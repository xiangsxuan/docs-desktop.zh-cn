---
title: XAML 概述
description: 了解适用于 .NET 的 Windows Presentation Foundation (WPF) 如何构造和实现 XAML 语言。
author: adegeo
ms.date: 12/03/2020
ms.author: adegeo
ms.topic: overview
dev_langs:
- csharp
- vb
helpviewer_keywords:
- user interfaces [XAML]
- classes [XAML]
- root element [XAML]
- XAML [WPF], about XAML
- base classes [XAML]
- routed events [WPF]
- code-behind files [WPF], XAML
- collection properties [XAML]
- events [XAML]
- property element [XAML]
- content models [XAML]
- Extensible Application Markup Language (see XAML)
- attribute syntax [XAML]
ms.openlocfilehash: 455f0eb49491250913998015f38948a2d864432e
ms.sourcegitcommit: 03df1de4077d996809eca885f6e2948774cf0fe7
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/04/2021
ms.locfileid: "102101603"
---
# <a name="xaml-overview-wpf-net"></a><span data-ttu-id="01b5a-103">XAML 概述 (WPF .NET)</span><span class="sxs-lookup"><span data-stu-id="01b5a-103">XAML overview (WPF .NET)</span></span>

<span data-ttu-id="01b5a-104">本本介绍 XAML 语言的功能，并演示如何使用 XAML 编写 Windows Presentation Foundation (WPF) 应用。</span><span class="sxs-lookup"><span data-stu-id="01b5a-104">This article describes the features of the XAML language and demonstrates how you can use XAML to write Windows Presentation Foundation (WPF) apps.</span></span> <span data-ttu-id="01b5a-105">本主题专门介绍 WPF 实现的 XAML。</span><span class="sxs-lookup"><span data-stu-id="01b5a-105">This article specifically describes XAML as implemented by WPF.</span></span> <span data-ttu-id="01b5a-106">XAML 本身是一个比 WPF 更大的语言概念。</span><span class="sxs-lookup"><span data-stu-id="01b5a-106">XAML itself is a larger language concept than WPF.</span></span>

[!INCLUDE [desktop guide under construction](../../includes/desktop-guide-preview-note.md)]

## <a name="what-is-xaml"></a><span data-ttu-id="01b5a-107">什么是 XAML</span><span class="sxs-lookup"><span data-stu-id="01b5a-107">What is XAML</span></span>

<span data-ttu-id="01b5a-108">XAML 是一种声明性标记语言。</span><span class="sxs-lookup"><span data-stu-id="01b5a-108">XAML is a declarative markup language.</span></span> <span data-ttu-id="01b5a-109">应用于 .NET Core 编程模型时，XAML 简化了为 .NET Core 应用创建 UI 的过程。</span><span class="sxs-lookup"><span data-stu-id="01b5a-109">As applied to the .NET Core programming model, XAML simplifies creating a UI for a .NET Core app.</span></span> <span data-ttu-id="01b5a-110">你可以在声明性 XAML 标记中创建可见的 UI 元素，然后使用代码隐藏文件（这些文件通过分部类定义与标记相联接）将 UI 定义与运行时逻辑相分离。</span><span class="sxs-lookup"><span data-stu-id="01b5a-110">You can create visible UI elements in the declarative XAML markup, and then separate the UI definition from the run-time logic by using code-behind files that are joined to the markup through partial class definitions.</span></span> <span data-ttu-id="01b5a-111">XAML 直接以程序集中定义的一组特定后备类型表示对象的实例化。</span><span class="sxs-lookup"><span data-stu-id="01b5a-111">XAML directly represents the instantiation of objects in a specific set of backing types defined in assemblies.</span></span> <span data-ttu-id="01b5a-112">这与大多数其他标记语言不同，后者通常是与后备类型系统没有此类直接关系的解释语言。</span><span class="sxs-lookup"><span data-stu-id="01b5a-112">This is unlike most other markup languages, which are typically an interpreted language without such a direct tie to a backing type system.</span></span> <span data-ttu-id="01b5a-113">XAML 实现了一个工作流，通过此工作流，各方可以采用不同的工具来处理 UI 和应用的逻辑。</span><span class="sxs-lookup"><span data-stu-id="01b5a-113">XAML enables a workflow where separate parties can work on the UI and the logic of an app, using potentially different tools.</span></span>

<span data-ttu-id="01b5a-114">以文本表示时，XAML 文件是通常具有 `.xaml` 扩展名的 XML 文件。</span><span class="sxs-lookup"><span data-stu-id="01b5a-114">When represented as text, XAML files are XML files that generally have the `.xaml` extension.</span></span> <span data-ttu-id="01b5a-115">可通过任何 XML 编码对文件进行编码，但通常以 UTF-8 编码。</span><span class="sxs-lookup"><span data-stu-id="01b5a-115">The files can be encoded by any XML encoding, but encoding as UTF-8 is typical.</span></span>

<span data-ttu-id="01b5a-116">以下示例演示如何创建 UI 中的按钮。</span><span class="sxs-lookup"><span data-stu-id="01b5a-116">The following example shows how you might create a button as part of a UI.</span></span> <span data-ttu-id="01b5a-117">此示例用于初步了解 XAML 如何表示常用 UI 编程形式（它不是一个完整的示例）。</span><span class="sxs-lookup"><span data-stu-id="01b5a-117">This example is intended to give you a flavor of how XAML represents common UI programming metaphors (it is not a complete sample).</span></span>

[!code-xaml[XAMLOvwSupport#DirtSimple](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page2.xaml#dirtsimple)]

## <a name="xaml-syntax-in-brief"></a><span data-ttu-id="01b5a-118">XAML 语法概述</span><span class="sxs-lookup"><span data-stu-id="01b5a-118">XAML syntax in brief</span></span>

<span data-ttu-id="01b5a-119">下面章节介绍 XAML 语法的基本形式，并提供一个简短的标记示例。</span><span class="sxs-lookup"><span data-stu-id="01b5a-119">The following sections explain the basic forms of XAML syntax, and give a short markup example.</span></span> <span data-ttu-id="01b5a-120">这些章节并不提供每个语法形式的完整信息，例如这些语法形式如何在后备类型系统中表示。</span><span class="sxs-lookup"><span data-stu-id="01b5a-120">These sections are not intended to provide complete information about each syntax form, such as how these are represented in the backing type system.</span></span> <span data-ttu-id="01b5a-121">有关 XAML 语法细节的详细信息，请参阅 [XAML 语法详述](../../../framework/wpf/advanced/xaml-syntax-in-detail.md)。</span><span class="sxs-lookup"><span data-stu-id="01b5a-121">For more information about the specifics of XAML syntax, see [XAML Syntax In Detail](../../../framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span>

<span data-ttu-id="01b5a-122">如果已熟悉 XML 语言，则下面几节中的很多材料对你而言都是基础知识。</span><span class="sxs-lookup"><span data-stu-id="01b5a-122">Much of the material in the next few sections will be elementary to you if you have previous familiarity with the XML language.</span></span> <span data-ttu-id="01b5a-123">这得益于 XAML 的一个基本设计原则。</span><span class="sxs-lookup"><span data-stu-id="01b5a-123">This is a consequence of one of the basic design principles of XAML.</span></span> <span data-ttu-id="01b5a-124">XAML 语言定义它自己的概念，但这些概念也适用于 XML 语言和标记形式。</span><span class="sxs-lookup"><span data-stu-id="01b5a-124">The XAML language defines concepts of its own, but these concepts work within the XML language and markup form.</span></span>

### <a name="xaml-object-elements"></a><span data-ttu-id="01b5a-125">XAML 对象元素</span><span class="sxs-lookup"><span data-stu-id="01b5a-125">XAML object elements</span></span>

<span data-ttu-id="01b5a-126">对象元素通常声明类型的实例。</span><span class="sxs-lookup"><span data-stu-id="01b5a-126">An object element typically declares an instance of a type.</span></span> <span data-ttu-id="01b5a-127">该类型在将 XAML 用作语言的技术所引用的程序集中定义。</span><span class="sxs-lookup"><span data-stu-id="01b5a-127">That type is defined in the assemblies referenced by the technology that uses XAML as a language.</span></span>

<span data-ttu-id="01b5a-128">对象元素语法始终以左尖括号 (`<`) 开头。</span><span class="sxs-lookup"><span data-stu-id="01b5a-128">Object element syntax always starts with an opening angle bracket (`<`).</span></span> <span data-ttu-id="01b5a-129">后跟要创建实例的类型的名称。</span><span class="sxs-lookup"><span data-stu-id="01b5a-129">This is followed by the name of the type where you want to create an instance.</span></span> <span data-ttu-id="01b5a-130">（该名称可能包含前缀，下文将解释前缀的概念。）此后可以选择声明该对象元素的特性。</span><span class="sxs-lookup"><span data-stu-id="01b5a-130">(The name can include a prefix, a concept that will be explained later.) After this, you can optionally declare attributes on the object element.</span></span> <span data-ttu-id="01b5a-131">要完成对象元素标记，请以右尖括号 (`>`) 结尾。</span><span class="sxs-lookup"><span data-stu-id="01b5a-131">To complete the object element tag, end with a closing angle bracket (`>`).</span></span> <span data-ttu-id="01b5a-132">也可以使用不含任何内容的自结束形式，方法是用一个正斜杠后接一个右尖括号 (`/>`) 来完成标记。</span><span class="sxs-lookup"><span data-stu-id="01b5a-132">You can instead use a self-closing form that does not have any content, by completing the tag with a forward slash and closing angle bracket in succession (`/>`).</span></span> <span data-ttu-id="01b5a-133">例如，请再次查看之前演示的标记片段。</span><span class="sxs-lookup"><span data-stu-id="01b5a-133">For example, look at the previously shown markup snippet again.</span></span>

[!code-xaml[XAMLOvwSupport#DirtSimple](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page2.xaml#dirtsimple)]

<span data-ttu-id="01b5a-134">这指定了两个对象元素：`<StackPanel>`（含有内容，后面有一个结束标记）和 `<Button .../>`（自结束形式，包含几个特性）。</span><span class="sxs-lookup"><span data-stu-id="01b5a-134">This specifies two object elements: `<StackPanel>` (with content, and a closing tag later), and `<Button .../>` (the self-closing form, with several attributes).</span></span> <span data-ttu-id="01b5a-135">对象元素 `StackPanel` 和 `Button` 各映射到一个类名，该类由 WPF 定义并且属于 WPF 程序集。</span><span class="sxs-lookup"><span data-stu-id="01b5a-135">The object elements `StackPanel` and `Button` each map to the name of a class that is defined by WPF and is part of the WPF assemblies.</span></span> <span data-ttu-id="01b5a-136">指定对象元素标记时，会创建一条指令，指示 XAML 处理创建基础类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="01b5a-136">When you specify an object element tag, you create an instruction for XAML processing to create a new instance of the underlying type.</span></span> <span data-ttu-id="01b5a-137">每个实例都是在分析和加载 XAML 时通过调用基础类型的无参数构造函数来创建。</span><span class="sxs-lookup"><span data-stu-id="01b5a-137">Each instance is created by calling the parameterless constructor of the underlying type when parsing and loading the XAML.</span></span>

### <a name="attribute-syntax-properties"></a><span data-ttu-id="01b5a-138">特性语法（属性）</span><span class="sxs-lookup"><span data-stu-id="01b5a-138">Attribute syntax (properties)</span></span>

<span data-ttu-id="01b5a-139">对象的属性通常可表示为对象元素的特性。</span><span class="sxs-lookup"><span data-stu-id="01b5a-139">Properties of an object can often be expressed as attributes of the object element.</span></span> <span data-ttu-id="01b5a-140">特性语法对设置的对象属性命名，后跟赋值运算符 (=)。</span><span class="sxs-lookup"><span data-stu-id="01b5a-140">The attribute syntax names the object property that is being set, followed by the assignment operator (=).</span></span> <span data-ttu-id="01b5a-141">特性的值始终指定为包含在引号中的字符串。</span><span class="sxs-lookup"><span data-stu-id="01b5a-141">The value of an attribute is always specified as a string that is contained within quotation marks.</span></span>

<span data-ttu-id="01b5a-142">特性语法是最简化的属性设置语法，并且对曾使用过标记语言的开发人员而言是最直观的语法。</span><span class="sxs-lookup"><span data-stu-id="01b5a-142">Attribute syntax is the most streamlined property setting syntax and is the most intuitive syntax to use for developers who have used markup languages in the past.</span></span> <span data-ttu-id="01b5a-143">例如，以下标记将创建一个具有红色文本和蓝色背景的按钮，还将创建指定为 `Content` 的显示文本。</span><span class="sxs-lookup"><span data-stu-id="01b5a-143">For example, the following markup creates a button that has red text and a blue background in addition to display text specified as `Content`.</span></span>

[!code-xaml[XAMLOvwSupport#BlueRedButton](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#blueredbutton)]

### <a name="property-element-syntax"></a><span data-ttu-id="01b5a-144">属性元素语法</span><span class="sxs-lookup"><span data-stu-id="01b5a-144">Property element syntax</span></span>

<span data-ttu-id="01b5a-145">对于对象元素的某些属性，无法使用特性语法，因为无法在特性语法的引号和字符串限制内充分地表达提供属性值所必需的对象或信息。</span><span class="sxs-lookup"><span data-stu-id="01b5a-145">For some properties of an object element, attribute syntax is not possible, because the object or information necessary to provide the property value cannot be adequately expressed within the quotation mark and string restrictions of attribute syntax.</span></span> <span data-ttu-id="01b5a-146">对于这些情况，可以使用另一个语法，即属性元素语法。</span><span class="sxs-lookup"><span data-stu-id="01b5a-146">For these cases, a different syntax known as property element syntax can be used.</span></span>

<span data-ttu-id="01b5a-147">属性元素开始标记的语法为 `<TypeName.PropertyName>`。</span><span class="sxs-lookup"><span data-stu-id="01b5a-147">The syntax for the property element start tag is `<TypeName.PropertyName>`.</span></span> <span data-ttu-id="01b5a-148">通常，该标记的内容是类型的对象元素，属性会将该元素作为其值。</span><span class="sxs-lookup"><span data-stu-id="01b5a-148">Generally, the content of that tag is an object element of the type that the property takes as its value.</span></span> <span data-ttu-id="01b5a-149">指定内容之后，必须用结束标记结束属性元素。</span><span class="sxs-lookup"><span data-stu-id="01b5a-149">After specifying the content, you must close the property element with an end tag.</span></span> <span data-ttu-id="01b5a-150">结束标记的语法为 `</TypeName.PropertyName>`。</span><span class="sxs-lookup"><span data-stu-id="01b5a-150">The syntax for the end tag is `</TypeName.PropertyName>`.</span></span>

<span data-ttu-id="01b5a-151">如果可以使用特性语法，那么使用特性语法通常更为方便，且能够实现更为精简的标记，但这通常只是样式问题，而不是技术限制。</span><span class="sxs-lookup"><span data-stu-id="01b5a-151">If an attribute syntax is possible, using the attribute syntax is typically more convenient and enables a more compact markup, but that is often just a matter of style, not a technical limitation.</span></span> <span data-ttu-id="01b5a-152">以下示例演示在前面的特性语法示例中设置的相同属性，但这次对 `Button` 的所有属性使用属性元素语法。</span><span class="sxs-lookup"><span data-stu-id="01b5a-152">The following example shows the same properties being set as in the previous attribute syntax example, but this time by using property element syntax for all properties of the `Button`.</span></span>

[!code-xaml[XAMLOvwSupport#BlueRedButtonPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#blueredbuttonpe)]

### <a name="collection-syntax"></a><span data-ttu-id="01b5a-153">集合语法</span><span class="sxs-lookup"><span data-stu-id="01b5a-153">Collection syntax</span></span>

<span data-ttu-id="01b5a-154">XAML 语言包含一些优化，可以生成更易于阅读的标记。</span><span class="sxs-lookup"><span data-stu-id="01b5a-154">The XAML language includes some optimizations that produce more human-readable markup.</span></span> <span data-ttu-id="01b5a-155">其中一项优化是：如果某个特定属性采用集合类型，则在标记中声明为该属性的值内的子元素的项将成为集合的一部分。</span><span class="sxs-lookup"><span data-stu-id="01b5a-155">One such optimization is that if a particular property takes a collection type, then items that you declare in markup as child elements within that property's value become part of the collection.</span></span> <span data-ttu-id="01b5a-156">在这种情况下，子对象元素的集合是设置为集合属性的值。</span><span class="sxs-lookup"><span data-stu-id="01b5a-156">In this case a collection of child object elements is the value being set to the collection property.</span></span>

<span data-ttu-id="01b5a-157">下面的示例演示用于设置 <xref:System.Windows.Media.GradientBrush.GradientStops%2A> 属性的值的集合语法。</span><span class="sxs-lookup"><span data-stu-id="01b5a-157">The following example shows collection syntax for setting values of the <xref:System.Windows.Media.GradientBrush.GradientStops%2A> property.</span></span>

```xaml
<LinearGradientBrush>
  <LinearGradientBrush.GradientStops>
    <!-- no explicit new GradientStopCollection, parser knows how to find or create -->
    <GradientStop Offset="0.0" Color="Red" />
    <GradientStop Offset="1.0" Color="Blue" />
  </LinearGradientBrush.GradientStops>
</LinearGradientBrush>
```

### <a name="xaml-content-properties"></a><span data-ttu-id="01b5a-158">XAML 内容属性</span><span class="sxs-lookup"><span data-stu-id="01b5a-158">XAML content properties</span></span>

<span data-ttu-id="01b5a-159">XAML 指定了一个语言功能，通过该功能，类可以指定它的一个且仅一个属性为 XAML 内容  属性。</span><span class="sxs-lookup"><span data-stu-id="01b5a-159">XAML specifies a language feature whereby a class can designate exactly one of its properties to be the XAML _content_ property.</span></span> <span data-ttu-id="01b5a-160">该对象元素的子元素用于设置该内容属性的值。</span><span class="sxs-lookup"><span data-stu-id="01b5a-160">Child elements of that object element are used to set the value of that content property.</span></span> <span data-ttu-id="01b5a-161">换言之，仅对内容属性而言，可以在 XAML 标记中设置该属性时省略属性元素，并在标记中生成更直观的父级/子级形式。</span><span class="sxs-lookup"><span data-stu-id="01b5a-161">In other words, for the content property uniquely, you can omit a property element when setting that property in XAML markup and produce a more visible parent/child metaphor in the markup.</span></span>

<span data-ttu-id="01b5a-162">例如，<xref:System.Windows.Controls.Border> 指定 <xref:System.Windows.Controls.Decorator.Child%2A> 的内容  属性。</span><span class="sxs-lookup"><span data-stu-id="01b5a-162">For example, <xref:System.Windows.Controls.Border> specifies a _content_ property of <xref:System.Windows.Controls.Decorator.Child%2A>.</span></span> <span data-ttu-id="01b5a-163">以下两个 <xref:System.Windows.Controls.Border> 元素的处理方式相同。</span><span class="sxs-lookup"><span data-stu-id="01b5a-163">The following two <xref:System.Windows.Controls.Border> elements are treated identically.</span></span> <span data-ttu-id="01b5a-164">第一个元素利用内容属性语法并省略 `Border.Child` 属性元素。</span><span class="sxs-lookup"><span data-stu-id="01b5a-164">The first one takes advantage of the content property syntax and omits the `Border.Child` property element.</span></span> <span data-ttu-id="01b5a-165">第二个元素显式显示 `Border.Child`。</span><span class="sxs-lookup"><span data-stu-id="01b5a-165">The second one shows `Border.Child` explicitly.</span></span>

```xaml
<Border>
  <TextBox Width="300"/>
</Border>
<!--explicit equivalent-->
<Border>
  <Border.Child>
    <TextBox Width="300"/>
  </Border.Child>
</Border>
```

<span data-ttu-id="01b5a-166">作为 XAML 语言的规则，XAML 内容属性的值必须完全在该对象元素的其他任何属性元素之前或之后指定。</span><span class="sxs-lookup"><span data-stu-id="01b5a-166">As a rule of the XAML language, the value of a XAML content property must be given either entirely before or entirely after any other property elements on that object element.</span></span> <span data-ttu-id="01b5a-167">例如，以下标记不会进行编译。</span><span class="sxs-lookup"><span data-stu-id="01b5a-167">For instance, the following markup does not compile.</span></span>

```xaml
<Button>I am a
  <Button.Background>Blue</Button.Background>
  blue button</Button>
```

<span data-ttu-id="01b5a-168">有关 XAML 语法细节的详细信息，请参阅 [XAML 语法详述](../../../framework/wpf/advanced/xaml-syntax-in-detail.md)。</span><span class="sxs-lookup"><span data-stu-id="01b5a-168">For more information about the specifics of XAML syntax, see [XAML Syntax In Detail](../../../framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span>

### <a name="text-content"></a><span data-ttu-id="01b5a-169">文本内容</span><span class="sxs-lookup"><span data-stu-id="01b5a-169">Text content</span></span>

<span data-ttu-id="01b5a-170">有少量 XAML 元素可直接将文本作为其内容来处理。</span><span class="sxs-lookup"><span data-stu-id="01b5a-170">A small number of XAML elements can directly process text as their content.</span></span> <span data-ttu-id="01b5a-171">若要实现此功能，必须满足以下条件之一：</span><span class="sxs-lookup"><span data-stu-id="01b5a-171">To enable this, one of the following cases must be true:</span></span>

- <span data-ttu-id="01b5a-172">类必须声明一个内容属性，并且该内容属性必须是可赋值给字符串的类型（该类型可以是 <xref:System.Object>）。</span><span class="sxs-lookup"><span data-stu-id="01b5a-172">The class must declare a content property, and that content property must be of a type assignable to a string (the type could be <xref:System.Object>).</span></span> <span data-ttu-id="01b5a-173">例如，任何 <xref:System.Windows.Controls.ContentControl> 都使用 <xref:System.Windows.Controls.ContentControl.Content%2A> 作为其内容属性，并且它属于类型 <xref:System.Object>，这对于 <xref:System.Windows.Controls.ContentControl>（如 <xref:System.Windows.Controls.Button>）支持以下用法：`<Button>Hello</Button>`。</span><span class="sxs-lookup"><span data-stu-id="01b5a-173">For instance, any <xref:System.Windows.Controls.ContentControl> uses <xref:System.Windows.Controls.ContentControl.Content%2A> as its content property and it is type <xref:System.Object>, and this supports the following usage on a <xref:System.Windows.Controls.ContentControl> such as a <xref:System.Windows.Controls.Button>: `<Button>Hello</Button>`.</span></span>

- <span data-ttu-id="01b5a-174">类型必须声明一个类型转换器，该类型转换器将文本内容用作初始化文本。</span><span class="sxs-lookup"><span data-stu-id="01b5a-174">The type must declare a type converter, in which case the text content is used as initialization text for that type converter.</span></span> <span data-ttu-id="01b5a-175">例如，`<Brush>Blue</Brush>` 将 `Blue` 的内容值转换为画笔。</span><span class="sxs-lookup"><span data-stu-id="01b5a-175">For example, `<Brush>Blue</Brush>` converts the content value of `Blue` into a brush.</span></span> <span data-ttu-id="01b5a-176">这种情况实际上并不常见。</span><span class="sxs-lookup"><span data-stu-id="01b5a-176">This case is less common in practice.</span></span>

- <span data-ttu-id="01b5a-177">类型必须为已知的 XAML 语言基元。</span><span class="sxs-lookup"><span data-stu-id="01b5a-177">The type must be a known XAML language primitive.</span></span>

### <a name="content-properties-and-collection-syntax-combined"></a><span data-ttu-id="01b5a-178">内容属性和集合语法组合</span><span class="sxs-lookup"><span data-stu-id="01b5a-178">Content properties and collection syntax combined</span></span>

<span data-ttu-id="01b5a-179">考虑以下示例。</span><span class="sxs-lookup"><span data-stu-id="01b5a-179">Consider this example.</span></span>

```xaml
<StackPanel>
  <Button>First Button</Button>
  <Button>Second Button</Button>
</StackPanel>
```

<span data-ttu-id="01b5a-180">此处，每个 <xref:System.Windows.Controls.Button> 都是 <xref:System.Windows.Controls.StackPanel> 的子元素。</span><span class="sxs-lookup"><span data-stu-id="01b5a-180">Here, each <xref:System.Windows.Controls.Button> is a child element of <xref:System.Windows.Controls.StackPanel>.</span></span> <span data-ttu-id="01b5a-181">这是一个简单直观的标记，此标记由于两个不同的原因省略了两个标记。</span><span class="sxs-lookup"><span data-stu-id="01b5a-181">This is a streamlined and intuitive markup that omits two tags for two different reasons.</span></span>

- <span data-ttu-id="01b5a-182">省略了 StackPanel.Children 属性元素：  <xref:System.Windows.Controls.StackPanel> 派生自 <xref:System.Windows.Controls.Panel>。</span><span class="sxs-lookup"><span data-stu-id="01b5a-182">**Omitted StackPanel.Children property element:** <xref:System.Windows.Controls.StackPanel> derives from <xref:System.Windows.Controls.Panel>.</span></span> <span data-ttu-id="01b5a-183"><xref:System.Windows.Controls.Panel> 将 <xref:System.Windows.Controls.Panel.Children%2A?displayProperty=nameWithType> 定义为其 XAML 内容属性。</span><span class="sxs-lookup"><span data-stu-id="01b5a-183"><xref:System.Windows.Controls.Panel> defines <xref:System.Windows.Controls.Panel.Children%2A?displayProperty=nameWithType> as its XAML content property.</span></span>

- <span data-ttu-id="01b5a-184">省略了 UIElementCollection 对象元素：  <xref:System.Windows.Controls.Panel.Children%2A?displayProperty=nameWithType> 属性采用类型 <xref:System.Windows.Controls.UIElementCollection>，该类型实现 <xref:System.Collections.IList>。</span><span class="sxs-lookup"><span data-stu-id="01b5a-184">**Omitted UIElementCollection object element:** The <xref:System.Windows.Controls.Panel.Children%2A?displayProperty=nameWithType> property takes the type <xref:System.Windows.Controls.UIElementCollection>, which implements <xref:System.Collections.IList>.</span></span> <span data-ttu-id="01b5a-185">根据处理 <xref:System.Collections.IList> 等集合的 XAML 规则，集合的元素标记可以省略。</span><span class="sxs-lookup"><span data-stu-id="01b5a-185">The collection's element tag can be omitted, based on the XAML rules for processing collections such as <xref:System.Collections.IList>.</span></span> <span data-ttu-id="01b5a-186">（在本例中，<xref:System.Windows.Controls.UIElementCollection> 实际上无法实例化，因为它不公开无参数构造函数，这便是 <xref:System.Windows.Controls.UIElementCollection> 对象元素显示为注释掉的原因）。</span><span class="sxs-lookup"><span data-stu-id="01b5a-186">(In this case, <xref:System.Windows.Controls.UIElementCollection> actually cannot be instantiated because it does not expose a parameterless constructor, and that is why the <xref:System.Windows.Controls.UIElementCollection> object element is shown commented out).</span></span>

```xaml
<StackPanel>
  <StackPanel.Children>
    <!--<UIElementCollection>-->
    <Button>First Button</Button>
    <Button>Second Button</Button>
    <!--</UIElementCollection>-->
  </StackPanel.Children>
</StackPanel>
```

### <a name="attribute-syntax-events"></a><span data-ttu-id="01b5a-187">特性语法（事件）</span><span class="sxs-lookup"><span data-stu-id="01b5a-187">Attribute syntax (events)</span></span>

<span data-ttu-id="01b5a-188">特性语法还可用于事件成员，而非属性成员。</span><span class="sxs-lookup"><span data-stu-id="01b5a-188">Attribute syntax can also be used for members that are events rather than properties.</span></span> <span data-ttu-id="01b5a-189">在这种情况下，特性的名称为事件的名称。</span><span class="sxs-lookup"><span data-stu-id="01b5a-189">In this case, the attribute's name is the name of the event.</span></span> <span data-ttu-id="01b5a-190">在 XAML 事件的 WPF 实现中，特性的值是实现该事件的委托的处理程序的名称。</span><span class="sxs-lookup"><span data-stu-id="01b5a-190">In the WPF implementation of events for XAML, the attribute's value is the name of a handler that implements that event's delegate.</span></span> <span data-ttu-id="01b5a-191">例如，以下标记将 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 事件的处理程序分配给在标记中创建的 <xref:System.Windows.Controls.Button>：</span><span class="sxs-lookup"><span data-stu-id="01b5a-191">For example, the following markup assigns a handler for the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event to a <xref:System.Windows.Controls.Button> created in markup:</span></span>

[!code-xaml[XAMLOvwSupport#ButtonWithCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page3.xaml#buttonwithcodebehind)]

<span data-ttu-id="01b5a-192">除此特性语法示例外，还有更多关于 WPF 中的事件和 XAML 的内容。</span><span class="sxs-lookup"><span data-stu-id="01b5a-192">There is more to events and XAML in WPF than just this example of the attribute syntax.</span></span> <span data-ttu-id="01b5a-193">例如，可了解此处引用的 `ClickHandler` 表示什么，以及它是如何定义的。</span><span class="sxs-lookup"><span data-stu-id="01b5a-193">For example, you might wonder what the `ClickHandler` referenced here represents and how it is defined.</span></span> <span data-ttu-id="01b5a-194">这将在本文后面的[事件和 XAML 代码隐藏](#events-and-xaml-code-behind)一节中介绍。</span><span class="sxs-lookup"><span data-stu-id="01b5a-194">This will be explained in the upcoming [Events and XAML code-behind](#events-and-xaml-code-behind) section of this article.</span></span>

## <a name="case-and-white-space-in-xaml"></a><span data-ttu-id="01b5a-195">XAML 中的大小写和空白</span><span class="sxs-lookup"><span data-stu-id="01b5a-195">Case and white space in XAML</span></span>

<span data-ttu-id="01b5a-196">一般而言，XAML 区分大小写。</span><span class="sxs-lookup"><span data-stu-id="01b5a-196">In general, XAML is case-sensitive.</span></span> <span data-ttu-id="01b5a-197">出于解析后备类型的目的，WPF XAML 按照 CLR 区分大小写的相同规则区分大小写。</span><span class="sxs-lookup"><span data-stu-id="01b5a-197">For purposes of resolving backing types, WPF XAML is case-sensitive by the same rules that the CLR is case-sensitive.</span></span> <span data-ttu-id="01b5a-198">以下情况下，对象元素、属性元素和特性名称均必须使用区分大小写的形式指定：按名称与程序集中的基础类型进行比较或者与类型的成员进行比较。</span><span class="sxs-lookup"><span data-stu-id="01b5a-198">Object elements, property elements, and attribute names must all be specified by using the sensitive casing when compared by name to the underlying type in the assembly, or to a member of a type.</span></span> <span data-ttu-id="01b5a-199">XAML 语言关键字和基元也区分大小写。</span><span class="sxs-lookup"><span data-stu-id="01b5a-199">XAML language keywords and primitives are also case-sensitive.</span></span> <span data-ttu-id="01b5a-200">值并不总是区分大小写。</span><span class="sxs-lookup"><span data-stu-id="01b5a-200">Values are not always case-sensitive.</span></span> <span data-ttu-id="01b5a-201">值是否区分大小写将取决于与采用该值的属性关联的类型转换器行为，或取决于属性值类型。</span><span class="sxs-lookup"><span data-stu-id="01b5a-201">Case sensitivity for values will depend on the type converter behavior associated with the property that takes the value, or the property value type.</span></span> <span data-ttu-id="01b5a-202">例如，采用 <xref:System.Boolean> 类型的属性可以采用 `true` 或 `True` 作为等效值，但只是因为将字符串转换为 <xref:System.Boolean> 的本机 WPF XAML 分析程序类型转换已经允许将这些值作为等效值。</span><span class="sxs-lookup"><span data-stu-id="01b5a-202">For example, properties that take the <xref:System.Boolean> type can take either `true` or `True` as equivalent values, but only because the native WPF XAML parser type conversion for string to <xref:System.Boolean> already permits these as equivalents.</span></span>

<span data-ttu-id="01b5a-203">WPF XAML 处理器和序列化程序将忽略或删除所有无意义的空白，并标准化任何有意义的空白。</span><span class="sxs-lookup"><span data-stu-id="01b5a-203">WPF XAML processors and serializers will ignore or drop all nonsignificant white space, and will normalize any significant white space.</span></span> <span data-ttu-id="01b5a-204">这与 XAML 规范的默认空白行为建议一致。</span><span class="sxs-lookup"><span data-stu-id="01b5a-204">This is consistent with the default white-space behavior recommendations of the XAML specification.</span></span> <span data-ttu-id="01b5a-205">只有在 XAML 内容属性中指定字符串时，此行为的重要性才会体现出来。</span><span class="sxs-lookup"><span data-stu-id="01b5a-205">This behavior is only of consequence when you specify strings within XAML content properties.</span></span> <span data-ttu-id="01b5a-206">简言之，XAML 将空格、换行符和制表符转化为空格，如果它们出现在一个连续字符串的任一端，则保留一个空格。</span><span class="sxs-lookup"><span data-stu-id="01b5a-206">In simplest terms, XAML converts space, linefeed, and tab characters into spaces, and then preserves one space if found at either end of a contiguous string.</span></span> <span data-ttu-id="01b5a-207">本文不包含有关 XAML 空白处理的完整说明。</span><span class="sxs-lookup"><span data-stu-id="01b5a-207">The full explanation of XAML white-space handling is not covered in this article.</span></span> <span data-ttu-id="01b5a-208">有关详细信息，请参阅 [XAML 中的空白处理](../../../xaml-services/white-space-processing.md)。</span><span class="sxs-lookup"><span data-stu-id="01b5a-208">For more information, see [White space processing in XAML](../../../xaml-services/white-space-processing.md).</span></span>

## <a name="markup-extensions"></a><span data-ttu-id="01b5a-209">标记扩展</span><span class="sxs-lookup"><span data-stu-id="01b5a-209">Markup extensions</span></span>

<span data-ttu-id="01b5a-210">标记扩展是一个 XAML 语言概念。</span><span class="sxs-lookup"><span data-stu-id="01b5a-210">Markup extensions are a XAML language concept.</span></span> <span data-ttu-id="01b5a-211">用于提供特性语法的值时，大括号（`{` 和 `}`）表示标记扩展用法。</span><span class="sxs-lookup"><span data-stu-id="01b5a-211">When used to provide the value of an attribute syntax, curly braces (`{` and `}`) indicate a markup extension usage.</span></span> <span data-ttu-id="01b5a-212">此用法指示 XAML 处理不要像通常那样将特性值视为文本字符串或者可转换为字符串的值。</span><span class="sxs-lookup"><span data-stu-id="01b5a-212">This usage directs the XAML processing to escape from the general treatment of attribute values as either a literal string or a string-convertible value.</span></span>

<span data-ttu-id="01b5a-213">WPF 应用编程中最常用的标记扩展是 [`Binding`](../../../framework/wpf/advanced/binding-markup-extension.md)（用于数据绑定表达式）以及资源引用 [`StaticResource`](../../../framework/wpf/advanced/staticresource-markup-extension.md) 和 [`DynamicResource`](../../../framework/wpf/advanced/dynamicresource-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="01b5a-213">The most common markup extensions used in WPF app programming are [`Binding`](../../../framework/wpf/advanced/binding-markup-extension.md), used for data binding expressions, and the resource references [`StaticResource`](../../../framework/wpf/advanced/staticresource-markup-extension.md) and [`DynamicResource`](../../../framework/wpf/advanced/dynamicresource-markup-extension.md).</span></span> <span data-ttu-id="01b5a-214">通过使用标记扩展，即使属性通常不支持特性语法，也可以使用特性语法为属性提供值。</span><span class="sxs-lookup"><span data-stu-id="01b5a-214">By using markup extensions, you can use attribute syntax to provide values for properties even if that property does not support an attribute syntax in general.</span></span> <span data-ttu-id="01b5a-215">标记扩展经常使用中间表达式类型实现一些功能，例如，推迟值或引用仅在运行时才存在的其他对象。</span><span class="sxs-lookup"><span data-stu-id="01b5a-215">Markup extensions often use intermediate expression types to enable features such as deferring values or referencing other objects that are only present at run-time.</span></span>

<span data-ttu-id="01b5a-216">例如，以下标记使用特性语法设置 <xref:System.Windows.FrameworkElement.Style%2A> 属性的值。</span><span class="sxs-lookup"><span data-stu-id="01b5a-216">For example, the following markup sets the value of the <xref:System.Windows.FrameworkElement.Style%2A> property using attribute syntax.</span></span> <span data-ttu-id="01b5a-217"><xref:System.Windows.FrameworkElement.Style%2A> 属性采用 <xref:System.Windows.Style> 类的实例，该类在默认情况下无法由特性语法字符串进行实例化。</span><span class="sxs-lookup"><span data-stu-id="01b5a-217">The <xref:System.Windows.FrameworkElement.Style%2A> property takes an instance of the <xref:System.Windows.Style> class, which by default could not be instantiated by an attribute syntax string.</span></span> <span data-ttu-id="01b5a-218">但在本例中，特性引用了特定的标记扩展 `StaticResource`。</span><span class="sxs-lookup"><span data-stu-id="01b5a-218">But in this case, the attribute references a particular markup extension, `StaticResource`.</span></span> <span data-ttu-id="01b5a-219">处理该标记扩展时，将返回对以前在资源字典中作为键控资源进行实例化的某个样式的引用。</span><span class="sxs-lookup"><span data-stu-id="01b5a-219">When that markup extension is processed, it returns a reference to a style that was previously instantiated as a keyed resource in a resource dictionary.</span></span>

[!code-xaml[FEResourceSH_snip#XAMLOvwShortResources](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResourceSH_snip/CS/page1.xaml#xamlovwshortresources)]
[!code-xaml[FEResourceSH_snip#XAMLOvwShortResources2](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResourceSH_snip/CS/page1.xaml#xamlovwshortresources2)]
[!code-xaml[FEResourceSH_snip#XAMLOvwShortResources3](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResourceSH_snip/CS/page1.xaml#xamlovwshortresources3)]

<span data-ttu-id="01b5a-220">有关特定在 WPF 中实现的所有 XAML 标记扩展的参考列表，请参阅 [WPF XAML 扩展](../../../framework/wpf/advanced/wpf-xaml-extensions.md)。</span><span class="sxs-lookup"><span data-stu-id="01b5a-220">For a reference listing of all markup extensions for XAML implemented specifically in WPF, see [WPF XAML Extensions](../../../framework/wpf/advanced/wpf-xaml-extensions.md).</span></span> <span data-ttu-id="01b5a-221">有关由 System.Xaml 定义并且可更广泛用于 .NET Core XAML 实现的标记扩展的参考列表，请参阅 [XAML 命名空间 (x:)语言功能](../../../xaml-services/namespace-language-features.md)。</span><span class="sxs-lookup"><span data-stu-id="01b5a-221">For a reference listing of the markup extensions that are defined by System.Xaml and are more widely available for .NET Core XAML implementations, see [XAML Namespace (x:) Language Features](../../../xaml-services/namespace-language-features.md).</span></span> <span data-ttu-id="01b5a-222">有关标记扩展概念的详细信息，请参阅[标记扩展和 WPF XAML](../../../framework/wpf/advanced/markup-extensions-and-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="01b5a-222">For more information about markup extension concepts, see [Markup Extensions and WPF XAML](../../../framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).</span></span>

## <a name="type-converters"></a><span data-ttu-id="01b5a-223">类型转换器</span><span class="sxs-lookup"><span data-stu-id="01b5a-223">Type converters</span></span>

<span data-ttu-id="01b5a-224">在 [XAML 语法概述](#xaml-syntax-in-brief)一节中，曾提到特性值必须能够通过字符串进行设置。</span><span class="sxs-lookup"><span data-stu-id="01b5a-224">In the [XAML Syntax in Brief](#xaml-syntax-in-brief) section, it was stated that the attribute value must be able to be set by a string.</span></span> <span data-ttu-id="01b5a-225">对字符串如何转换为其他对象类型或基元值的基本本机处理取决于 <xref:System.String> 类型本身，以及对某些类型（如 <xref:System.DateTime> 或 <xref:System.Uri>）的本机处理。</span><span class="sxs-lookup"><span data-stu-id="01b5a-225">The basic, native handling of how strings are converted into other object types or primitive values is based on the <xref:System.String> type itself, in addition to native processing for certain types such as <xref:System.DateTime> or <xref:System.Uri>.</span></span> <span data-ttu-id="01b5a-226">但是很多 WPF 类型或这些类型的成员扩展了基本字符串特性处理行为，因此可以将更复杂的对象类型的实例指定为字符串和特性。</span><span class="sxs-lookup"><span data-stu-id="01b5a-226">But many WPF types or members of those types extend the basic string attribute processing behavior in such a way that instances of more complex object types can be specified as strings and attributes.</span></span>

<span data-ttu-id="01b5a-227"><xref:System.Windows.Thickness> 结构是一个类型示例，该类型拥有可使用 XAML 的类型转换。</span><span class="sxs-lookup"><span data-stu-id="01b5a-227">The <xref:System.Windows.Thickness> structure is an example of a type that has a type conversion enabled for XAML usages.</span></span> <span data-ttu-id="01b5a-228"><xref:System.Windows.Thickness> 指示嵌套矩形中的度量，可用作属性（如 <xref:System.Windows.FrameworkElement.Margin%2A>）的值。</span><span class="sxs-lookup"><span data-stu-id="01b5a-228"><xref:System.Windows.Thickness> indicates measurements within a nested rectangle and is used as the value for properties such as <xref:System.Windows.FrameworkElement.Margin%2A>.</span></span> <span data-ttu-id="01b5a-229">通过对 <xref:System.Windows.Thickness> 放置类型转换器，所有使用 <xref:System.Windows.Thickness> 的属性都可以更容易地在 XAML 中指定，因为它们可指定为特性。</span><span class="sxs-lookup"><span data-stu-id="01b5a-229">By placing a type converter on <xref:System.Windows.Thickness>, all properties that use a <xref:System.Windows.Thickness> are easier to specify in XAML because they can be specified as attributes.</span></span> <span data-ttu-id="01b5a-230">以下示例使用类型转换和特性语法来为 <xref:System.Windows.FrameworkElement.Margin%2A> 提供值：</span><span class="sxs-lookup"><span data-stu-id="01b5a-230">The following example uses a type conversion and attribute syntax to provide a value for a <xref:System.Windows.FrameworkElement.Margin%2A>:</span></span>

[!code-xaml[XAMLOvwSupport#MarginTCE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page7.xaml#margintce)]

<span data-ttu-id="01b5a-231">以上特性语法示例与下面更为详细的语法示例等效，但在下面的示例中，<xref:System.Windows.FrameworkElement.Margin%2A> 改为通过包含 <xref:System.Windows.Thickness> 对象元素的属性元素语法进行设置。</span><span class="sxs-lookup"><span data-stu-id="01b5a-231">The previous attribute syntax example is equivalent to the following more verbose syntax example, where the <xref:System.Windows.FrameworkElement.Margin%2A> is instead set through property element syntax containing a <xref:System.Windows.Thickness> object element.</span></span> <span data-ttu-id="01b5a-232">而且将 <xref:System.Windows.Thickness> 的四个关键属性设置为新实例的特性：</span><span class="sxs-lookup"><span data-stu-id="01b5a-232">The four key properties of <xref:System.Windows.Thickness> are set as attributes on the new instance:</span></span>

[!code-xaml[XAMLOvwSupport#MarginVerbose](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page7.xaml#marginverbose)]

> [!NOTE]
> <span data-ttu-id="01b5a-233">对于少数对象，类型转换是在不涉及子类的情况下将属性设置为此类型的唯一公开方式，因为类型自身没有无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="01b5a-233">There are also a limited number of objects where the type conversion is the only public way to set a property to that type without involving a subclass, because the type itself does not have a parameterless constructor.</span></span> <span data-ttu-id="01b5a-234">示例为 <xref:System.Windows.Input.Cursor>。</span><span class="sxs-lookup"><span data-stu-id="01b5a-234">An example is <xref:System.Windows.Input.Cursor>.</span></span>

<span data-ttu-id="01b5a-235">有关类型转换的详细信息，请参阅 [TypeConverters 和 XAML](../../../framework/wpf/advanced/typeconverters-and-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="01b5a-235">For more information on type conversion, see [TypeConverters and XAML](../../../framework/wpf/advanced/typeconverters-and-xaml.md).</span></span>

## <a name="xaml-root-elements-and-xaml-namespaces"></a><span data-ttu-id="01b5a-236">XAML 根元素和 XAML 命名空间</span><span class="sxs-lookup"><span data-stu-id="01b5a-236">XAML root elements and XAML namespaces</span></span>

<span data-ttu-id="01b5a-237">一个 XAML 文件只能有一个根元素，这样才能同时作为格式正确的 XML 文件和有效的 XAML 文件。</span><span class="sxs-lookup"><span data-stu-id="01b5a-237">A XAML file must have only one root element, in order to be both a well-formed XML file and a valid XAML file.</span></span> <span data-ttu-id="01b5a-238">对于典型 WPF 方案，可使用在 WPF 应用模型中具有突出意义的根元素（例如，页面的 <xref:System.Windows.Window> 或 <xref:System.Windows.Controls.Page>、外部字典的 <xref:System.Windows.ResourceDictionary> 或应用定义的 <xref:System.Windows.Application>）。</span><span class="sxs-lookup"><span data-stu-id="01b5a-238">For typical WPF scenarios, you use a root element that has a prominent meaning in the WPF app model (for example, <xref:System.Windows.Window> or <xref:System.Windows.Controls.Page> for a page, <xref:System.Windows.ResourceDictionary> for an external dictionary, or <xref:System.Windows.Application> for the app definition).</span></span> <span data-ttu-id="01b5a-239">以下示例演示 WPF 页的典型 XAML 文件的根元素，此根元素为 <xref:System.Windows.Controls.Page>。</span><span class="sxs-lookup"><span data-stu-id="01b5a-239">The following example shows the root element of a typical XAML file for a WPF page, with the root element of <xref:System.Windows.Controls.Page>.</span></span>

[!code-xaml[XAMLOvwSupport#RootOnly](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page2.xaml#rootonly)]
[!code-xaml[XAMLOvwSupport#RootOnly2](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page2.xaml#rootonly2)]

<span data-ttu-id="01b5a-240">根元素还包含特性 `xmlns` 和 `xmlns:x`。</span><span class="sxs-lookup"><span data-stu-id="01b5a-240">The root element also contains the attributes `xmlns` and `xmlns:x`.</span></span> <span data-ttu-id="01b5a-241">这些特性向 XAML 处理器指示哪些 XAML 命名空间包含标记将其作为元素引用的后备类型的类型定义。</span><span class="sxs-lookup"><span data-stu-id="01b5a-241">These attributes indicate to a XAML processor which XAML namespaces contain the type definitions for backing types that the markup will reference as elements.</span></span> <span data-ttu-id="01b5a-242">`xmlns` 特性明确指示默认的 XAML 命名空间。</span><span class="sxs-lookup"><span data-stu-id="01b5a-242">The `xmlns` attribute specifically indicates the default XAML namespace.</span></span> <span data-ttu-id="01b5a-243">在默认的 XAML 命名空间中，可以不使用前缀指定标记中的对象元素。</span><span class="sxs-lookup"><span data-stu-id="01b5a-243">Within the default XAML namespace, object elements in the markup can be specified without a prefix.</span></span> <span data-ttu-id="01b5a-244">对于大多数 WPF 应用程序方案以及 SDK 的 WPF 部分中给出的几乎所有示例，默认的 XAML 命名空间均映射到 WPF 命名空间 `http://schemas.microsoft.com/winfx/2006/xaml/presentation`。</span><span class="sxs-lookup"><span data-stu-id="01b5a-244">For most WPF app scenarios, and for almost all of the examples given in the WPF sections of the SDK, the default XAML namespace is mapped to the WPF namespace `http://schemas.microsoft.com/winfx/2006/xaml/presentation`.</span></span> <span data-ttu-id="01b5a-245">`xmlns:x` 特性指示另一个 XAML 命名空间，该命名空间映射 XAML 语言命名空间`http://schemas.microsoft.com/winfx/2006/xaml`。</span><span class="sxs-lookup"><span data-stu-id="01b5a-245">The `xmlns:x` attribute indicates an additional XAML namespace, which maps the XAML language namespace `http://schemas.microsoft.com/winfx/2006/xaml`.</span></span>

<span data-ttu-id="01b5a-246">使用 `xmlns` 定义用法范围和名称范围映射的做法符合 XML 1.0 规范。</span><span class="sxs-lookup"><span data-stu-id="01b5a-246">This usage of `xmlns` to define a scope for usage and mapping of a namescope is consistent with the XML 1.0 specification.</span></span> <span data-ttu-id="01b5a-247">XAML 名称范围与 XML 名称范围的不同仅在于：XAML 名称范围还包含有关进行类型解析和分析 XAML 时名称范围的元素如何受类型支持的信息。</span><span class="sxs-lookup"><span data-stu-id="01b5a-247">XAML namescopes are different from XML namescopes only in that a XAML namescope also implies something about how the namescope's elements are backed by types when it comes to type resolution and parsing the XAML.</span></span>

<span data-ttu-id="01b5a-248">只有在每个 XAML 文件的根元素上，`xmlns` 特性才是绝对必需的。</span><span class="sxs-lookup"><span data-stu-id="01b5a-248">The `xmlns` attributes are only strictly necessary on the root element of each XAML file.</span></span> <span data-ttu-id="01b5a-249">`xmlns` 定义将适用于根元素的所有子代元素（此行为也符合 `xmlns` 的 XML 1.0 规范）。同时允许根以下的其他元素上具有 `xmlns` 特性，这些特性将适用于定义元素的任何子代元素。</span><span class="sxs-lookup"><span data-stu-id="01b5a-249">`xmlns` definitions will apply to all descendant elements of the root element (this behavior is again consistent with the XML 1.0 specification for `xmlns`.) `xmlns` attributes are also permitted on other elements underneath the root, and would apply to any descendant elements of the defining element.</span></span> <span data-ttu-id="01b5a-250">但是，频繁定义或重新定义 XAML 命名空间会导致难以阅读 XAML 标记样式。</span><span class="sxs-lookup"><span data-stu-id="01b5a-250">However, frequent definition or redefinition of XAML namespaces can result in a XAML markup style that is difficult to read.</span></span>

<span data-ttu-id="01b5a-251">其 XAML 处理器的 WPF 实现包括可识别 WPF 核心程序集的基础结构。</span><span class="sxs-lookup"><span data-stu-id="01b5a-251">The WPF implementation of its XAML processor includes an infrastructure that has awareness of the WPF core assemblies.</span></span> <span data-ttu-id="01b5a-252">已知 WPF 核心程序集包含支持指向默认 XAML 命名空间的 WPF 映射的类型。</span><span class="sxs-lookup"><span data-stu-id="01b5a-252">The WPF core assemblies are known to contain the types that support the WPF mappings to the default XAML namespace.</span></span> <span data-ttu-id="01b5a-253">这是通过项目生成文件中的配置以及 WPF 生成和项目系统实现的。</span><span class="sxs-lookup"><span data-stu-id="01b5a-253">This is enabled through configuration that is part of your project build file and the WPF build and project systems.</span></span> <span data-ttu-id="01b5a-254">因此，为了引用来自 WPF 程序集的 XAML 元素，只需将默认 XAML 命名空间声明为默认 `xmlns`。</span><span class="sxs-lookup"><span data-stu-id="01b5a-254">Therefore, declaring the default XAML namespace as the default `xmlns` is all that is necessary in order to reference XAML elements that come from WPF assemblies.</span></span>

### <a name="the-x-prefix"></a><span data-ttu-id="01b5a-255">x: 前缀</span><span class="sxs-lookup"><span data-stu-id="01b5a-255">The x: prefix</span></span>

<span data-ttu-id="01b5a-256">在之前的根元素示例中，前缀 `x:` 用于映射 XAML 命名空间 `http://schemas.microsoft.com/winfx/2006/xaml`，该命名空间是支持 XAML 语言构造的专用 XAML 命名空间。</span><span class="sxs-lookup"><span data-stu-id="01b5a-256">In the previous root element example, the prefix `x:` was used to map the XAML namespace `http://schemas.microsoft.com/winfx/2006/xaml`, which is the dedicated XAML namespace that supports XAML language constructs.</span></span> <span data-ttu-id="01b5a-257">在这整个 SDK 的项目模板、示例以及文档中，此 `x:` 前缀用于映射该 XAML 命名空间。</span><span class="sxs-lookup"><span data-stu-id="01b5a-257">This `x:` prefix is used for mapping this XAML namespace in the templates for projects, in examples, and in documentation throughout this SDK.</span></span> <span data-ttu-id="01b5a-258">XAML 语言的 XAML 命名空间包含多个将在 XAML 中频繁使用的编程构造。</span><span class="sxs-lookup"><span data-stu-id="01b5a-258">The XAML namespace for the XAML language contains several programming constructs that you will use frequently in your XAML.</span></span> <span data-ttu-id="01b5a-259">下面列出了最常用的 `x:` 前缀编程构造：</span><span class="sxs-lookup"><span data-stu-id="01b5a-259">The following is a listing of the most common `x:` prefix programming constructs you will use:</span></span>

- <span data-ttu-id="01b5a-260">[x:Key](../../../xaml-services/xkey-directive.md)：为 <xref:System.Windows.ResourceDictionary>（或其他框架中的类似字典概念）中的每个资源设置唯一的键。</span><span class="sxs-lookup"><span data-stu-id="01b5a-260">[x:Key](../../../xaml-services/xkey-directive.md): Sets a unique key for each resource in a <xref:System.Windows.ResourceDictionary> (or similar dictionary concepts in other frameworks).</span></span> <span data-ttu-id="01b5a-261">在典型的 WPF 应用标记中的所有 `x:` 用法中，`x:Key` 可能占到 90%。</span><span class="sxs-lookup"><span data-stu-id="01b5a-261">`x:Key` will probably account for 90 percent of the `x:` usages you will see in a typical WPF app's markup.</span></span>

- <span data-ttu-id="01b5a-262">[x:Class](../../../xaml-services/xclass-directive.md)：向为 XAML 页提供代码隐藏的类指定 CLR 命名空间和类名。</span><span class="sxs-lookup"><span data-stu-id="01b5a-262">[x:Class](../../../xaml-services/xclass-directive.md): Specifies the CLR namespace and class name for the class that provides code-behind for a XAML page.</span></span> <span data-ttu-id="01b5a-263">必须具有这样一个类才能支持每个 WPF 编程模型的代码隐藏，因此即使没有资源，也几乎总是能看到映射的 `x:`。</span><span class="sxs-lookup"><span data-stu-id="01b5a-263">You must have such a class to support code-behind per the WPF programming model, and therefore you almost always see `x:` mapped, even if there are no resources.</span></span>

- <span data-ttu-id="01b5a-264">[x:Name](../../../xaml-services/xname-directive.md)：处理对象元素后，为运行时代码中存在的实例指定运行时对象名称。</span><span class="sxs-lookup"><span data-stu-id="01b5a-264">[x:Name](../../../xaml-services/xname-directive.md): Specifies a run-time object name for the instance that exists in run-time code after an object element is processed.</span></span> <span data-ttu-id="01b5a-265">通常，经常为 [x:Name](../../../xaml-services/xname-directive.md) 使用 WPF 定义的等效属性。</span><span class="sxs-lookup"><span data-stu-id="01b5a-265">In general, you will frequently use a WPF-defined equivalent property for [x:Name](../../../xaml-services/xname-directive.md).</span></span> <span data-ttu-id="01b5a-266">此类属性特定映射到 CLR 后备属性，因此更便于进行应用编程，在应用编程中，经常使用运行时代码从初始化的 XAML 中查找命名元素。</span><span class="sxs-lookup"><span data-stu-id="01b5a-266">Such properties map specifically to a CLR backing property and are thus more convenient for app programming, where you frequently use run-time code to find the named elements from initialized XAML.</span></span> <span data-ttu-id="01b5a-267">最常见的此类属性是 <xref:System.Windows.FrameworkElement.Name%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="01b5a-267">The most common such property is <xref:System.Windows.FrameworkElement.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="01b5a-268">在特定类型中不支持等效的 WPF 框架级 <xref:System.Windows.FrameworkElement.Name%2A> 属性时，仍然可以使用 [x:Name](../../../xaml-services/xname-directive.md)。</span><span class="sxs-lookup"><span data-stu-id="01b5a-268">You might still use [x:Name](../../../xaml-services/xname-directive.md) when the equivalent WPF framework-level <xref:System.Windows.FrameworkElement.Name%2A> property is not supported in a particular type.</span></span> <span data-ttu-id="01b5a-269">某些动画方案中会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="01b5a-269">This occurs in certain animation scenarios.</span></span>

- <span data-ttu-id="01b5a-270">[x:Static](../../../xaml-services/xstatic-markup-extension.md)：启用一个返回静态值的引用，该静态值不是与 XAML 兼容的属性。</span><span class="sxs-lookup"><span data-stu-id="01b5a-270">[x:Static](../../../xaml-services/xstatic-markup-extension.md): Enables a reference that returns a static value that is not otherwise a XAML-compatible property.</span></span>

- <span data-ttu-id="01b5a-271">[x:Type](../../../xaml-services/xtype-markup-extension.md)：根据类型名称构造 <xref:System.Type> 引用。</span><span class="sxs-lookup"><span data-stu-id="01b5a-271">[x:Type](../../../xaml-services/xtype-markup-extension.md): Constructs a <xref:System.Type> reference based on a type name.</span></span> <span data-ttu-id="01b5a-272">用于指定采用 <xref:System.Type>（例如 <xref:System.Windows.Style.TargetType%2A?displayProperty=nameWithType>）的特性，但属性经常具有本机的字符串到 <xref:System.Type> 的转换功能，因此使用 [x:Type](../../../xaml-services/xtype-markup-extension.md) 标记扩展用法是可选的。</span><span class="sxs-lookup"><span data-stu-id="01b5a-272">This is used to specify attributes that take <xref:System.Type>, such as <xref:System.Windows.Style.TargetType%2A?displayProperty=nameWithType>, although frequently the property has native string-to-<xref:System.Type> conversion in such a way that the [x:Type](../../../xaml-services/xtype-markup-extension.md) markup extension usage is optional.</span></span>

<span data-ttu-id="01b5a-273">`x:` 前缀/XAML 命名空间中还有其他一些不太常见的编程构造。</span><span class="sxs-lookup"><span data-stu-id="01b5a-273">There are additional programming constructs in the `x:` prefix/XAML namespace, which are not as common.</span></span> <span data-ttu-id="01b5a-274">有关详细信息，请参阅 [XAML 命名空间 (x:)语言功能](../../../xaml-services/namespace-language-features.md)。</span><span class="sxs-lookup"><span data-stu-id="01b5a-274">For details, see [XAML Namespace (x:) Language Features](../../../xaml-services/namespace-language-features.md).</span></span>

## <a name="custom-prefixes-and-custom-types-in-xaml"></a><span data-ttu-id="01b5a-275">XAML 中的自定义前缀和自定义类型</span><span class="sxs-lookup"><span data-stu-id="01b5a-275">Custom prefixes and custom types in XAML</span></span>

<span data-ttu-id="01b5a-276">对于自身的自定义程序集或 PresentationCore  、PresentationFramework  和 WindowsBase  的 WPF 核心以外的程序集，可以将该程序集指定为自定义 `xmlns` 映射的一部分。</span><span class="sxs-lookup"><span data-stu-id="01b5a-276">For your own custom assemblies, or for assemblies outside the WPF core of **PresentationCore**, **PresentationFramework** and **WindowsBase**, you can specify the assembly as part of a custom `xmlns` mapping.</span></span> <span data-ttu-id="01b5a-277">只要该类型能够正确地实现以支持正在尝试的 XAML 用法，就可以在 XAML 中引用该程序集中的类型。</span><span class="sxs-lookup"><span data-stu-id="01b5a-277">You can then reference types from that assembly in your XAML, so long as that type is correctly implemented to support the XAML usages you are attempting.</span></span>

<span data-ttu-id="01b5a-278">下面是一个说明自定义前缀如何在 XAML 标记中工作的基本示例。</span><span class="sxs-lookup"><span data-stu-id="01b5a-278">The following is a basic example of how custom prefixes work in XAML markup.</span></span> <span data-ttu-id="01b5a-279">前缀 `custom` 在根元素标记中定义，并映射为打包在应用中并随应用一起提供的特定程序集。</span><span class="sxs-lookup"><span data-stu-id="01b5a-279">The prefix `custom` is defined in the root element tag, and mapped to a specific assembly that is packaged and available with the app.</span></span> <span data-ttu-id="01b5a-280">此程序集包含 `NumericUpDown` 类型，实现该类型的目的是在支持常规 XAML 用法之外，还可以使用允许在 WPF XAML 内容模型的此特定点执行插入的类继承。</span><span class="sxs-lookup"><span data-stu-id="01b5a-280">This assembly contains a type `NumericUpDown`, which is implemented to support general XAML usage as well as using a class inheritance that permits its insertion at this particular point in a WPF XAML content model.</span></span> <span data-ttu-id="01b5a-281">通过使用该前缀，此 `NumericUpDown` 控件的一个实例声明为对象元素，以便 XAML 分析程序可找到包含该类型的 XAML 命名空间，从而找到包含该类型定义的后备程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="01b5a-281">An instance of this `NumericUpDown` control is declared as an object element, using the prefix so that a XAML parser knows which XAML namespace contains the type, and therefore where the backing assembly is that contains the type definition.</span></span>

```xaml
<Page
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:custom="clr-namespace:NumericUpDownCustomControl;assembly=CustomLibrary"
    >
  <StackPanel Name="LayoutRoot">
    <custom:NumericUpDown Name="numericCtrl1" Width="100" Height="60"/>
...
  </StackPanel>
</Page>
```

<span data-ttu-id="01b5a-282">有关 XAML 中自定义类型的详细信息，请参阅 [XAML 及 WPF 的自定义类](../../../framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="01b5a-282">For more information about custom types in XAML, see [XAML and Custom Classes for WPF](../../../framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md).</span></span>

<span data-ttu-id="01b5a-283">若要深入了解 XML 命名空间与程序集中代码命名空间之间的关系，请参阅 [WPF XAML 的 XAML 命名空间和命名空间映射](../../../framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="01b5a-283">For more information about how XML namespaces and code namespaces in assemblies are related, see [XAML Namespaces and Namespace Mapping for WPF XAML](../../../framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>

## <a name="events-and-xaml-code-behind"></a><span data-ttu-id="01b5a-284">事件和 XAML 代码隐藏</span><span class="sxs-lookup"><span data-stu-id="01b5a-284">Events and XAML code-behind</span></span>

<span data-ttu-id="01b5a-285">大多数 WPF 应用既包括 XAML 标记，也包括代码隐藏。</span><span class="sxs-lookup"><span data-stu-id="01b5a-285">Most WPF apps consist of both XAML markup and code-behind.</span></span> <span data-ttu-id="01b5a-286">在一个项目中，XAML 编写为 `.xaml` 文件，而 CLR 语言（如 Microsoft Visual Basic 或 C#）用于编写代码隐藏文件。</span><span class="sxs-lookup"><span data-stu-id="01b5a-286">Within a project, the XAML is written as a `.xaml` file, and a CLR language such as Microsoft Visual Basic or C# is used to write a code-behind file.</span></span> <span data-ttu-id="01b5a-287">在 WPF 编程和应用程序模型中对 XAML 文件进行标记编译时，XAML 文件的 XAML 代码隐藏文件的位置是通过如下方式来标识的：以 XAML 根元素的 `x:Class` 特性形式指定一个命名空间和类。</span><span class="sxs-lookup"><span data-stu-id="01b5a-287">When a XAML file is markup compiled as part of the WPF programming and application models, the location of the XAML code-behind file for a XAML file is identified by specifying a namespace and class as the `x:Class` attribute of the root element of the XAML.</span></span>

<span data-ttu-id="01b5a-288">通过目前已介绍的示例，你已了解了几个按钮，但这其中没有一个按钮具有任何与其关联的逻辑行为。</span><span class="sxs-lookup"><span data-stu-id="01b5a-288">In the examples so far, you have seen several buttons, but none of these buttons had any logical behavior associated with them yet.</span></span> <span data-ttu-id="01b5a-289">为对象元素添加行为的主要应用程序级机制是使用元素类的现有事件，并为在运行时引发该事件时调用的该事件编写特定的处理程序。</span><span class="sxs-lookup"><span data-stu-id="01b5a-289">The primary application-level mechanism for adding a behavior for an object element is to use an existing event of the element class, and to write a specific handler for that event that is invoked when that event is raised at run-time.</span></span> <span data-ttu-id="01b5a-290">在标记中指定事件名称以及要使用的处理程序的名称，而在代码隐藏中定义实现处理程序的代码。</span><span class="sxs-lookup"><span data-stu-id="01b5a-290">The event name and the name of the handler to use are specified in the markup, whereas the code that implements your handler is defined in the code-behind.</span></span>

[!code-xaml[XAMLOvwSupport#ButtonWithCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page3.xaml#buttonwithcodebehind)]

[!code-csharp[XAMLOvwSupport#ButtonWithCodeBehindHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page3.xaml.cs#buttonwithcodebehindhandler)]
[!code-vb[XAMLOvwSupport#ButtonWithCodeBehindHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XAMLOvwSupport/VisualBasic/Page1.xaml.vb#buttonwithcodebehindhandler)]

<span data-ttu-id="01b5a-291">请注意，代码隐藏文件使用 CLR 命名空间 `ExampleNamespace` 并将 `ExamplePage` 声明为该命名空间内的一个分部类。</span><span class="sxs-lookup"><span data-stu-id="01b5a-291">Notice that the code-behind file uses the CLR namespace `ExampleNamespace` and declares `ExamplePage` as a partial class within that namespace.</span></span> <span data-ttu-id="01b5a-292">这相当于 `ExampleNamespace`.`ExamplePage` 的 `x:Class` 特性值，</span><span class="sxs-lookup"><span data-stu-id="01b5a-292">This parallels the `x:Class` attribute value of `ExampleNamespace`.`ExamplePage`</span></span> <span data-ttu-id="01b5a-293">前者在标记根中提供。</span><span class="sxs-lookup"><span data-stu-id="01b5a-293">that was provided in the markup root.</span></span> <span data-ttu-id="01b5a-294">WPF 标记编译器将通过从根元素类型派生一个类，为编译的任何 XAML 文件创建一个分部类。</span><span class="sxs-lookup"><span data-stu-id="01b5a-294">The WPF markup compiler will create a partial class for any compiled XAML file, by deriving a class from the root element type.</span></span> <span data-ttu-id="01b5a-295">在提供定义同一分部类的代码隐藏时，将在与编译的应用相同的命名空间和类中合并生成的代码。</span><span class="sxs-lookup"><span data-stu-id="01b5a-295">When you provide code-behind that also defines the same partial class, the resulting code is combined within the same namespace and class of the compiled app.</span></span>

<span data-ttu-id="01b5a-296">若要深入了解 WPF 中代码隐藏编程的要求，请参阅 [WPF 中的代码隐藏、事件处理程序和分部类要求](../../../framework/wpf/advanced/code-behind-and-xaml-in-wpf.md#code-behind-event-handler-and-partial-class-requirements-in-wpf)。</span><span class="sxs-lookup"><span data-stu-id="01b5a-296">For more information about requirements for code-behind programming in WPF, see [Code-behind, Event Handler, and Partial Class Requirements in WPF](../../../framework/wpf/advanced/code-behind-and-xaml-in-wpf.md#code-behind-event-handler-and-partial-class-requirements-in-wpf).</span></span>

<span data-ttu-id="01b5a-297">如果不需要创建单独的代码隐藏文件，还可以将代码内联到 XAML 文件中。</span><span class="sxs-lookup"><span data-stu-id="01b5a-297">If you do not want to create a separate code-behind file, you can also inline your code in a XAML file.</span></span> <span data-ttu-id="01b5a-298">但是，内联代码是一种通用性较低的方法，具有很多的限制。</span><span class="sxs-lookup"><span data-stu-id="01b5a-298">However, inline code is a less versatile technique that has substantial limitations.</span></span> <span data-ttu-id="01b5a-299">有关详细信息，请参阅 [WPF 中的代码隐藏和 XAML](../../../framework/wpf/advanced/code-behind-and-xaml-in-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="01b5a-299">For more information, see [Code-Behind and XAML in WPF](../../../framework/wpf/advanced/code-behind-and-xaml-in-wpf.md).</span></span>

### <a name="routed-events"></a><span data-ttu-id="01b5a-300">路由事件</span><span class="sxs-lookup"><span data-stu-id="01b5a-300">Routed events</span></span>

<span data-ttu-id="01b5a-301">路由事件是一个特殊的事件功能，该功能是 WPF 的基础。</span><span class="sxs-lookup"><span data-stu-id="01b5a-301">A particular event feature that is fundamental to WPF is a routed event.</span></span> <span data-ttu-id="01b5a-302">路由事件使一个元素可以处理另一个元素引发的事件，前提是这些元素通过树关系连接在一起。</span><span class="sxs-lookup"><span data-stu-id="01b5a-302">Routed events enable an element to handle an event that was raised by a different element, as long as the elements are connected through a tree relationship.</span></span> <span data-ttu-id="01b5a-303">使用 XAML 特性指定事件处理时，可以对任何元素（包括未在类成员表中列出该特定事件的元素）侦听和处理该路由事件。</span><span class="sxs-lookup"><span data-stu-id="01b5a-303">When specifying event handling with a XAML attribute, the routed event can be listened for and handled on any element, including elements that do not list that particular event in the class members table.</span></span> <span data-ttu-id="01b5a-304">这是通过以所属类名限定事件名特性来实现的。</span><span class="sxs-lookup"><span data-stu-id="01b5a-304">This is accomplished by qualifying the event name attribute with the owning class name.</span></span> <span data-ttu-id="01b5a-305">例如，在当前讨论的 `StackPanel` / `Button` 示例中，父 `StackPanel` 可以在 `StackPanel` 对象元素上指定特性 `Button.Click`，并将处理程序名用作特性值，从而为子元素按钮的 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 事件注册一个处理程序。</span><span class="sxs-lookup"><span data-stu-id="01b5a-305">For instance, the parent `StackPanel` in the ongoing `StackPanel` / `Button` example could register a handler for the child element button's <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event by specifying the attribute `Button.Click` on the `StackPanel` object element, with your handler name as the attribute value.</span></span> <span data-ttu-id="01b5a-306">有关详细信息，请参阅[路由事件概述](../../../framework/wpf/advanced/routed-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="01b5a-306">For more information, see [Routed Events Overview](../../../framework/wpf/advanced/routed-events-overview.md).</span></span>

## <a name="xaml-named-elements"></a><span data-ttu-id="01b5a-307">XAML 命名元素</span><span class="sxs-lookup"><span data-stu-id="01b5a-307">XAML named elements</span></span>

<span data-ttu-id="01b5a-308">默认情况下，通过处理 XAML 对象元素在对象图中创建的对象实例没有唯一标识符或对象引用。</span><span class="sxs-lookup"><span data-stu-id="01b5a-308">By default, the object instance that is created in an object graph by processing a XAML object element does not possess a unique identifier or object reference.</span></span> <span data-ttu-id="01b5a-309">相反，如果在代码中调用构造函数，则几乎总是使用构造函数结果为构造的实例设置变量，以便以后在代码中引用该实例。</span><span class="sxs-lookup"><span data-stu-id="01b5a-309">In contrast, if you call a constructor in code, you almost always use the constructor result to set a variable to the constructed instance, so that you can reference the instance later in your code.</span></span> <span data-ttu-id="01b5a-310">为了对通过标记定义创建的对象提供标准化访问，XAML 定义了 [x:Name 特性](../../../xaml-services/xname-directive.md)。</span><span class="sxs-lookup"><span data-stu-id="01b5a-310">In order to provide standardized access to objects that were created through a markup definition, XAML defines the [x:Name attribute](../../../xaml-services/xname-directive.md).</span></span> <span data-ttu-id="01b5a-311">可以在任何对象元素上设置 `x:Name` 特性的值。</span><span class="sxs-lookup"><span data-stu-id="01b5a-311">You can set the value of the `x:Name` attribute on any object element.</span></span> <span data-ttu-id="01b5a-312">在代码隐藏中，所选标识符等效于引用所构造的实例的实例变量。</span><span class="sxs-lookup"><span data-stu-id="01b5a-312">In your code-behind, the identifier you choose is equivalent to an instance variable that refers to the constructed instance.</span></span> <span data-ttu-id="01b5a-313">在所有方面，命名元素以类似于对象实例的方式工作（名称引用实例），并且代码隐藏可以通过引用命名元素来处理应用内的运行时交互。</span><span class="sxs-lookup"><span data-stu-id="01b5a-313">In all respects, named elements function as if they were object instances (the name references that instance), and your code-behind can reference the named elements to handle run-time interactions within the app.</span></span> <span data-ttu-id="01b5a-314">实例和变量之间的这种连接是由 WPF XAML 标记编译器实现的，并且更具体地涉及到功能和模式，例如本文中未详细讨论的 <xref:System.Windows.Markup.IComponentConnector.InitializeComponent%2A>。</span><span class="sxs-lookup"><span data-stu-id="01b5a-314">This connection between instances and variables is accomplished by the WPF XAML markup compiler, and more specifically involve features and patterns such as <xref:System.Windows.Markup.IComponentConnector.InitializeComponent%2A> that will not be discussed in detail in this article.</span></span>

<span data-ttu-id="01b5a-315">WPF 框架级 XAML 元素继承 <xref:System.Windows.FrameworkElement.Name%2A> 属性，该属性等效于 XAML 定义的 `x:Name` 特性。</span><span class="sxs-lookup"><span data-stu-id="01b5a-315">WPF framework-level XAML elements inherit a <xref:System.Windows.FrameworkElement.Name%2A> property, which is equivalent to the XAML defined `x:Name` attribute.</span></span> <span data-ttu-id="01b5a-316">其他某些类也为 `x:Name`（通常也定义为 `Name` 属性）提供属性级等效项。</span><span class="sxs-lookup"><span data-stu-id="01b5a-316">Certain other classes also provide property-level equivalents for `x:Name`, which is also generally defined as a `Name` property.</span></span> <span data-ttu-id="01b5a-317">一般而言，如果在所选元素/类型的成员表中找不到 `Name` 属性，则可以改用 `x:Name`。</span><span class="sxs-lookup"><span data-stu-id="01b5a-317">Generally speaking, if you cannot find a `Name` property in the members table for your chosen element/type, use `x:Name` instead.</span></span> <span data-ttu-id="01b5a-318">`x:Name` 值将通过特定子系统或通过 <xref:System.Windows.FrameworkElement.FindName%2A> 等实用工具方法，为可在运行时使用的 XAML 元素提供标识符。</span><span class="sxs-lookup"><span data-stu-id="01b5a-318">The `x:Name` values will provide an identifier to a XAML element that can be used at run-time, either by specific subsystems or by utility methods such as <xref:System.Windows.FrameworkElement.FindName%2A>.</span></span>

<span data-ttu-id="01b5a-319">下面的示例对 <xref:System.Windows.Controls.StackPanel> 元素设置 <xref:System.Windows.FrameworkElement.Name%2A>。</span><span class="sxs-lookup"><span data-stu-id="01b5a-319">The following example sets <xref:System.Windows.FrameworkElement.Name%2A> on a <xref:System.Windows.Controls.StackPanel> element.</span></span> <span data-ttu-id="01b5a-320">然后，该 <xref:System.Windows.Controls.StackPanel> 中 <xref:System.Windows.Controls.Button> 上的一个处理程序通过其实例引用 `buttonContainer`（由 <xref:System.Windows.FrameworkElement.Name%2A> 设置）来引用 <xref:System.Windows.Controls.StackPanel>。</span><span class="sxs-lookup"><span data-stu-id="01b5a-320">Then, a handler on a <xref:System.Windows.Controls.Button> within that <xref:System.Windows.Controls.StackPanel> references the <xref:System.Windows.Controls.StackPanel> through its instance reference `buttonContainer` as set by <xref:System.Windows.FrameworkElement.Name%2A>.</span></span>

[!code-xaml[XAMLOvwSupport#NamedE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page7.xaml#namede)]
[!code-xaml[XAMLOvwSupport#NamedE2](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page7.xaml#namede2)]

[!code-csharp[XAMLOvwSupport#NameCode](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page7.xaml.cs#namecode)]
[!code-vb[XAMLOvwSupport#NameCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XAMLOvwSupport/VisualBasic/Page1.xaml.vb#namecode)]

<span data-ttu-id="01b5a-321">和变量一样，实例的 XAML 名称受范围概念约束，因此可以在可预测的某个范围内强制名称唯一。</span><span class="sxs-lookup"><span data-stu-id="01b5a-321">Just like a variable, the XAML name for an instance is governed by a concept of scope, so that names can be enforced to be unique within a certain scope that is predictable.</span></span> <span data-ttu-id="01b5a-322">定义页面的主标记表示一个唯一的 XAML 名称范围，而该 XAML 名称范围的边界是该页面的根元素。</span><span class="sxs-lookup"><span data-stu-id="01b5a-322">The primary markup that defines a page denotes one unique XAML namescope, with the XAML namescope boundary being the root element of that page.</span></span> <span data-ttu-id="01b5a-323">但是，其他标记源（如样式或样式中的模板）可以在运行时与页面交互，这种标记源常常具有自己的 XAML 名称范围，这些名称范围不一定与页面的 XAML 名称范围相关联。</span><span class="sxs-lookup"><span data-stu-id="01b5a-323">However, other markup sources can interact with a page at run-time, such as styles or templates within styles, and such markup sources often have their own XAML namescopes that do not necessarily connect with the XAML namescope of the page.</span></span> <span data-ttu-id="01b5a-324">有关 `x:Name` 和 XAML 名称范围的详细信息，请参阅 <xref:System.Windows.FrameworkElement.Name%2A>、[x:Name 指令](../../../xaml-services/xname-directive.md)或 [WPF XAML 名称范围](../../../framework/wpf/advanced/wpf-xaml-namescopes.md)。</span><span class="sxs-lookup"><span data-stu-id="01b5a-324">For more information on `x:Name` and XAML namescopes, see <xref:System.Windows.FrameworkElement.Name%2A>, [x:Name Directive](../../../xaml-services/xname-directive.md), or [WPF XAML Namescopes](../../../framework/wpf/advanced/wpf-xaml-namescopes.md).</span></span>

## <a name="attached-properties-and-attached-events"></a><span data-ttu-id="01b5a-325">附加属性和附加事件</span><span class="sxs-lookup"><span data-stu-id="01b5a-325">Attached properties and attached events</span></span>

<span data-ttu-id="01b5a-326">XAML 指定了一个语言功能，该功能允许对任何元素指定某些属性或事件，而不管要设置属性或事件的元素的类型定义中是否存在该属性或事件。</span><span class="sxs-lookup"><span data-stu-id="01b5a-326">XAML specifies a language feature that enables certain properties or events to be specified on any element, regardless of whether the property or event exists in the type's definitions for the element it is being set on.</span></span> <span data-ttu-id="01b5a-327">该功能的属性版本称为附加属性，事件版本称为附加事件。</span><span class="sxs-lookup"><span data-stu-id="01b5a-327">The properties version of this feature is called an attached property, the events version is called an attached event.</span></span> <span data-ttu-id="01b5a-328">从概念上讲，可以将附加属性和附加事件视为可以在任何 XAML 元素/对象实例上设置的全局成员。</span><span class="sxs-lookup"><span data-stu-id="01b5a-328">Conceptually, you can think of attached properties and attached events as global members that can be set on any XAML element/object instance.</span></span> <span data-ttu-id="01b5a-329">但是，元素/类或更大的基础结构必须支持附加值的后备属性存储。</span><span class="sxs-lookup"><span data-stu-id="01b5a-329">However, that element/class or a larger infrastructure must support a backing property store for the attached values.</span></span>

<span data-ttu-id="01b5a-330">通常通过特性语法来使用 XAML 中的附加属性。</span><span class="sxs-lookup"><span data-stu-id="01b5a-330">Attached properties in XAML are typically used through attribute syntax.</span></span> <span data-ttu-id="01b5a-331">在特性语法中，可以采用 `ownerType.propertyName` 的形式指定附加属性。</span><span class="sxs-lookup"><span data-stu-id="01b5a-331">In attribute syntax, you specify an attached property in the form `ownerType.propertyName`.</span></span>

<span data-ttu-id="01b5a-332">表面上，这与属性元素用法类似，但在这种情况下，所指定的 `ownerType` 始终是一种与从中要设置附加属性的对象元素不同的类型。</span><span class="sxs-lookup"><span data-stu-id="01b5a-332">Superficially, this resembles a property element usage, but in this case the `ownerType` you specify is always a different type than the object element where the attached property is being set.</span></span> <span data-ttu-id="01b5a-333">`ownerType` 这种类型提供 XAML 处理器为获取或设置附加属性值所需要的访问器方法。</span><span class="sxs-lookup"><span data-stu-id="01b5a-333">`ownerType` is the type that provides the accessor methods that are required by a XAML processor in order to get or set the attached property value.</span></span>

<span data-ttu-id="01b5a-334">附加属性的最常见方案是使子元素向其父元素报告属性值。</span><span class="sxs-lookup"><span data-stu-id="01b5a-334">The most common scenario for attached properties is to enable child elements to report a property value to their parent element.</span></span>

<span data-ttu-id="01b5a-335">下面的示例演示 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 附加属性。</span><span class="sxs-lookup"><span data-stu-id="01b5a-335">The following example illustrates the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property.</span></span> <span data-ttu-id="01b5a-336"><xref:System.Windows.Controls.DockPanel> 类为 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 定义访问器，因此拥有附加属性。</span><span class="sxs-lookup"><span data-stu-id="01b5a-336">The <xref:System.Windows.Controls.DockPanel> class defines the accessors for <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> and therefore owns the attached property.</span></span> <span data-ttu-id="01b5a-337"><xref:System.Windows.Controls.DockPanel> 类还包括一个逻辑，该逻辑迭代其子元素并具体检查每个元素是否具有 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 设置值。</span><span class="sxs-lookup"><span data-stu-id="01b5a-337">The <xref:System.Windows.Controls.DockPanel> class also includes logic that iterates its child elements and specifically checks each element for a set value of <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="01b5a-338">如果找到一个值，将在布局过程中使用该值定位子元素。</span><span class="sxs-lookup"><span data-stu-id="01b5a-338">If a value is found, that value is used during layout to position the child elements.</span></span> <span data-ttu-id="01b5a-339">使用 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 附加属性和此定位功能实际上是 <xref:System.Windows.Controls.DockPanel> 类激动人心的一面。</span><span class="sxs-lookup"><span data-stu-id="01b5a-339">Use of the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property and this positioning capability is in fact the motivating scenario for the <xref:System.Windows.Controls.DockPanel> class.</span></span>

[!code-xaml[XAMLOvwSupport#DockAP](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#dockap)]

<span data-ttu-id="01b5a-340">在 WPF 中，大部分或所有附加属性还作为依赖属性实现。</span><span class="sxs-lookup"><span data-stu-id="01b5a-340">In WPF, most or all the attached properties are also implemented as dependency properties.</span></span> <span data-ttu-id="01b5a-341">有关详细信息，请参阅[附加属性概述](../../../framework/wpf/advanced/attached-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="01b5a-341">For more information, see [Attached Properties Overview](../../../framework/wpf/advanced/attached-properties-overview.md).</span></span>

<span data-ttu-id="01b5a-342">附加事件使用类似的 `ownerType.eventName` 特性语法形式。</span><span class="sxs-lookup"><span data-stu-id="01b5a-342">Attached events use a similar `ownerType.eventName` form of attribute syntax.</span></span> <span data-ttu-id="01b5a-343">和非附加事件一样，XAML 中附加事件的特性值指定对元素处理事件时调用的处理程序方法的名称。</span><span class="sxs-lookup"><span data-stu-id="01b5a-343">Just like the non-attached events, the attribute value for an attached event in XAML specifies the name of the handler method that is invoked when the event is handled on the element.</span></span> <span data-ttu-id="01b5a-344">在 WPF XAML 中使用附加事件并不常见。</span><span class="sxs-lookup"><span data-stu-id="01b5a-344">Attached event usages in WPF XAML are less common.</span></span> <span data-ttu-id="01b5a-345">有关详细信息，请参阅[附加事件概述](../../../framework/wpf/advanced/attached-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="01b5a-345">For more information, see [Attached Events Overview](../../../framework/wpf/advanced/attached-events-overview.md).</span></span>

## <a name="base-types-and-xaml"></a><span data-ttu-id="01b5a-346">基类型和 XAML</span><span class="sxs-lookup"><span data-stu-id="01b5a-346">Base types and XAML</span></span>

<span data-ttu-id="01b5a-347">基础 WPF XAML 及其 XAML 命名空间是类型的一个集合，这些类型对应于 CLR 对象以及 XAML 的标记元素。</span><span class="sxs-lookup"><span data-stu-id="01b5a-347">Underlying WPF XAML and its XAML namespace is a collection of types that correspond to CLR objects in addition to markup elements for XAML.</span></span> <span data-ttu-id="01b5a-348">但是，并不是所有的类都能映射到元素。</span><span class="sxs-lookup"><span data-stu-id="01b5a-348">However, not all classes can be mapped to elements.</span></span> <span data-ttu-id="01b5a-349">抽象类（如 <xref:System.Windows.Controls.Primitives.ButtonBase>）和某些非抽象基类在 CLR 对象模型中用于继承。</span><span class="sxs-lookup"><span data-stu-id="01b5a-349">Abstract classes, such as <xref:System.Windows.Controls.Primitives.ButtonBase>, and certain non-abstract base classes, are used for inheritance in the CLR objects model.</span></span> <span data-ttu-id="01b5a-350">基类（包括抽象类）对于 XAML 开发仍然很重要，因为每个具体的 XAML 元素都从其层次结构中的某个基类继承成员。</span><span class="sxs-lookup"><span data-stu-id="01b5a-350">Base classes, including abstract ones, are still important to XAML development because each of the concrete XAML elements inherits members from some base class in its hierarchy.</span></span> <span data-ttu-id="01b5a-351">通常，这些成员包括可以设置为元素特性的属性或者可以处理的事件。</span><span class="sxs-lookup"><span data-stu-id="01b5a-351">Often these members include properties that can be set as attributes on the element, or events that can be handled.</span></span> <span data-ttu-id="01b5a-352"><xref:System.Windows.FrameworkElement> 是 WPF 在 WPF 框架级的具体 UI 基类。</span><span class="sxs-lookup"><span data-stu-id="01b5a-352"><xref:System.Windows.FrameworkElement> is the concrete base UI class of WPF at the WPF framework level.</span></span> <span data-ttu-id="01b5a-353">设计 UI 时，将使用各种形状、面板、装饰器或控件类，它们全部派生自 <xref:System.Windows.FrameworkElement>。</span><span class="sxs-lookup"><span data-stu-id="01b5a-353">When designing UI, you will use various shape, panel, decorator, or control classes, which all derive from <xref:System.Windows.FrameworkElement>.</span></span> <span data-ttu-id="01b5a-354">一个相关的基类 <xref:System.Windows.FrameworkContentElement> 使用可在 <xref:System.Windows.FrameworkElement> 中特意镜像 API 的 API，支持适合流布局表示形式的面向文档的元素。</span><span class="sxs-lookup"><span data-stu-id="01b5a-354">A related base class, <xref:System.Windows.FrameworkContentElement>, supports document-oriented elements that work well for a flow layout presentation, using APIs that deliberately mirror the APIs in <xref:System.Windows.FrameworkElement>.</span></span> <span data-ttu-id="01b5a-355">元素级的特性和 CLR 对象模型的组合提供一组通用的属性，这些属性可以在大多数具体的 XAML 元素上设置，而不管具体的 XAML 元素及其基础类型。</span><span class="sxs-lookup"><span data-stu-id="01b5a-355">The combination of attributes at the element level and a CLR object model provides you with a set of common properties that are settable on most concrete XAML elements, regardless of the specific XAML element and its underlying type.</span></span>

## <a name="xaml-security"></a><span data-ttu-id="01b5a-356">XAML 安全性</span><span class="sxs-lookup"><span data-stu-id="01b5a-356">XAML security</span></span>

<span data-ttu-id="01b5a-357">XAML 是一种直接表示对象实例化和执行的标记语言。</span><span class="sxs-lookup"><span data-stu-id="01b5a-357">XAML is a markup language that directly represents object instantiation and execution.</span></span> <span data-ttu-id="01b5a-358">因此，在 XAML 中创建的元素能够像等效的生成代码那样与系统资源（如网络访问、文件系统 IO）进行交互。</span><span class="sxs-lookup"><span data-stu-id="01b5a-358">Therefore, elements created in XAML have the same ability to interact with system resources (network access, file system IO, for example) as the equivalent generated code does.</span></span> <span data-ttu-id="01b5a-359">加载到完全受信任的应用中的 XAML 与承载应用具有相同的系统资源访问权限。</span><span class="sxs-lookup"><span data-stu-id="01b5a-359">XAML loaded in to a fully trusted app has the same access to the system resources as the hosting app does.</span></span>

### <a name="code-access-security-cas-in-wpf"></a><span data-ttu-id="01b5a-360">WPF 中的代码访问安全性 (CAS)</span><span class="sxs-lookup"><span data-stu-id="01b5a-360">Code Access Security (CAS) in WPF</span></span>

<span data-ttu-id="01b5a-361">与 .NET Framework 不同，适用于 .NET 的 WPF 不支持 CAS。</span><span class="sxs-lookup"><span data-stu-id="01b5a-361">Unlike .NET Framework, WPF for .NET doesn't support CAS.</span></span> <span data-ttu-id="01b5a-362">有关详细信息，请参阅[代码访问安全性差异](../migration/differences-from-net-framework.md#code-access-security)。</span><span class="sxs-lookup"><span data-stu-id="01b5a-362">For more information, see [Code Access Security differences](../migration/differences-from-net-framework.md#code-access-security).</span></span>

## <a name="loading-xaml-from-code"></a><span data-ttu-id="01b5a-363">从代码中加载 XAML</span><span class="sxs-lookup"><span data-stu-id="01b5a-363">Loading XAML from code</span></span>

<span data-ttu-id="01b5a-364">XAML 可用于定义整个 UI，但有时也适合在 XAML 中定义一部分 UI。</span><span class="sxs-lookup"><span data-stu-id="01b5a-364">XAML can be used to define all of the UI, but it is sometimes also appropriate to define just a piece of the UI in XAML.</span></span> <span data-ttu-id="01b5a-365">此功能可用于实现部分自定义、在本地存储信息，使用 XAML 提供业务对象或者各种可能的方案。</span><span class="sxs-lookup"><span data-stu-id="01b5a-365">This capability could be used to enable partial customization, local storage of information, using XAML to provide a business object, or a variety of possible scenarios.</span></span> <span data-ttu-id="01b5a-366">这些方案的关键是 <xref:System.Windows.Markup.XamlReader> 类及其 <xref:System.Windows.Markup.XamlReader.Load%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="01b5a-366">The key to these scenarios is the <xref:System.Windows.Markup.XamlReader> class and its <xref:System.Windows.Markup.XamlReader.Load%2A> method.</span></span> <span data-ttu-id="01b5a-367">输入是 XAML 文件，而输出是对象，该对象表示从该标记创建的整个运行时对象树。</span><span class="sxs-lookup"><span data-stu-id="01b5a-367">The input is a XAML file, and the output is an object that represents all of the run-time tree of objects that was created from that markup.</span></span> <span data-ttu-id="01b5a-368">然后可以插入该对象，作为应用中已存在的另一个对象的属性。</span><span class="sxs-lookup"><span data-stu-id="01b5a-368">You then can insert the object to be a property of another object that already exists in the app.</span></span> <span data-ttu-id="01b5a-369">只要该属性在内容模型中是一个合适的属性，而该内容模型具有最终显示功能并且将通知执行引擎已向应用添加新内容，就可以通过在 XAML 中进行加载轻松地修改正在运行的应用的内容。</span><span class="sxs-lookup"><span data-stu-id="01b5a-369">So long as the property is an appropriate property in the content model that has eventual display capabilities and that will notify the execution engine that new content has been added into the app, you can modify a running app's contents easily by loading in XAML.</span></span>

## <a name="see-also"></a><span data-ttu-id="01b5a-370">请参阅</span><span class="sxs-lookup"><span data-stu-id="01b5a-370">See also</span></span>

- [<span data-ttu-id="01b5a-371">XAML 语法详述</span><span class="sxs-lookup"><span data-stu-id="01b5a-371">XAML Syntax In Detail</span></span>](../../../framework/wpf/advanced/xaml-syntax-in-detail.md)
- [<span data-ttu-id="01b5a-372">XAML 及 WPF 的自定义类</span><span class="sxs-lookup"><span data-stu-id="01b5a-372">XAML and Custom Classes for WPF</span></span>](../../../framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md)
- [<span data-ttu-id="01b5a-373">XAML 命名空间 (x:)语言功能</span><span class="sxs-lookup"><span data-stu-id="01b5a-373">XAML Namespace (x:) Language Features</span></span>](../../../xaml-services/namespace-language-features.md)
- [<span data-ttu-id="01b5a-374">WPF XAML 扩展</span><span class="sxs-lookup"><span data-stu-id="01b5a-374">WPF XAML Extensions</span></span>](../../../framework/wpf/advanced/wpf-xaml-extensions.md)
- [<span data-ttu-id="01b5a-375">基元素概述</span><span class="sxs-lookup"><span data-stu-id="01b5a-375">Base Elements Overview</span></span>](../../../framework/wpf/advanced/base-elements-overview.md)
- [<span data-ttu-id="01b5a-376">WPF 中的树</span><span class="sxs-lookup"><span data-stu-id="01b5a-376">Trees in WPF</span></span>](../../../framework/wpf/advanced/trees-in-wpf.md)
