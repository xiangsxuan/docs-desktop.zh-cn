---
title: 将 WPF 应用迁移到 .NET Core 3.0
description: 了解如何将 Windows Presentation Foundation (WPF) 应用迁移到 .NET Core 3.0。
author: mjrousos
ms.date: 09/12/2019
ms.author: mikerou
ms.topic: how-to
ms.openlocfilehash: 148c1e4b21ccf4dbdb80bc17f1637a8407732cf0
ms.sourcegitcommit: 069786bcadbf9cd931d7dc3d892262cd852d2ffb
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/10/2021
ms.locfileid: "102604324"
---
# <a name="migrating-wpf-apps-to-net-core"></a><span data-ttu-id="1f157-103">将 WPF 应用迁移到 .NET Core</span><span class="sxs-lookup"><span data-stu-id="1f157-103">Migrating WPF apps to .NET Core</span></span>

<span data-ttu-id="1f157-104">本文介绍将 Windows Presentation Foundation (WPF) 应用从 .NET Framework 迁移到 .NET Core 3.0 所需的步骤。</span><span class="sxs-lookup"><span data-stu-id="1f157-104">This article covers the steps necessary to migrate a Windows Presentation Foundation (WPF) app from .NET Framework to .NET Core 3.0.</span></span> <span data-ttu-id="1f157-105">如果手头没有可供移植的 WPF 应用，但是要尝试该过程，则可以使用 [GitHub](https://github.com/dotnet/windows-desktop/tree/main/Samples/BeanTrader) 上提供的 Bean Trader 示例应用。</span><span class="sxs-lookup"><span data-stu-id="1f157-105">If you don't have a WPF app on hand to port, but would like to try out the process, you can use the **Bean Trader** sample app available on [GitHub](https://github.com/dotnet/windows-desktop/tree/main/Samples/BeanTrader).</span></span> <span data-ttu-id="1f157-106">原始应用（面向 .NET Framework 4.7.2）在 NetFx\BeanTraderClient 文件夹中提供。</span><span class="sxs-lookup"><span data-stu-id="1f157-106">The original app (targeting .NET Framework 4.7.2) is available in the NetFx\BeanTraderClient folder.</span></span> <span data-ttu-id="1f157-107">首先，我们将说明一般情况下移植应用所需的步骤，然后演练适用于 Bean Trader 示例的特定更改。</span><span class="sxs-lookup"><span data-stu-id="1f157-107">First we'll explain the steps necessary to port apps in general, and then we'll walk through the specific changes that apply to the **Bean Trader** sample.</span></span>

[!INCLUDE [desktop guide under construction](../../includes/desktop-guide-preview-note.md)]

<span data-ttu-id="1f157-108">若要迁移到 .NET Core，必须先：</span><span class="sxs-lookup"><span data-stu-id="1f157-108">To migrate to .NET Core, you must first:</span></span>

01. <span data-ttu-id="1f157-109">了解和更新 NuGet 依赖项：</span><span class="sxs-lookup"><span data-stu-id="1f157-109">Understand and update NuGet dependencies:</span></span>

    01. <span data-ttu-id="1f157-110">升级 NuGet 依赖项以使用 `<PackageReference>` 格式。</span><span class="sxs-lookup"><span data-stu-id="1f157-110">Upgrade NuGet dependencies to use the `<PackageReference>` format.</span></span>
    01. <span data-ttu-id="1f157-111">查看顶级 NuGet 依赖项以实现 .NET Core 或 .NET Standard 兼容性。</span><span class="sxs-lookup"><span data-stu-id="1f157-111">Review top-level NuGet dependencies for .NET Core or .NET Standard compatibility.</span></span>
    01. <span data-ttu-id="1f157-112">将 NuGet 包升级到较新版本。</span><span class="sxs-lookup"><span data-stu-id="1f157-112">Upgrade NuGet packages to newer versions.</span></span>
    01. <span data-ttu-id="1f157-113">使用 [.NET 可移植性分析器](/dotnet/standard/analyzers/portability-analyzer)来了解 .NET 依赖项。</span><span class="sxs-lookup"><span data-stu-id="1f157-113">Use the [.NET Portability Analyzer](/dotnet/standard/analyzers/portability-analyzer) to understand .NET dependencies.</span></span>

01. <span data-ttu-id="1f157-114">将项目文件迁移到新的 SDK 样式格式：</span><span class="sxs-lookup"><span data-stu-id="1f157-114">Migrate the project file to the new SDK-style format:</span></span>

    01. <span data-ttu-id="1f157-115">选择是面向 .NET Core 和 .NET Framework，还是仅面向 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="1f157-115">Choose whether to target both .NET Core and .NET Framework, or only .NET Core.</span></span>
    01. <span data-ttu-id="1f157-116">将相关项目文件属性和项复制到新的项目文件。</span><span class="sxs-lookup"><span data-stu-id="1f157-116">Copy relevant project file properties and items to the new project file.</span></span>

01. <span data-ttu-id="1f157-117">修复生成问题：</span><span class="sxs-lookup"><span data-stu-id="1f157-117">Fix build issues:</span></span>

    01. <span data-ttu-id="1f157-118">添加对 [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) 包的引用。</span><span class="sxs-lookup"><span data-stu-id="1f157-118">Add a reference to the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) package.</span></span>
    01. <span data-ttu-id="1f157-119">查找并修复 API 级别差异。</span><span class="sxs-lookup"><span data-stu-id="1f157-119">Find and fix API-level differences.</span></span>
    01. <span data-ttu-id="1f157-120">删除 `appSettings` 或 `connectionStrings` 以外的 app.config 节。</span><span class="sxs-lookup"><span data-stu-id="1f157-120">Remove *app.config* sections other than `appSettings` or `connectionStrings`.</span></span>
    01. <span data-ttu-id="1f157-121">如有必要，重新生成已生成的代码。</span><span class="sxs-lookup"><span data-stu-id="1f157-121">Regenerate generated code, if necessary.</span></span>

01. <span data-ttu-id="1f157-122">运行时测试：</span><span class="sxs-lookup"><span data-stu-id="1f157-122">Runtime testing:</span></span>

    01. <span data-ttu-id="1f157-123">确认移植的应用按预期方式工作。</span><span class="sxs-lookup"><span data-stu-id="1f157-123">Confirm the ported app works as expected.</span></span>
    01. <span data-ttu-id="1f157-124">谨防 <xref:System.NotSupportedException> 异常。</span><span class="sxs-lookup"><span data-stu-id="1f157-124">Beware of <xref:System.NotSupportedException> exceptions.</span></span>

## <a name="about-the-sample"></a><span data-ttu-id="1f157-125">关于本示例</span><span class="sxs-lookup"><span data-stu-id="1f157-125">About the sample</span></span>

<span data-ttu-id="1f157-126">本文引用 [Bean Trader 示例应用](https://github.com/dotnet/windows-desktop/tree/main/Samples/BeanTrader)，因为它使用了各种依赖项，而这些依赖项类似于实际 WPF 应用可能包含的依赖项。</span><span class="sxs-lookup"><span data-stu-id="1f157-126">This article references the [Bean Trader sample app](https://github.com/dotnet/windows-desktop/tree/main/Samples/BeanTrader) because it uses a variety of dependencies similar to those that real-world WPF apps might have.</span></span> <span data-ttu-id="1f157-127">该应用并不大，但在复杂性方面要比“Hello World”高出一步。</span><span class="sxs-lookup"><span data-stu-id="1f157-127">The app isn't large, but is meant to be a step up from 'Hello World' in terms of complexity.</span></span> <span data-ttu-id="1f157-128">该应用演示在移植实际应用时可能会遇到的一些问题。</span><span class="sxs-lookup"><span data-stu-id="1f157-128">The app demonstrates some issues users may encounter while porting real apps.</span></span> <span data-ttu-id="1f157-129">该应用与 WCF 服务进行通信，因此若要使它正常运行，还需要运行 BeanTraderServer 项目（在同一个 GitHub 存储库中提供），并确保 BeanTraderClient 配置指向正确的终结点。</span><span class="sxs-lookup"><span data-stu-id="1f157-129">The app communicates with a WCF service, so for it to run properly, you'll also need to run the BeanTraderServer project (available in the same GitHub repository) and make sure the BeanTraderClient configuration points to the correct endpoint.</span></span> <span data-ttu-id="1f157-130">（默认情况下，该示例假设服务器在 `http://localhost:8090` 处的相同计算机上运行，如果在本地启动 BeanTraderServer，则是这种情况。）</span><span class="sxs-lookup"><span data-stu-id="1f157-130">(By default, the sample assumes the server is running on the same machine at `http://localhost:8090`, which will be true if you launch BeanTraderServer locally.)</span></span>

<span data-ttu-id="1f157-131">请记住，此示例应用旨在演示 .NET Core 移植挑战和解决方案。</span><span class="sxs-lookup"><span data-stu-id="1f157-131">Keep in mind that this sample app is meant to demonstrate .NET Core porting challenges and solutions.</span></span> <span data-ttu-id="1f157-132">它并不打算演示 WPF 最佳做法。</span><span class="sxs-lookup"><span data-stu-id="1f157-132">It's not meant to demonstrate WPF best practices.</span></span> <span data-ttu-id="1f157-133">事实上，它故意包含一些反模式，以确保在移植时至少遇到几个有趣的挑战。</span><span class="sxs-lookup"><span data-stu-id="1f157-133">In fact, it deliberately includes some anti-patterns to make sure you come across at least a couple of interesting challenges while porting.</span></span>

## <a name="getting-ready"></a><span data-ttu-id="1f157-134">做好准备</span><span class="sxs-lookup"><span data-stu-id="1f157-134">Getting ready</span></span>

<span data-ttu-id="1f157-135">将 .NET Framework 应用迁移到 .NET Core 的主要挑战是其依赖项可能会以不同方式工作或根本无法工作。</span><span class="sxs-lookup"><span data-stu-id="1f157-135">The primary challenge of migrating a .NET Framework app to .NET Core is that its dependencies may work differently or not at all.</span></span> <span data-ttu-id="1f157-136">迁移比以前容易得多；现在有许多 NuGet 包面向 .NET Standard。</span><span class="sxs-lookup"><span data-stu-id="1f157-136">Migration is much easier than it used to be; many NuGet packages now target .NET Standard.</span></span> <span data-ttu-id="1f157-137">从 .NET Core 2.0 开始，.NET Framework 和 .NET Core 外围应用已变得十分类似。</span><span class="sxs-lookup"><span data-stu-id="1f157-137">Starting with .NET Core 2.0, the .NET Framework and .NET Core surface areas have become similar.</span></span> <span data-ttu-id="1f157-138">尽管如此，仍然存在一些差异（NuGet 包提供的支持和可用 .NET API）。</span><span class="sxs-lookup"><span data-stu-id="1f157-138">Even so, some differences (both in support from NuGet packages and in available .NET APIs) remain.</span></span> <span data-ttu-id="1f157-139">迁移的第一步是查看应用的依赖项，并确保引用采用的格式可轻松迁移到 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="1f157-139">The first step in migrating is to review the app's dependencies and make sure references are in a format that's easily migrated to .NET Core.</span></span>

### <a name="upgrade-to-packagereference-nuget-references"></a><span data-ttu-id="1f157-140">升级到 `<PackageReference>` NuGet 引用</span><span class="sxs-lookup"><span data-stu-id="1f157-140">Upgrade to `<PackageReference>` NuGet references</span></span>

<span data-ttu-id="1f157-141">较旧 .NET Framework 项目通常会在的 packages.config 文件中列出其 NuGet 依赖项。</span><span class="sxs-lookup"><span data-stu-id="1f157-141">Older .NET Framework projects typically list their NuGet dependencies in a *packages.config* file.</span></span> <span data-ttu-id="1f157-142">新的 SDK 样式项目文件格式将 NuGet 包引用为 csproj 文件本身中的 [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) 元素，而不是在单独的配置文件中。</span><span class="sxs-lookup"><span data-stu-id="1f157-142">The new SDK-style project file format references NuGet packages as [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) elements in the csproj file itself rather than in a separate config file.</span></span>

<span data-ttu-id="1f157-143">迁移时，使用 `<PackageReference>` 样式引用有两个优点：</span><span class="sxs-lookup"><span data-stu-id="1f157-143">When migrating, there are two advantages to using `<PackageReference>`-style references:</span></span>

- <span data-ttu-id="1f157-144">这是新 .NET Core 项目文件所需的 NuGet 引用的样式。</span><span class="sxs-lookup"><span data-stu-id="1f157-144">This is the style of NuGet reference that is required for the new .NET Core project file.</span></span> <span data-ttu-id="1f157-145">如果已在使用 `<PackageReference>`，则可以将这些项目文件元素直接复制并粘贴到新项目中。</span><span class="sxs-lookup"><span data-stu-id="1f157-145">If you're already using `<PackageReference>`, those project file elements can be copied and pasted directly into the new project.</span></span>
- <span data-ttu-id="1f157-146">与 packages.config 文件不同，`<PackageReference>` 元素只引用项目直接依赖的顶级依赖项。</span><span class="sxs-lookup"><span data-stu-id="1f157-146">Unlike a packages.config file, `<PackageReference>` elements only refer to the top-level dependencies that your project depends on directly.</span></span> <span data-ttu-id="1f157-147">所有其他可传递 NuGet 包将在还原时确定，并记录在自动生成的 obj\project.assets.json 文件中。</span><span class="sxs-lookup"><span data-stu-id="1f157-147">All other transitive NuGet packages will be determined at restore time and recorded in the autogenerated obj\project.assets.json file.</span></span> <span data-ttu-id="1f157-148">这样可以更轻松地确定项目所具有的依赖项，这在确定所需依赖项是否可在 .NET Core 中正常工作时非常有用。</span><span class="sxs-lookup"><span data-stu-id="1f157-148">This makes it much easier to determine what dependencies your project has, which is useful when determining whether the necessary dependencies will work on .NET Core or not.</span></span>

<span data-ttu-id="1f157-149">将 .NET Framework 应用迁移到 .NET Core 的第一步是将它更新为使用 `<PackageReference>` NuGet 引用。</span><span class="sxs-lookup"><span data-stu-id="1f157-149">The first step to migrating a .NET Framework app to .NET Core is to update it to use `<PackageReference>` NuGet references.</span></span> <span data-ttu-id="1f157-150">Visual Studio 使此过程变得简单。</span><span class="sxs-lookup"><span data-stu-id="1f157-150">Visual Studio makes this simple.</span></span> <span data-ttu-id="1f157-151">只需在 Visual Studio 的“解决方案资源管理器”中右键单击项目的 packages.config 文件，然后选择“将 packages.config 迁移到 PackageReference”。</span><span class="sxs-lookup"><span data-stu-id="1f157-151">Just right-click the project's *packages.config* file in Visual Studio's **Solution Explorer**, and then select **Migrate packages.config to PackageReference**.</span></span>

![升级到 PackageReference](./media/convert-project-from-net-framework/package-reference-migration.png)

<span data-ttu-id="1f157-153">将出现一个对话框，显示计算出的顶级 NuGet 依赖项，并询问应将其他哪些 NuGet 包提升到顶级。</span><span class="sxs-lookup"><span data-stu-id="1f157-153">A dialog appears showing calculated top-level NuGet dependencies and asking which other NuGet packages should be promoted to top-level.</span></span> <span data-ttu-id="1f157-154">Bean Trader 示例不需要其他任何包是顶级包，因此可以取消选中所有这些框。</span><span class="sxs-lookup"><span data-stu-id="1f157-154">None of these other packages need to be top-level for the Bean Trader sample, so you can uncheck all of those boxes.</span></span> <span data-ttu-id="1f157-155">然后，单击“确定”，packages.config 文件会删除，而 `<PackageReference>` 元素会添加到项目文件中。</span><span class="sxs-lookup"><span data-stu-id="1f157-155">Then, click **Ok** and the *packages.config* file is removed and `<PackageReference>` elements are added to the project file.</span></span>

<span data-ttu-id="1f157-156">`<PackageReference>` 样式引用不会在本地将 NuGet 包存储在包文件夹中。</span><span class="sxs-lookup"><span data-stu-id="1f157-156">`<PackageReference>`-style references don't store NuGet packages locally in a packages folder.</span></span> <span data-ttu-id="1f157-157">而是以全局方式将它们作为优化进行存储。</span><span class="sxs-lookup"><span data-stu-id="1f157-157">Instead, they're stored globally as an optimization.</span></span> <span data-ttu-id="1f157-158">迁移完成之后，编辑 csproj 文件，删除任何引用以前来自 ..\packages 目录的分析器的 `<Analyzer>` 元素。</span><span class="sxs-lookup"><span data-stu-id="1f157-158">After the migration completes, edit the csproj file and remove any `<Analyzer>` elements referring to the analyzers that previously came from the *..\packages* directory.</span></span> <span data-ttu-id="1f157-159">别担心；由于仍然具有 NuGet 包引用，因此这些分析器将包含在项目中。</span><span class="sxs-lookup"><span data-stu-id="1f157-159">Don't worry; since you still have the NuGet package references, the analyzers will be included in the project.</span></span> <span data-ttu-id="1f157-160">只需清理旧的 packages.config 样式 `<Analyzer>` 元素。</span><span class="sxs-lookup"><span data-stu-id="1f157-160">You just need to clean up the old packages.config-style `<Analyzer>` elements.</span></span>

### <a name="review-nuget-packages"></a><span data-ttu-id="1f157-161">查看 NuGet 包</span><span class="sxs-lookup"><span data-stu-id="1f157-161">Review NuGet packages</span></span>

<span data-ttu-id="1f157-162">现在可以看到项目所依赖的顶级 NuGet 包，可以查看这些包在 .NET Core 中是否可用。</span><span class="sxs-lookup"><span data-stu-id="1f157-162">Now that you can see the top-level NuGet packages that the project depends on, you can review whether those packages are available on .NET Core.</span></span> <span data-ttu-id="1f157-163">可以通过在 [nuget.org](https://www.nuget.org/) 上查看包的依赖项来确定它是否支持 .NET Core。社区创建的 [fuget.org](https://www.fuget.org/) 网站在包信息页面顶部突出显示此信息。</span><span class="sxs-lookup"><span data-stu-id="1f157-163">You can determine whether a package supports .NET Core by looking at its dependencies on [nuget.org](https://www.nuget.org/). The community-created [fuget.org](https://www.fuget.org/) site shows this information prominently at the top of the package information page.</span></span>

<span data-ttu-id="1f157-164">面向 .NET Core 3.0 时，面向 .NET Core 或 .NET Standard 的任何包都应该可正常工作（因为 .NET Core 实现了 .NET Standard 外围应用）。</span><span class="sxs-lookup"><span data-stu-id="1f157-164">When targeting .NET Core 3.0, any packages targeting .NET Core or .NET Standard should work (since .NET Core implements the .NET Standard surface area).</span></span> <span data-ttu-id="1f157-165">在某些情况下，所用包的特定版本不面向 .NET Core 或 .NET Standard，但较新版本会面向。</span><span class="sxs-lookup"><span data-stu-id="1f157-165">In some cases, the specific version of a package that's used won't target .NET Core or .NET Standard, but newer versions will.</span></span> <span data-ttu-id="1f157-166">在这种情况下，应考虑升级到最新版本的包。</span><span class="sxs-lookup"><span data-stu-id="1f157-166">In this case, you should consider upgrading to the latest version of the package.</span></span>

<span data-ttu-id="1f157-167">也可以使用面向 .NET Framework 的包，但这会带来一些风险。</span><span class="sxs-lookup"><span data-stu-id="1f157-167">You can use packages targeting .NET Framework, as well, but that introduces some risk.</span></span> <span data-ttu-id="1f157-168">允许 .NET core 到 .NET Framework 的依赖项，因为 .NET Core 和 .NET Framework 外围应用非常类似，足以使此类依赖项通常可正常工作。</span><span class="sxs-lookup"><span data-stu-id="1f157-168">.NET Core to .NET Framework dependencies are allowed because .NET Core and .NET Framework surface areas are similar enough that such dependencies *often* work.</span></span> <span data-ttu-id="1f157-169">但是，如果包尝试使用 .NET Core 中不存在的 .NET API，则会遇到运行时异常。</span><span class="sxs-lookup"><span data-stu-id="1f157-169">However, if the package tries to use a .NET API that isn't present in .NET Core, you'll encounter a runtime exception.</span></span> <span data-ttu-id="1f157-170">因此，只应在没有其他选项可用时才引用 .NET Framework 包，并了解这样做会带来测试负担。</span><span class="sxs-lookup"><span data-stu-id="1f157-170">Because of that, you should only reference .NET Framework packages when no other options are available and understand that doing so imposes a test burden.</span></span>

<span data-ttu-id="1f157-171">如果引用的包不面向 .NET Core 或 .NET Standard，则必须考虑其他替代方法：</span><span class="sxs-lookup"><span data-stu-id="1f157-171">If there are packages referenced that don't target .NET Core or .NET Standard, you'll have to think about other alternatives:</span></span>

- <span data-ttu-id="1f157-172">是否有其他类似的包可代替使用？</span><span class="sxs-lookup"><span data-stu-id="1f157-172">Are there other similar packages that can be used instead?</span></span> <span data-ttu-id="1f157-173">有时，NuGet 作者会发布库的单独“.Core”版本，专门面向 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="1f157-173">Sometimes NuGet authors publish separate '.Core' versions of their libraries specifically targeting .NET Core.</span></span> <span data-ttu-id="1f157-174">Enterprise Library 包是社区发布“.NetCore”替代方法的一个示例。</span><span class="sxs-lookup"><span data-stu-id="1f157-174">Enterprise Library packages are an example of the community publishing ".NetCore" alternatives.</span></span> <span data-ttu-id="1f157-175">在其他情况下，适用于特定服务的较新 SDK（有时具有不同的包名称）可用于 .NET Standard。</span><span class="sxs-lookup"><span data-stu-id="1f157-175">In other cases, newer SDKs for a particular service (sometimes with different package names) are available for .NET Standard.</span></span> <span data-ttu-id="1f157-176">如果没有可用的替代方法，则可以继续使用面向 .NET Framework 的包，请记住，在 .NET Core 上运行后，需要对它们进行全面测试。</span><span class="sxs-lookup"><span data-stu-id="1f157-176">If no alternatives are available, you can proceed using the .NET Framework-targeted packages, bearing in mind that you'll need to test them thoroughly once running on .NET Core.</span></span>

<span data-ttu-id="1f157-177">Bean Trader 示例具有以下顶级 NuGet 依赖项：</span><span class="sxs-lookup"><span data-stu-id="1f157-177">The Bean Trader sample has the following top-level NuGet dependencies:</span></span>

- [<span data-ttu-id="1f157-178">Castle.Windsor，版本 4.1.1</span><span class="sxs-lookup"><span data-stu-id="1f157-178">**Castle.Windsor, version 4.1.1**</span></span>](https://www.castleproject.org/projects/windsor/)  

  <span data-ttu-id="1f157-179">此包面向 .NET Standard 1.6，因此它可在 .NET Core 上正常工作。</span><span class="sxs-lookup"><span data-stu-id="1f157-179">This package targets .NET Standard 1.6, so it works on .NET Core.</span></span>

- [<span data-ttu-id="1f157-180">Microsoft.CodeAnalysis.FxCopAnalyzers，版本 2.6.3</span><span class="sxs-lookup"><span data-stu-id="1f157-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, version 2.6.3**</span></span>](https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/2.6.3)  
  <span data-ttu-id="1f157-181">这是一个元包，因此，它支持哪些平台并不明显，但[文档](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers)指示其最新版本 (2.9.2) 将适用于 .NET Framework 和 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="1f157-181">This is a meta-package, so it's not immediately obvious which platforms it supports, but [documentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indicates that its newest version (2.9.2) will work for both .NET Framework and .NET Core.</span></span>

- [<span data-ttu-id="1f157-182">Nito.AsyncEx，版本 4.0.1</span><span class="sxs-lookup"><span data-stu-id="1f157-182">**Nito.AsyncEx, version 4.0.1**</span></span>](https://www.nuget.org/packages/Nito.AsyncEx/4.0.1)  

  <span data-ttu-id="1f157-183">此包不面向 .NET Core，但较新的 5.0 版本面向。</span><span class="sxs-lookup"><span data-stu-id="1f157-183">This package doesn't target .NET Core, but the newer 5.0 version does.</span></span> <span data-ttu-id="1f157-184">这在迁移时十分常见，因为许多 NuGet 包最近添加了 .NET Standard 支持，但较旧项目版本仅面向 .NET Framework。</span><span class="sxs-lookup"><span data-stu-id="1f157-184">This is common when migrating because many NuGet packages have added .NET Standard support recently, but older project versions will only target .NET Framework.</span></span> <span data-ttu-id="1f157-185">如果版本差异只是次版本差异，则通常可轻松升级到较新版本。</span><span class="sxs-lookup"><span data-stu-id="1f157-185">If the version difference is only a minor version difference, it's often easy to upgrade to the newer version.</span></span> <span data-ttu-id="1f157-186">由于这是主版本更改，因此需要小心升级，因为包中可能存在中断性变更。</span><span class="sxs-lookup"><span data-stu-id="1f157-186">Because this is a major version change, you need to be cautious upgrading since there could be breaking changes in the package.</span></span> <span data-ttu-id="1f157-187">不过，有一条很好的前进道路。</span><span class="sxs-lookup"><span data-stu-id="1f157-187">There is a path forward, though, which is good.</span></span>

- [<span data-ttu-id="1f157-188">MahApps.Metro，版本 1.6.5</span><span class="sxs-lookup"><span data-stu-id="1f157-188">**MahApps.Metro, version 1.6.5**</span></span>](https://www.nuget.org/packages/MahApps.Metro/1.6.5)  

  <span data-ttu-id="1f157-189">此包也不面向 .NET Core，但较新的预发行版 (2.0-alpha) 面向。</span><span class="sxs-lookup"><span data-stu-id="1f157-189">This package also doesn't target .NET Core, but has a newer pre-release (2.0-alpha) that does.</span></span> <span data-ttu-id="1f157-190">同样，必须注意中断性变更，但较新的包令人鼓舞。</span><span class="sxs-lookup"><span data-stu-id="1f157-190">Again, you have to look out for breaking changes, but the newer package is encouraging.</span></span>

<span data-ttu-id="1f157-191">Bean Trader 示例的 NuGet 依赖项全都面向 .NET Standard/.NET Core，或具有面向它们的较新版本，因此此处不可能存在任何阻塞性问题。</span><span class="sxs-lookup"><span data-stu-id="1f157-191">The Bean Trader sample's NuGet dependencies all either target .NET Standard/.NET Core or have newer versions that do, so there are unlikely to be any blocking issues here.</span></span>

### <a name="upgrade-nuget-packages"></a><span data-ttu-id="1f157-192">升级 NuGet 包</span><span class="sxs-lookup"><span data-stu-id="1f157-192">Upgrade NuGet packages</span></span>

<span data-ttu-id="1f157-193">如果可能，最好此时使用更近的版本升级仅面向 .NET Core 或 .NET Standard 的任何包的版本（项目仍面向 .NET Framework），以便及早发现和解决任何中断性变更。</span><span class="sxs-lookup"><span data-stu-id="1f157-193">If possible, it would be good to upgrade the versions of any packages that only target .NET Core or .NET Standard with more recent versions at this point (with the project still targeting .NET Framework) to discover and address any breaking changes early.</span></span>

<span data-ttu-id="1f157-194">如果不想对现有 .NET Framework 版本的应用进行任何重大更改，则可以等到具有面向 .NET Core 的新项目文件。</span><span class="sxs-lookup"><span data-stu-id="1f157-194">If you would rather not make any material changes to the existing .NET Framework version of the app, this can wait until you have a new project file targeting .NET Core.</span></span> <span data-ttu-id="1f157-195">但是，提前将 NuGet 包升级到 .NET Core 兼容版本会使迁移过程更加轻松（即使在创建新项目文件后），并减少了应用的 .NET Framework 与 .NET Core 版本之间的差异数量。</span><span class="sxs-lookup"><span data-stu-id="1f157-195">However, upgrading the NuGet packages to .NET Core-compatible versions ahead of time makes the migration process even easier once you create the new project file and reduces the number of differences between the .NET Framework and .NET Core versions of the app.</span></span>

<span data-ttu-id="1f157-196">使用 Bean Trader 示例时，可以轻松地进行所有必要的升级（使用 Visual Studio 的 NuGet 包管理器），但有一个例外：从 MahApps.Metro 1.6.5 升级到 2.0 会展示与主题和辅色管理 API 相关的中断性变更。</span><span class="sxs-lookup"><span data-stu-id="1f157-196">With the Bean Trader sample, all of the necessary upgrades can be made easily (using Visual Studio's NuGet package manager) with one exception: upgrading from **MahApps.Metro 1.6.5** to **2.0** reveals breaking changes related to theme and accent management APIs.</span></span>

<span data-ttu-id="1f157-197">理想情况下，该应用将更新为使用较新版本的包（因为这更有可能在 .NET Core 上正常工作）。</span><span class="sxs-lookup"><span data-stu-id="1f157-197">Ideally, the app would be updated to use the newer version of the package (since that is more likely to work on .NET Core).</span></span> <span data-ttu-id="1f157-198">但在某些情况下，这可能不可行。</span><span class="sxs-lookup"><span data-stu-id="1f157-198">In some cases, however, that may not be feasible.</span></span> <span data-ttu-id="1f157-199">在这些情况下，请不要升级 MahApps.Metro，因为所需更改十分繁琐，而本教程侧重于迁移到 .NET Core 3，而不是 MahApps.Metro 2。</span><span class="sxs-lookup"><span data-stu-id="1f157-199">In these cases, don't upgrade **MahApps.Metro** because the necessary changes are non-trivial and this tutorial focuses on migrating to .NET Core 3, not to **MahApps.Metro 2.**</span></span> <span data-ttu-id="1f157-200">另外，这是一个低风险 .NET Framework 依赖项，因为 Bean Trader 应用仅执行一小部分的 MahApps.Metro。</span><span class="sxs-lookup"><span data-stu-id="1f157-200">Also, this is a low-risk .NET Framework dependency because the Bean Trader app only exercises a small part of **MahApps.Metro**.</span></span> <span data-ttu-id="1f157-201">当然，它需要进行测试，以确保在迁移完成后所有内容都可正常工作。</span><span class="sxs-lookup"><span data-stu-id="1f157-201">It will, of course, require testing to make sure everything's working once the migration is complete.</span></span> <span data-ttu-id="1f157-202">如果这是一个实际方案，最好提交一个问题以跟踪迁移到 MahApps.Metro 版本 2.0 的工作，因为现在不执行迁移会留下一些技术债务。</span><span class="sxs-lookup"><span data-stu-id="1f157-202">If this were a real-world scenario, it would be good to file an issue to track the work to move to **MahApps.Metro** version 2.0 since not doing the migration now leaves behind some technical debt.</span></span>

<span data-ttu-id="1f157-203">将 NuGet 包更新到最新版本后，Bean Trader 示例项目文件中的 `<PackageReference>` 项组应如下所示。</span><span class="sxs-lookup"><span data-stu-id="1f157-203">Once the NuGet packages are updated to recent versions, the `<PackageReference>` item group in the Bean Trader sample's project file should look like this.</span></span>

```xml
<ItemGroup>
  <PackageReference Include="Castle.Windsor">
    <Version>4.1.1</Version>
  </PackageReference>
  <PackageReference Include="MahApps.Metro">
    <Version>1.6.5</Version>
  </PackageReference>
  <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers">
    <Version>2.9.2</Version>
  </PackageReference>
  <PackageReference Include="Nito.AsyncEx">
    <Version>5.0.0</Version>
  </PackageReference>
</ItemGroup>
```

### <a name="net-framework-portability-analysis"></a><span data-ttu-id="1f157-204">.NET Framework 可移植性分析</span><span class="sxs-lookup"><span data-stu-id="1f157-204">.NET Framework portability analysis</span></span>

<span data-ttu-id="1f157-205">了解项目 NuGet 依赖项的状态后，接下来要考虑的事项是 .NET Framework API 依赖项。</span><span class="sxs-lookup"><span data-stu-id="1f157-205">Once you understand the state of your project's NuGet dependencies, the next thing to consider is .NET Framework API dependencies.</span></span> <span data-ttu-id="1f157-206">[.NET 可移植性分析器](/dotnet/standard/analyzers/portability-analyzer)工具可用于了解项目使用的哪些 .NET API 在其他 .NET 平台上可用。</span><span class="sxs-lookup"><span data-stu-id="1f157-206">The [.NET Portability Analyzer](/dotnet/standard/analyzers/portability-analyzer) tool is useful for understanding which of the .NET APIs your project uses are available on other .NET platforms.</span></span>

<span data-ttu-id="1f157-207">该工具作为 [Visual Studio 插件](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer)、[命令行工具](https://github.com/Microsoft/dotnet-apiport/releases)或包装在[简单 GUI](https://github.com/Microsoft/dotnet-apiport-ui) 来提供，这简化了其选项。</span><span class="sxs-lookup"><span data-stu-id="1f157-207">The tool comes as a [Visual Studio plugin](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), a [command-line tool](https://github.com/Microsoft/dotnet-apiport/releases), or wrapped in a [simple GUI](https://github.com/Microsoft/dotnet-apiport-ui), which simplifies its options.</span></span> <span data-ttu-id="1f157-208">可以在[将桌面应用移植到 .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) 博客文章中了解有关通过 GUI 使用 .NET 可移植性分析器 (API Port) 的更多信息。</span><span class="sxs-lookup"><span data-stu-id="1f157-208">You can read more about using the .NET Portability Analyzer (API Port) using the GUI in the [Porting desktop apps to .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog post.</span></span> <span data-ttu-id="1f157-209">如果希望使用命令行，则所需步骤是：</span><span class="sxs-lookup"><span data-stu-id="1f157-209">If you prefer to use the command line, the necessary steps are:</span></span>

1. <span data-ttu-id="1f157-210">下载 [.NET 可移植性分析器](https://github.com/Microsoft/dotnet-apiport/releases)（如果尚未安装）。</span><span class="sxs-lookup"><span data-stu-id="1f157-210">Download the [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) if you don't already have it.</span></span>
1. <span data-ttu-id="1f157-211">确保要移植 .NET Framework 应用成功生成（无论如何，在迁移之前这都是一个好主意）。</span><span class="sxs-lookup"><span data-stu-id="1f157-211">Make sure the .NET Framework app to be ported builds successfully (this is a good idea prior to migration regardless).</span></span>
1. <span data-ttu-id="1f157-212">使用如下所示的命令行运行 API Port。</span><span class="sxs-lookup"><span data-stu-id="1f157-212">Run API Port with a command line like this.</span></span>

    ```console
    ApiPort.exe analyze -f <PathToBeanTraderBinaries> -r html -r excel -t ".NET Core"
    ```

    <span data-ttu-id="1f157-213">`-f` 参数指定包含要分析的二进制文件的路径。</span><span class="sxs-lookup"><span data-stu-id="1f157-213">The `-f` argument specifies the path containing the binaries to analyze.</span></span> <span data-ttu-id="1f157-214">`-r` 参数指定所需的输出文件格式。</span><span class="sxs-lookup"><span data-stu-id="1f157-214">The `-r` argument specifies which output file format you want.</span></span> <span data-ttu-id="1f157-215">`-t` 参数指定要对其分析 API 使用情况的 .NET 平台。</span><span class="sxs-lookup"><span data-stu-id="1f157-215">The `-t` argument specifies which .NET platform to analyze API usage against.</span></span> <span data-ttu-id="1f157-216">在这种情况下，需要 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="1f157-216">In this case, you want .NET Core.</span></span>

<span data-ttu-id="1f157-217">打开 HTML 报告时，第一个部分将列出所有已分析的二进制文件以及它们使用的 .NET API 在目标平台上可用的百分比。</span><span class="sxs-lookup"><span data-stu-id="1f157-217">When you open the HTML report, the first section will list all of the analyzed binaries and what percentage of the .NET APIs they use are available on the targeted platform.</span></span> <span data-ttu-id="1f157-218">该百分比本身并无意义。</span><span class="sxs-lookup"><span data-stu-id="1f157-218">The percentage is not meaningful by itself.</span></span> <span data-ttu-id="1f157-219">更有用的是查看缺少的特定 API。</span><span class="sxs-lookup"><span data-stu-id="1f157-219">What's more useful is to see the specific APIs that are missing.</span></span> <span data-ttu-id="1f157-220">为此，请选择程序集名称或向下滚动到各个程序集的报告。</span><span class="sxs-lookup"><span data-stu-id="1f157-220">To do that, either select an assembly name or scroll down to the reports for individual assemblies.</span></span>

<span data-ttu-id="1f157-221">专注于你拥有源代码的程序集。</span><span class="sxs-lookup"><span data-stu-id="1f157-221">Focus on the assemblies that you own the source code for.</span></span> <span data-ttu-id="1f157-222">例如，在 Bean Trader ApiPort 报告中列出了很多二进制文件，但其中大多数都属于 NuGet 包。</span><span class="sxs-lookup"><span data-stu-id="1f157-222">In the Bean Trader ApiPort report, for example, there are many binaries listed, but most of them belong to NuGet packages.</span></span> <span data-ttu-id="1f157-223">`Castle.Windsor` 显示它依赖于 .NET Core 中缺少的某些 System.Web API。</span><span class="sxs-lookup"><span data-stu-id="1f157-223">`Castle.Windsor` shows that it depends on some System.Web APIs that are missing in .NET Core.</span></span> <span data-ttu-id="1f157-224">这不必担心，因为先前已验证 `Castle.Windsor` 支持 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="1f157-224">This isn't a concern because you previously verified that `Castle.Windsor` supports .NET Core.</span></span> <span data-ttu-id="1f157-225">NuGet 包通常具有不同的二进制文件以用于不同的 .NET 平台，因此，只要包还面向 .NET Standard 或 .NET Core，.NET Framework 版本的 `Castle.Windsor` 是否使用 System.Web API 便无关要紧。</span><span class="sxs-lookup"><span data-stu-id="1f157-225">It is common for NuGet packages to have different binaries for use with different .NET platforms, so whether the .NET Framework version of `Castle.Windsor` uses System.Web APIs or not is irrelevant as long as the package also targets .NET Standard or .NET Core (which it does).</span></span>

<span data-ttu-id="1f157-226">对于 Bean Trader 示例，需要考虑的唯一二进制文件是 BeanTraderClient，报告会显示仅缺少两个 .NET API：`System.ServiceModel.ClientBase<T>.Close` 和 `System.ServiceModel.ClientBase<T>.Open`。</span><span class="sxs-lookup"><span data-stu-id="1f157-226">With the Bean Trader sample, the only binary that you need to consider is **BeanTraderClient** and the report shows that only two .NET APIs are missing: `System.ServiceModel.ClientBase<T>.Close` and `System.ServiceModel.ClientBase<T>.Open`.</span></span>

![BeanTraderClient 可移植性报告](./media/convert-project-from-net-framework/portability-report.png)

<span data-ttu-id="1f157-228">这些不太可能是阻塞性问题，因为 WCF 客户端 API（多半）在 .NET Core 上受支持，因此必须有可用于这些中央 API 的替代方法。</span><span class="sxs-lookup"><span data-stu-id="1f157-228">These are unlikely to be blocking issues because WCF Client APIs are (mostly) supported on .NET Core, so there must be alternatives available for these central APIs.</span></span> <span data-ttu-id="1f157-229">事实上，查看 `System.ServiceModel` 的 .NET Core 外围应用（使用 <https://apisof.net>）时可发现，.NET Core 中存在异步替代方法。</span><span class="sxs-lookup"><span data-stu-id="1f157-229">In fact, looking at `System.ServiceModel`'s .NET Core surface area (using <https://apisof.net>), you see that there are async alternatives in .NET Core instead.</span></span>

<span data-ttu-id="1f157-230">根据此报告以及以前的 NuGet 依赖项分析，将 Bean Trader 示例迁移到 .NET Core 应该不会有大问题。</span><span class="sxs-lookup"><span data-stu-id="1f157-230">Based on this report and the previous NuGet dependency analysis, it looks like there should be no major issues migrating the Bean Trader sample to .NET Core.</span></span> <span data-ttu-id="1f157-231">你已为实际开始迁移的下一步做好准备。</span><span class="sxs-lookup"><span data-stu-id="1f157-231">You're ready for the next step in which you'll actually start the migration.</span></span>

## <a name="migrating-the-project-file"></a><span data-ttu-id="1f157-232">迁移项目文件</span><span class="sxs-lookup"><span data-stu-id="1f157-232">Migrating the project file</span></span>

<span data-ttu-id="1f157-233">如果应用未使用新的 [SDK 样式项目文件格式](/dotnet/core/tools/csproj)，则需要新的项目文件以面向 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="1f157-233">If your app isn't using the new [SDK-style project file format](/dotnet/core/tools/csproj), you'll need a new project file to target .NET Core.</span></span> <span data-ttu-id="1f157-234">可以替换现有 csproj 文件，或者如果想使现有项目保持其当前状态不变，则可以添加面向 .NET Core 的新 csproj 文件。</span><span class="sxs-lookup"><span data-stu-id="1f157-234">You can replace the existing csproj file or, if you prefer to keep the existing project untouched in its current state, you can add a new csproj file targeting .NET Core.</span></span> <span data-ttu-id="1f157-235">可以使用具有[多目标](/dotnet/standard/library-guidance/cross-platform-targeting)（指定多个 `<TargetFrameworks>` 目标）的单个 SDK 样式项目文件，生成适用于 .NET Framework 和 .NET Core 的应用版本。</span><span class="sxs-lookup"><span data-stu-id="1f157-235">You can build versions of the app for .NET Framework and .NET Core with a single SDK-style project file with [multi-targeting](/dotnet/standard/library-guidance/cross-platform-targeting) (specifying multiple `<TargetFrameworks>` targets).</span></span>

<span data-ttu-id="1f157-236">若要创建新的项目文件，可以在 Visual Studio 中创建新的 WPF 项目，或在临时目录中使用 `dotnet new wpf` 命令生成项目文件，然后将它复制/重命名为正确的位置。</span><span class="sxs-lookup"><span data-stu-id="1f157-236">To create the new project file, you can create a new WPF project in Visual Studio or use the `dotnet new wpf` command in a temporary directory to generate the project file and then copy/rename it to the correct location.</span></span> <span data-ttu-id="1f157-237">还有一个社区创建的工具 [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017)，可自动执行某些项目文件迁移。</span><span class="sxs-lookup"><span data-stu-id="1f157-237">There is also a community-created tool, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), that can automate some of the project file migration.</span></span> <span data-ttu-id="1f157-238">该工具十分有用，但仍需要人工查看结果，以确保迁移的所有详细信息都正确。</span><span class="sxs-lookup"><span data-stu-id="1f157-238">The tool is helpful but still needs a human to review the results to make sure all the details of the migration are correct.</span></span> <span data-ttu-id="1f157-239">该工具不能以最佳方式处理的一个特定方面是从 packages.config 文件迁移 NuGet 包。</span><span class="sxs-lookup"><span data-stu-id="1f157-239">One particular area that the tool doesn't handle optimally is migrating NuGet packages from *packages.config* files.</span></span> <span data-ttu-id="1f157-240">如果该工具对仍使用 packages.config 文件引用 NuGet 包的项目文件运行，则它将自动迁移到 `<PackageReference>` 元素，但会为所有包（而不只是顶级包）添加 `<PackageReference>` 元素。</span><span class="sxs-lookup"><span data-stu-id="1f157-240">If the tool runs on a project file that still uses a *packages.config* file to reference NuGet packages, it will migrate to `<PackageReference>` elements automatically, but will add `<PackageReference>` elements for *all* of the packages instead of just top-level ones.</span></span> <span data-ttu-id="1f157-241">如果已使用 Visual Studio 迁移到 `<PackageReference>` 元素（如本示例中所做的那样），则该工具可帮助执行转换的其余部分。</span><span class="sxs-lookup"><span data-stu-id="1f157-241">If you have already migrated to`<PackageReference>` elements with Visual Studio (as you've done in this sample), then the tool can help with the rest of the conversion.</span></span> <span data-ttu-id="1f157-242">正如 Scott Hanselman 在[他有关迁移 csproj 文件的博客文章](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx)中所建议的那样，手动移植具有教育意义，并且在只有几个项目要移植时可获得更好的结果。</span><span class="sxs-lookup"><span data-stu-id="1f157-242">Like Scott Hanselman recommends in [his blog post on migrating csproj files](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), porting by hand is educational and will give better results if you only have a few projects to port.</span></span> <span data-ttu-id="1f157-243">但是，如果要移植数十个或数百个项目文件，则类似于 [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017) 这样的工具可能会很有帮助。</span><span class="sxs-lookup"><span data-stu-id="1f157-243">But if you're porting dozens or hundreds of project files, then a tool like [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017) can be a help.</span></span>

<span data-ttu-id="1f157-244">若要为 Bean Trader 示例创建新项目文件，请在临时目录中运行 `dotnet new wpf`，并将生成的 .csproj 文件移动到 BeanTraderClient 文件夹中，并将它重命名为 BeanTraderClient.Core.csproj。</span><span class="sxs-lookup"><span data-stu-id="1f157-244">To create a new project file for the Bean Trader sample, run `dotnet new wpf` in a temporary directory and move the generated *.csproj* file into the *BeanTraderClient* folder and rename it **BeanTraderClient.Core.csproj**.</span></span>

<span data-ttu-id="1f157-245">由于新项目文件格式会自动包含它在其目录中或目录下找到的 C# 文件、resx 文件和 XAML 文件，因此项目文件已几乎完成！</span><span class="sxs-lookup"><span data-stu-id="1f157-245">Because the new project file format automatically includes C# files, *resx* files, and XAML files that it finds in or under its directory, the project file is already almost complete!</span></span> <span data-ttu-id="1f157-246">若要完成迁移，请并排打开新旧项目文件并浏览旧项目文件，以查看是否包含任何需要迁移的信息。</span><span class="sxs-lookup"><span data-stu-id="1f157-246">To finish the migration, open the old and new project files side-by-side and look through the old one to see if any information it contains needs to be migrated.</span></span> <span data-ttu-id="1f157-247">在 Bean Trader 示例中，应将以下各项复制到新项目中：</span><span class="sxs-lookup"><span data-stu-id="1f157-247">In the Bean Trader sample case, the following items should be copied to the new project:</span></span>

- <span data-ttu-id="1f157-248">`<RootNamespace>`、`<AssemblyName>` 和 `<ApplicationIcon>` 属性全都应进行复制。</span><span class="sxs-lookup"><span data-stu-id="1f157-248">The `<RootNamespace>`, `<AssemblyName>`, and `<ApplicationIcon>` properties should all be copied.</span></span>

- <span data-ttu-id="1f157-249">还需要将 `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` 属性添加到新项目文件，因为 Bean Trader 示例在 AssemblyInfo.cs 文件中包含程序集级别特性（如 `[AssemblyTitle]`）。</span><span class="sxs-lookup"><span data-stu-id="1f157-249">You also need to add a `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` property to the new project file since the Bean Trader sample includes assembly-level attributes (like `[AssemblyTitle]`) in an AssemblyInfo.cs file.</span></span> <span data-ttu-id="1f157-250">默认情况下，新的 SDK 样式项目将基于 csproj 文件中的属性来自动生成这些特性。</span><span class="sxs-lookup"><span data-stu-id="1f157-250">By default, new SDK-style projects will autogenerate these attributes based on properties in the csproj file.</span></span> <span data-ttu-id="1f157-251">因为在此例中不希望发生这种情况（自动生成的特性会与 AssemblyInfo.cs 中的特性冲突），所以可以通过 `<GenerateAssemblyInfo>` 禁用自动生成的特性。</span><span class="sxs-lookup"><span data-stu-id="1f157-251">Because you don't want that to happen in this case (the autogenerated attributes would conflict with those from AssemblyInfo.cs), you disable the autogenerated attributes with `<GenerateAssemblyInfo>`.</span></span>

- <span data-ttu-id="1f157-252">虽然 resx 文件会作为嵌入的资源自动包含在内，但其他 `<Resource>` 项（如图像）不会这样。</span><span class="sxs-lookup"><span data-stu-id="1f157-252">Although *resx* files are automatically included as embedded resources, other `<Resource>` items like images are not.</span></span> <span data-ttu-id="1f157-253">因此，复制 `<Resource>` 元素以用于嵌入图像和图标文件。</span><span class="sxs-lookup"><span data-stu-id="1f157-253">So, copy the `<Resource>` elements for embedding image and icon files.</span></span> <span data-ttu-id="1f157-254">可以使用新项目文件格式对 glob 模式的支持将 png 引用简化为单行：`<Resource Include="**\*.png" />`。</span><span class="sxs-lookup"><span data-stu-id="1f157-254">You can simplify the png references to a single line by using the new project file format's support for globbing patterns: `<Resource Include="**\*.png" />`.</span></span>

- <span data-ttu-id="1f157-255">同样，`<None>` 项会自动包含在内，但它们在默认情况下不会复制到输出目录。</span><span class="sxs-lookup"><span data-stu-id="1f157-255">Similarly, `<None>` items are included automatically, but they aren't copied to the output directory, by default.</span></span> <span data-ttu-id="1f157-256">由于 Bean Trader 项目包含复制到输出目录的 `<None>` 项（使用 `PreserveNewest` 行为），因此需要为该文件更新自动填充的 `<None>` 项，如下所示。</span><span class="sxs-lookup"><span data-stu-id="1f157-256">Because the Bean Trader project includes a `<None>` item that *is* copied to the output directory (using `PreserveNewest` behaviors), you need to update the automatically populated `<None>` item for that file, like this.</span></span>

  ```xml
  <None Update="BeanTrader.pfx">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
  ```

- <span data-ttu-id="1f157-257">Bean Trader 示例包含一个 XAML 文件 (Default.Accent.xaml) 作为 `Content`（而不是作为 `Page`），因为在运行时会从文件的 XAML 加载此文件中定义的主题和辅色，而不是嵌入在应用本身中。</span><span class="sxs-lookup"><span data-stu-id="1f157-257">The Bean Trader sample includes a XAML file (Default.Accent.xaml) as `Content` (rather than as a `Page`) because themes and accents defined in this file are loaded from the file's XAML at runtime, rather than being embedded in the app itself.</span></span> <span data-ttu-id="1f157-258">但是，新项目系统会自动将此文件作为 `<Page>` 包含在内，因为它是 XAML 文件。</span><span class="sxs-lookup"><span data-stu-id="1f157-258">The new project system automatically includes this file as a `<Page>`, however, since it's a XAML file.</span></span> <span data-ttu-id="1f157-259">因此，需要删除作为页面的 XAML 文件 (`<Page Remove="**\Default.Accent.xaml" />`)，并将它添加为内容。</span><span class="sxs-lookup"><span data-stu-id="1f157-259">So, you need to both remove the XAML file as a page (`<Page Remove="**\Default.Accent.xaml" />`) and add it as content.</span></span>

  ```xml
  <Content Include="Resources\Themes\Default.Accent.xaml">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </Content>
  ```

- <span data-ttu-id="1f157-260">最后，通过复制具有所有 `<PackageReference>` 元素的 `<ItemGroup>` 来添加 NuGet 引用。</span><span class="sxs-lookup"><span data-stu-id="1f157-260">Finally, add NuGet references by copying the `<ItemGroup>` with all the `<PackageReference>` elements.</span></span> <span data-ttu-id="1f157-261">如果以前未将 NuGet 包升级到与 .NET Core 兼容的版本，则可以现在执行该操作，因为包引用处于特定于 .NET Core 的项目中。</span><span class="sxs-lookup"><span data-stu-id="1f157-261">If you hadn't previously upgraded the NuGet packages to .NET Core-compatible versions, you could do that now that the package references are in a .NET Core-specific project.</span></span>

<span data-ttu-id="1f157-262">此时，应该可以将新项目添加到 BeanTrader 解决方案，并在 Visual Studio 中打开它。</span><span class="sxs-lookup"><span data-stu-id="1f157-262">At this point, it should be possible to add the new project to the BeanTrader solution and open it in Visual Studio.</span></span> <span data-ttu-id="1f157-263">项目应在“解决方案资源管理器”中正确显示，`dotnet restore BeanTraderClient.Core.csproj` 应成功还原包（有两个与面向 .NET Framework 使用的 MahApps.Metro 版本相关的预期警告）。</span><span class="sxs-lookup"><span data-stu-id="1f157-263">The project should look correct in **Solution Explorer**, and `dotnet restore BeanTraderClient.Core.csproj` should successfully restore packages (with two expected warnings related to the MahApps.Metro version you're using targeting .NET Framework).</span></span>

<span data-ttu-id="1f157-264">尽管可以并排保留两个项目文件（如果要完全按照原样继续生成旧项目，甚至可能需要这样做），但它会使迁移过程复杂化（两个项目将尝试使用相同的 bin 和 obj 文件夹），并且通常是不必要的。</span><span class="sxs-lookup"><span data-stu-id="1f157-264">Although it's possible to keep both project files side-by-side (and may even be desirable if you want to keep building the old project exactly as it was), it complicates the migration process (the two projects will try to use the same bin and obj folders) and usually isn't necessary.</span></span> <span data-ttu-id="1f157-265">如果要同时为 .NET Core 和 .NET Framework 目标进行生成，则可以改为将新项目文件中的 `<TargetFramework>netcoreapp3.0</TargetFramework>` 属性替换为 `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>`。</span><span class="sxs-lookup"><span data-stu-id="1f157-265">If you want to build for both .NET Core and .NET Framework targets, you can replace the `<TargetFramework>netcoreapp3.0</TargetFramework>` property in the new project file with `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` instead.</span></span> <span data-ttu-id="1f157-266">对于 Bean Trader 示例，删除旧项目文件 (BeanTraderClient.csproj)，因为不再需要它。</span><span class="sxs-lookup"><span data-stu-id="1f157-266">For the Bean Trader sample, delete the old project file (BeanTraderClient.csproj) since it's no longer needed.</span></span> <span data-ttu-id="1f157-267">如果想要同时保留两个项目文件，请务必让它们生成到不同的输出和中间输出路径。</span><span class="sxs-lookup"><span data-stu-id="1f157-267">If you prefer to keep both project files, be sure to have them build to different output and intermediate output paths.</span></span>

## <a name="fix-build-issues"></a><span data-ttu-id="1f157-268">修复生成问题</span><span class="sxs-lookup"><span data-stu-id="1f157-268">Fix build issues</span></span>

<span data-ttu-id="1f157-269">移植过程的第三步是获取要生成的项目。</span><span class="sxs-lookup"><span data-stu-id="1f157-269">The third step of the porting process is getting the project to build.</span></span> <span data-ttu-id="1f157-270">将项目文件转换为 SDK 样式项目后，某些应用已成功生成。</span><span class="sxs-lookup"><span data-stu-id="1f157-270">Some apps will already build successfully once the project file is converted to an SDK-style project.</span></span> <span data-ttu-id="1f157-271">如果你的应用是这种情况，那么祝贺你！</span><span class="sxs-lookup"><span data-stu-id="1f157-271">If that's the case for your app, congratulations!</span></span> <span data-ttu-id="1f157-272">可以转到步骤 4。</span><span class="sxs-lookup"><span data-stu-id="1f157-272">You can go on to Step 4.</span></span> <span data-ttu-id="1f157-273">其他应用需要一些更新才能针对 .NET Core 进行生成。</span><span class="sxs-lookup"><span data-stu-id="1f157-273">Other apps will need some updates to get them building for .NET Core.</span></span> <span data-ttu-id="1f157-274">例如，如果现在尝试对 Bean Trader 示例项目运行 `dotnet build`（或在 Visual Studio 中生成它），将会出现许多错误，但是可以快速修复它们。</span><span class="sxs-lookup"><span data-stu-id="1f157-274">If you try to run `dotnet build` on the Bean Trader sample project now, for example, (or build it in Visual Studio), there will be many errors, but you'll get them fixed quickly.</span></span>

### <a name="systemservicemodel-references-and-microsoftwindowscompatibility"></a><span data-ttu-id="1f157-275">System.ServiceModel 引用和 Microsoft.Windows.Compatibility</span><span class="sxs-lookup"><span data-stu-id="1f157-275">System.ServiceModel references and Microsoft.Windows.Compatibility</span></span>

<span data-ttu-id="1f157-276">常见错误源是对可用于 .NET Core 但不会自动包含在 .NET Core 应用元包中的 API 缺少引用。</span><span class="sxs-lookup"><span data-stu-id="1f157-276">A common source of errors is missing references for APIs that are available for .NET Core but not automatically included in the .NET Core app metapackage.</span></span> <span data-ttu-id="1f157-277">若要解决此情况，应引用 `Microsoft.Windows.Compatibility` 包。</span><span class="sxs-lookup"><span data-stu-id="1f157-277">To address this, you should reference the `Microsoft.Windows.Compatibility` package.</span></span> <span data-ttu-id="1f157-278">兼容性包中包含一组广泛的在 Windows 桌面应用中十分常见的 API，例如 WCF 客户端、目录服务、注册表、配置、ACL API 等。</span><span class="sxs-lookup"><span data-stu-id="1f157-278">The compatibility package includes a broad set of APIs that are common in Windows desktop apps, such as WCF client, directory services, registry, configuration, ACLs APIs, and more.</span></span>

<span data-ttu-id="1f157-279">对于 Bean Trader 示例，大多数生成错误是由于缺少 <xref:System.ServiceModel> 类型引起的。</span><span class="sxs-lookup"><span data-stu-id="1f157-279">With the Bean Trader sample, the majority of the build errors are due to missing <xref:System.ServiceModel> types.</span></span> <span data-ttu-id="1f157-280">可以通过引用必要的 WCF NuGet 包来解决这些问题。</span><span class="sxs-lookup"><span data-stu-id="1f157-280">These could be addressed by referencing the necessary WCF NuGet packages.</span></span> <span data-ttu-id="1f157-281">不过，WCF 客户端 API 处于 `Microsoft.Windows.Compatibility` 包中，因此引用兼容性包是更好的解决方案（因为它还解决与 API 相关的任何问题以及兼容性包提供的 WCF 问题解决方案）。</span><span class="sxs-lookup"><span data-stu-id="1f157-281">WCF client APIs are among those present in the `Microsoft.Windows.Compatibility` package, though, so referencing the compatibility package is an even better solution (since it also addresses any issues related to APIs as well as solutions to the WCF issues that the compatibility package makes available).</span></span> <span data-ttu-id="1f157-282">`Microsoft.Windows.Compatibility` 包在大多数 .NET Core 3.0 WPF 和 WinForms 移植方案中会很有帮助。</span><span class="sxs-lookup"><span data-stu-id="1f157-282">The `Microsoft.Windows.Compatibility` package helps in most .NET Core 3.0 WPF and WinForms porting scenarios.</span></span> <span data-ttu-id="1f157-283">将 NuGet 引用添加到 `Microsoft.Windows.Compatibility` 之后，只剩下一个生成错误！</span><span class="sxs-lookup"><span data-stu-id="1f157-283">After adding the NuGet reference to `Microsoft.Windows.Compatibility`, only one build error remains!</span></span>

### <a name="cleaning-up-unused-files"></a><span data-ttu-id="1f157-284">清理未使用的文件</span><span class="sxs-lookup"><span data-stu-id="1f157-284">Cleaning up unused files</span></span>

<span data-ttu-id="1f157-285">经常出现的一种类型的迁移问题与以前未包含在生成中的 C# 和 XAML 文件相关，而自动包含所有源文件的新 SDK 样式项目会选择它们。</span><span class="sxs-lookup"><span data-stu-id="1f157-285">One type of migration issue that comes up often relates to C# and XAML files that weren't previously included in the build getting picked up by the new SDK-style projects that include *all* source automatically.</span></span>

<span data-ttu-id="1f157-286">在 Bean Trader 示例中看到的下一个生成错误是指 OldUnusedViewModel.cs 中的错误接口实现。</span><span class="sxs-lookup"><span data-stu-id="1f157-286">The next build error you see in the Bean Trader sample refers to a bad interface implementation in *OldUnusedViewModel.cs*.</span></span> <span data-ttu-id="1f157-287">文件名是一个提示，但在检查时，你会发现此源文件不正确。</span><span class="sxs-lookup"><span data-stu-id="1f157-287">The file name is a hint, but on inspection, you'll find that this source file is incorrect.</span></span> <span data-ttu-id="1f157-288">它以前不会导致问题，因为原始 .NET Framework 项目中未包含它。</span><span class="sxs-lookup"><span data-stu-id="1f157-288">It didn't cause issues previously because it wasn't included in the original .NET Framework project.</span></span> <span data-ttu-id="1f157-289">现在会自动包含磁盘上存在但未包含在旧 csproj 中的源文件。</span><span class="sxs-lookup"><span data-stu-id="1f157-289">Source files that were present on disk but not included in the old *csproj* are included automatically now.</span></span>

<span data-ttu-id="1f157-290">对于这类一次性问题，可方便地与以前的 csproj 进行比较，以确认不需要该文件，然后对它执行 `<Compile Remove="" />`，或者如果任何位置都不再需要源文件，可删除它。</span><span class="sxs-lookup"><span data-stu-id="1f157-290">For one-off issues like this, it's easy to compare to the previous *csproj* to confirm that the file isn't needed, and then either `<Compile Remove="" />` it or, if the source file isn't needed anywhere anymore, delete it.</span></span> <span data-ttu-id="1f157-291">在此例中，可安全地只是删除 OldUnusedViewModel.cs。</span><span class="sxs-lookup"><span data-stu-id="1f157-291">In this case, it's safe to just delete *OldUnusedViewModel.cs*.</span></span>

<span data-ttu-id="1f157-292">如果有许多需要以这种方式排除的源文件，则可以通过在项目文件中将 `<EnableDefaultCompileItems>` 属性设置为 false 来禁用 C# 文件的自动包含。</span><span class="sxs-lookup"><span data-stu-id="1f157-292">If you have many source files that would need to be excluded this way, you can disable auto-inclusion of C# files by setting the `<EnableDefaultCompileItems>` property to false in the project file.</span></span> <span data-ttu-id="1f157-293">然后，可以将 `<Compile Include>` 项从旧项目文件复制到新文件，以便仅生成要包含的源文件。</span><span class="sxs-lookup"><span data-stu-id="1f157-293">Then, you can copy `<Compile Include>` items from the old project file to the new one in order to only build sources you intended to include.</span></span> <span data-ttu-id="1f157-294">同样，`<EnableDefaultPageItems>` 可用于关闭 XAML 页面的自动包含，而 `<EnableDefaultItems>` 可以通过单个属性控制这两者。</span><span class="sxs-lookup"><span data-stu-id="1f157-294">Similarly, `<EnableDefaultPageItems>` can be used to turn off auto-inclusion of XAML pages and `<EnableDefaultItems>` can control both with a single property.</span></span>

### <a name="a-brief-aside-on-multi-pass-compilers"></a><span data-ttu-id="1f157-295">多遍编译器简介</span><span class="sxs-lookup"><span data-stu-id="1f157-295">A brief aside on multi-pass compilers</span></span>

<span data-ttu-id="1f157-296">从 Bean Trader 示例中删除有问题的文件之后，可以重新生成，将收到四个错误。</span><span class="sxs-lookup"><span data-stu-id="1f157-296">After removing the offending file from the Bean Trader sample, you can re-build and will get four errors.</span></span> <span data-ttu-id="1f157-297">之前是否遇到过其中一个？</span><span class="sxs-lookup"><span data-stu-id="1f157-297">Didn't you have one before?</span></span> <span data-ttu-id="1f157-298">为什么错误数量会上升？</span><span class="sxs-lookup"><span data-stu-id="1f157-298">Why did the number of errors go up?</span></span> <span data-ttu-id="1f157-299">C# 编译器是[多遍编译器](/archive/blogs/ericlippert/how-many-passes)。</span><span class="sxs-lookup"><span data-stu-id="1f157-299">The C# compiler is a [multi-pass compiler](/archive/blogs/ericlippert/how-many-passes).</span></span> <span data-ttu-id="1f157-300">这意味着它会浏览每个源文件两次。</span><span class="sxs-lookup"><span data-stu-id="1f157-300">This means that it goes through each source file twice.</span></span> <span data-ttu-id="1f157-301">首先，编译器仅查看每个源文件中的元数据和声明，并标识任何声明级别问题。</span><span class="sxs-lookup"><span data-stu-id="1f157-301">First, the compiler just looks at metadata and declarations in each source file and identifies any declaration-level problems.</span></span> <span data-ttu-id="1f157-302">这些是已修复的错误。</span><span class="sxs-lookup"><span data-stu-id="1f157-302">Those are the errors you've fixed.</span></span> <span data-ttu-id="1f157-303">然后，它会再次浏览代码以将 C# 源文件生成为 IL；这些是现在看到的第二组错误。</span><span class="sxs-lookup"><span data-stu-id="1f157-303">Then it goes through the code again to build the C# source into IL; those are the second set of errors that you're seeing now.</span></span>

> [!NOTE]
> <span data-ttu-id="1f157-304">C# 编译器[不仅是浏览两次](/archive/blogs/ericlippert/how-many-passes)，但最终结果是，类似于这样的大型代码更改的编译器错误往往以两个波次的形式出现。</span><span class="sxs-lookup"><span data-stu-id="1f157-304">The C# compiler does [more than just two passes](/archive/blogs/ericlippert/how-many-passes), but the end result is that compiler errors for large code changes like this tend to come in two waves.</span></span>

### <a name="third-party-dependency-fixes-castlewindsor"></a><span data-ttu-id="1f157-305">第三方依赖项修补程序 (Castle.Windsor)</span><span class="sxs-lookup"><span data-stu-id="1f157-305">Third-party dependency fixes (Castle.Windsor)</span></span>

<span data-ttu-id="1f157-306">在某些迁移方案中出现的另一类问题是 .NET Framework 与 .NET Core 版本的依赖项之间的 API 差异。</span><span class="sxs-lookup"><span data-stu-id="1f157-306">Another class of issue that comes up in some migration scenarios is API differences between .NET Framework and .NET Core versions of dependencies.</span></span> <span data-ttu-id="1f157-307">即使 NuGet 包同时面向 .NET Framework 和 .NET Standard 或 .NET Core，也可能会有不同的库用于不同的 .NET 目标。</span><span class="sxs-lookup"><span data-stu-id="1f157-307">Even if a NuGet package targets both .NET Framework and .NET Standard or .NET Core, there may be different libraries for use with different .NET targets.</span></span> <span data-ttu-id="1f157-308">这使包可以支持许多不同的 .NET 平台，而这可能需要不同的实现。</span><span class="sxs-lookup"><span data-stu-id="1f157-308">This allows the packages to support many different .NET platforms, which may require different implementations.</span></span> <span data-ttu-id="1f157-309">这还意味着，在面向不同的 .NET 平台时，库中可能存在较小的 API 差异。</span><span class="sxs-lookup"><span data-stu-id="1f157-309">It also means that there may be small API differences in the libraries when targeting different .NET platforms.</span></span>

<span data-ttu-id="1f157-310">将在 Bean Trader 示例中看到的下一组错误与 `Castle.Windsor` API 相关。</span><span class="sxs-lookup"><span data-stu-id="1f157-310">The next set of errors you'll see in the Bean Trader sample are related to `Castle.Windsor` APIs.</span></span> <span data-ttu-id="1f157-311">.NET Core Bean Trader 项目使用的 `Castle.Windsor` 版本与面向 .NET Framework 的项目相同 (4.1.1)，但适用于这两个平台的实现略有不同。</span><span class="sxs-lookup"><span data-stu-id="1f157-311">The .NET Core Bean Trader project uses the same version of `Castle.Windsor` as the .NET Framework-targeted project (4.1.1), but the implementations for those two platforms are slightly different.</span></span>

<span data-ttu-id="1f157-312">在此例中，你将看到以下需要修复的问题：</span><span class="sxs-lookup"><span data-stu-id="1f157-312">In this case, you see the following issues that need to be fixed:</span></span>

1. <span data-ttu-id="1f157-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` 在 .NET Core 上不可用。</span><span class="sxs-lookup"><span data-stu-id="1f157-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` isn't available on .NET Core.</span></span> <span data-ttu-id="1f157-314">不过有类似的 API `Classes.FromAssemblyContaining` 可用，因此我们可以将 `Classes.FromThisAssembly()` 的两次使用替换为对 `Classes.FromAssemblyContaining(t)` 的调用，其中 `t` 是进行调用的类型。</span><span class="sxs-lookup"><span data-stu-id="1f157-314">There is, however, the similar API `Classes.FromAssemblyContaining` available, so we can replace both uses of `Classes.FromThisAssembly()` with calls to `Classes.FromAssemblyContaining(t)`, where `t` is the type making the call.</span></span>
1. <span data-ttu-id="1f157-315">Bootstrapper.cs 中的 `Castle.Windsor.Installer.FromAssembly` 也是如此。这在 .NET Core 中不可用。</span><span class="sxs-lookup"><span data-stu-id="1f157-315">Similarly, in *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`.This is unavailable on .NET Core.</span></span> <span data-ttu-id="1f157-316">相反，该调用可以替换为 `FromAssembly.Containing(typeof(Bootstrapper))`。</span><span class="sxs-lookup"><span data-stu-id="1f157-316">Instead, that call can be replaced with `FromAssembly.Containing(typeof(Bootstrapper))`.</span></span>

### <a name="updating-wcf-client-usage"></a><span data-ttu-id="1f157-317">更新 WCF 客户端使用</span><span class="sxs-lookup"><span data-stu-id="1f157-317">Updating WCF client usage</span></span>

<span data-ttu-id="1f157-318">修复了 `Castle.Windsor` 差异后，.NET Core Bean Trader 项目中剩下的最后一个生成错误是 `BeanTraderServiceClient`（派生自 `DuplexClientBase`）没有 `Open` 方法。</span><span class="sxs-lookup"><span data-stu-id="1f157-318">Having fixed the `Castle.Windsor` differences, the last remaining build error in the .NET Core Bean Trader project is that `BeanTraderServiceClient` (which derives from `DuplexClientBase`) doesn't have an `Open` method.</span></span> <span data-ttu-id="1f157-319">这并不令人吃惊，因为在此迁移过程开始时，.NET 可移植性分析器便突出显示了此 API。</span><span class="sxs-lookup"><span data-stu-id="1f157-319">This isn't surprising since this is an API that was highlighted by the .NET Portability Analyzer at the beginning of this migration process.</span></span> <span data-ttu-id="1f157-320">不过，查看 `BeanTraderServiceClient` 会让我们注意到一个更大的问题。</span><span class="sxs-lookup"><span data-stu-id="1f157-320">Looking at `BeanTraderServiceClient` draws our attention to a larger issue, though.</span></span> <span data-ttu-id="1f157-321">此 WCF 客户端由 [Svcutil.exe](/dotnet/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe) 工具自动生成。</span><span class="sxs-lookup"><span data-stu-id="1f157-321">This WCF client was autogenerated by the [Svcutil.exe](/dotnet/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe) tool.</span></span>

<span data-ttu-id="1f157-322">Svcutil 生成的 WCF 客户端旨在用于 .NET Framework。</span><span class="sxs-lookup"><span data-stu-id="1f157-322">**WCF clients generated by Svcutil are meant for use on .NET Framework.**</span></span>

<span data-ttu-id="1f157-323">使用 svcutil 生成的 WCF 客户端的解决方案将需要重新生成与 .NET Standard 兼容的客户端以用便与 .NET Core 一起使用。</span><span class="sxs-lookup"><span data-stu-id="1f157-323">Solutions that use svcutil-generated WCF clients will need to regenerate .NET Standard-compatible clients for use with .NET Core.</span></span> <span data-ttu-id="1f157-324">旧客户端无法正常工作的主要原因之一是它们依赖于应用配置来定义 WCF 绑定和终结点。</span><span class="sxs-lookup"><span data-stu-id="1f157-324">One of the main reasons the old clients won't work is that they depend on app configuration for defining WCF bindings and endpoints.</span></span> <span data-ttu-id="1f157-325">由于 .NET Standard WCF API 可以跨平台工作（其中 System.Configuration API 不可用），因此适用于 .NET Core 和 .NET Standard 方案的 WCF 客户端必须以编程方式（而不是在配置中）定义绑定和终结点。</span><span class="sxs-lookup"><span data-stu-id="1f157-325">Because .NET Standard WCF APIs can work cross-platform (where System.Configuration APIs aren't available), WCF clients for .NET Core and .NET Standard scenarios must define bindings and endpoints programmatically instead of in configuration.</span></span>

<span data-ttu-id="1f157-326">事实上，依赖于 `<system.serviceModel>` app.config 节的任何 WCF 客户端使用（无论是使用 Svcutil 还是手动创建）都需要进行更改以在 .NET Core 上正常工作。</span><span class="sxs-lookup"><span data-stu-id="1f157-326">In fact, any WCF client usage that depends on the `<system.serviceModel>` app.config section (whether created with Svcutil or manually) will need to be changed to work on .NET Core.</span></span>

<span data-ttu-id="1f157-327">可以通过两种方式自动生成与 .NET Standard 兼容的 WCF 客户端：</span><span class="sxs-lookup"><span data-stu-id="1f157-327">There are two ways to automatically generate .NET Standard-compatible WCF clients:</span></span>

- <span data-ttu-id="1f157-328">`dotnet-svcutil` 工具是一种 .NET 工具，它生成 WCF 客户端的方式与 Svcutil 以前的工作方式类似。</span><span class="sxs-lookup"><span data-stu-id="1f157-328">The `dotnet-svcutil` tool is a .NET tool that generates WCF clients in a way that is similar to how Svcutil worked previously.</span></span>
- <span data-ttu-id="1f157-329">Visual Studio 可以使用其连接的服务功能的 [WCF Web Service Reference](/dotnet/core/additional-tools/wcf-web-service-reference-guide) 选项生成 WCF 客户端。</span><span class="sxs-lookup"><span data-stu-id="1f157-329">Visual Studio can generate WCF clients using the [WCF Web Service Reference](/dotnet/core/additional-tools/wcf-web-service-reference-guide) option of its Connected Services feature.</span></span>

<span data-ttu-id="1f157-330">这两种方法都行之有效。</span><span class="sxs-lookup"><span data-stu-id="1f157-330">Either approach works well.</span></span> <span data-ttu-id="1f157-331">当然，也可以自己编写 WCF 客户端代码。</span><span class="sxs-lookup"><span data-stu-id="1f157-331">Alternatively, of course, you could write the WCF client code yourself.</span></span> <span data-ttu-id="1f157-332">对于此示例，我选择使用 Visual Studio 连接的服务功能。</span><span class="sxs-lookup"><span data-stu-id="1f157-332">For this sample, I chose to use the Visual Studio Connected Service feature.</span></span> <span data-ttu-id="1f157-333">若要执行该操作，请在 Visual Studio 的解决方案资源管理器中右键单击 BeanTraderClient.Core 项目，然后选择“添加” > “连接的服务”。</span><span class="sxs-lookup"><span data-stu-id="1f157-333">To do that, right-click on the *BeanTraderClient.Core* project in Visual Studio's solution explorer and select **Add** > **Connected Service**.</span></span> <span data-ttu-id="1f157-334">接下来，选择 WCF Web Service Reference Provider。</span><span class="sxs-lookup"><span data-stu-id="1f157-334">Next, choose the WCF Web Service Reference Provider.</span></span> <span data-ttu-id="1f157-335">这会显示一个对话框，可以在其中指定后端 Bean Trader Web 服务的地址（如果是在本地运行服务器，则为 `localhost:8080`）和生成的类型应使用的命名空间（例如 BeanTrader.Service）。</span><span class="sxs-lookup"><span data-stu-id="1f157-335">This will bring up a dialog where you can specify the address of the backend Bean Trader web service (`localhost:8080` if you are running the server locally) and the namespace that generated types should use (**BeanTrader.Service**, for example).</span></span>

![WCF Web Service Reference“连接的服务”对话框](./media/convert-project-from-net-framework/connected-service-dialog.png)

<span data-ttu-id="1f157-337">选择“完成”按钮之后，将向项目添加新的“连接的服务”节点，并在该节点下添加一个 Reference.cs 文件，其中包含用于访问 Bean Trader 服务的新 .NET Standard WCF 客户端。</span><span class="sxs-lookup"><span data-stu-id="1f157-337">After you select the **Finish** button, a new Connected Services node is added to the project and a Reference.cs file is added under that node containing the new .NET Standard WCF client for accessing the Bean Trader service.</span></span> <span data-ttu-id="1f157-338">如果查看该文件中的 `GetEndpointAddress` 或 `GetBindingForEndpoint` 方法，则会看到现在是以编程方式（而不是通过应用配置）生成绑定和终结点。</span><span class="sxs-lookup"><span data-stu-id="1f157-338">If you look at the `GetEndpointAddress` or `GetBindingForEndpoint` methods in that file, you'll see that bindings and endpoints are now generated programmatically (instead of via app config).</span></span> <span data-ttu-id="1f157-339">“添加连接的服务”功能可能还会在项目文件中添加对某些 System.ServiceModel 包的引用，这些引用并不需要，因为所有必需的 WCF 包都通过 Microsoft.Windows.Compatibility 包含在内。</span><span class="sxs-lookup"><span data-stu-id="1f157-339">The 'Add Connected Services' feature may also add references to some System.ServiceModel packages in the project file, which aren't needed since all necessary WCF packages are included via Microsoft.Windows.Compatibility.</span></span> <span data-ttu-id="1f157-340">检查 csproj 以查看是否添加了任何额外的 System.ServiceModel `<PackageReference>` 项，如果是，则删除它们。</span><span class="sxs-lookup"><span data-stu-id="1f157-340">Check the csproj to see if any extra System.ServiceModel `<PackageReference>` items have been added, and if so, remove them.</span></span>

<span data-ttu-id="1f157-341">现在，我们的项目具有新的 WCF 客户端类（在 Reference.cs 中），但是它也仍然具有旧的类（在 BeanTrader.cs 中）。</span><span class="sxs-lookup"><span data-stu-id="1f157-341">Our project has new WCF client classes now (in *Reference.cs*), but it also still has the old ones (in BeanTrader.cs).</span></span> <span data-ttu-id="1f157-342">此时有两个选项：</span><span class="sxs-lookup"><span data-stu-id="1f157-342">There are two options at this point:</span></span>

- <span data-ttu-id="1f157-343">如果希望能够生成原始 .NET Framework 项目（与面向 .NET Core 的新项目一起），则可以在 .NET Core 项目的 csproj 文件中使用 `<Compile Remove="BeanTrader.cs" />` 项，使应用的 .NET Framework 和 .NET Core 版本使用不同的 WCF 客户端。</span><span class="sxs-lookup"><span data-stu-id="1f157-343">If you want to be able to build the original .NET Framework project (alongside the new .NET Core-targeted one), you can use a `<Compile Remove="BeanTrader.cs" />` item in the .NET Core project's csproj file so that the .NET Framework and .NET Core versions of the app use different WCF clients.</span></span> <span data-ttu-id="1f157-344">这样做的优点是使现有 .NET Framework 项目不变，但缺点是，使用生成的 WCF 客户端的代码在 .NET Core 情况下可能需要与在 .NET Framework 项目中略有不同，因此可能需要使用 `#if` 指令有条件地编译某些 WCF 客户端使用（例如创建客户端），以便在针对 .NET Core 进行生成时以一种方式工作，而在针对 .NET Framework 进行生成时以另一种方式工作。</span><span class="sxs-lookup"><span data-stu-id="1f157-344">This has the advantage of leaving the existing .NET Framework project unchanged, but has the disadvantage that code using the generated WCF clients may need to be slightly different in the .NET Core case than it was in the .NET Framework project, so you'll likely need to use `#if` directives to conditionally compile some WCF client usage (creating clients, for example) to work one way when built for .NET Core and another way when built for .NET Framework.</span></span>

- <span data-ttu-id="1f157-345">另一方面，如果现有 .NET Framework 项目中的一些代码改动是可接受的，则可以将 BeanTrader.cs 全部删除。</span><span class="sxs-lookup"><span data-stu-id="1f157-345">If, on the other hand, some code churn in the existing .NET Framework project is acceptable, you can remove *BeanTrader.cs* all together.</span></span> <span data-ttu-id="1f157-346">由于新 WCF 客户端是针对 .NET Standard 而生成的，因此它将在 .NET Core 和 .NET Framework 方案中正常工作。</span><span class="sxs-lookup"><span data-stu-id="1f157-346">Because the new WCF client is built for .NET Standard, it will work in both .NET Core and .NET Framework scenarios.</span></span> <span data-ttu-id="1f157-347">如果除了 .NET Core 之外，还要针对 .NET Framework 进行生成（通过多目标或具有两个 csproj 文件），则可以这一新的 Reference.cs 文件用于这两个目标。</span><span class="sxs-lookup"><span data-stu-id="1f157-347">If you are building for .NET Framework in addition to .NET Core (either by multi-targeting or by having two csproj files), you can use this new *Reference.cs* file for both targets.</span></span> <span data-ttu-id="1f157-348">此方法的优点是，代码无需分叉即可支持两个不同的 WCF 客户端；将在所有位置使用相同的代码。</span><span class="sxs-lookup"><span data-stu-id="1f157-348">This approach has the advantage that the code won't need to bifurcate to support two different WCF clients; the same code will be used everywhere.</span></span> <span data-ttu-id="1f157-349">缺点是它涉及更改（可能稳定的）.NET Framework 项目。</span><span class="sxs-lookup"><span data-stu-id="1f157-349">The drawback is that it involves changing the (presumably stable) .NET Framework project.</span></span>

<span data-ttu-id="1f157-350">对于 Bean Trader 示例，如果使迁移更简单，则可以对原始项目进行少量更改，因此请按照以下步骤来协调 WCF 客户端使用：</span><span class="sxs-lookup"><span data-stu-id="1f157-350">In the case of the Bean Trader sample, you can make small changes to the original project if it makes migration easier, so follow these steps to reconcile WCF client usage:</span></span>

01. <span data-ttu-id="1f157-351">使用解决方案资源管理器中的“添加现有项”上下文菜单将新 Reference.cs 文件添加到 .NET Framework BeanTraderClient.csproj 项目。</span><span class="sxs-lookup"><span data-stu-id="1f157-351">Add the new Reference.cs file to the .NET Framework *BeanTraderClient.csproj* project using the 'Add existing item' context menu from the solution explorer.</span></span> <span data-ttu-id="1f157-352">请务必添加为“链接”，以便两个项目使用相同文件（与复制 C# 文件相反）。</span><span class="sxs-lookup"><span data-stu-id="1f157-352">Be sure to add 'as link' so that the same file is used by both projects (as opposed to copying the C# file).</span></span> <span data-ttu-id="1f157-353">如果在使用单个 csproj 同时针对 .NET Core 和 .NET Framework 进行生成（使用多目标），则无需执行此步骤。</span><span class="sxs-lookup"><span data-stu-id="1f157-353">If you are building for both .NET Core and .NET Framework with a single csproj (using multi-targeting) then this step isn't necessary.</span></span>

01. <span data-ttu-id="1f157-354">删除 BeanTrader.cs。</span><span class="sxs-lookup"><span data-stu-id="1f157-354">Delete *BeanTrader.cs*.</span></span>

01. <span data-ttu-id="1f157-355">新 WCF 客户端类似于旧客户端，但生成的代码中的一些命名空间是不同的。</span><span class="sxs-lookup"><span data-stu-id="1f157-355">The new WCF client is similar to the old one, but a number of namespaces in the generated code are different.</span></span> <span data-ttu-id="1f157-356">因此需要更新项目，以便通过 BeanTrader.Service（或所选的任何命名空间名称）使用 WCF 客户端类型（而不是 BeanTrader.Model 或不使用命名空间）。</span><span class="sxs-lookup"><span data-stu-id="1f157-356">Because of this, it is necessary to update the project so that WCF client types are used from BeanTrader.Service (or whatever namespace name you chose) instead of BeanTrader.Model or without a namespace.</span></span> <span data-ttu-id="1f157-357">生成 BeanTraderClient.Core.csproj 将有助于标识需要进行这些更改的位置。</span><span class="sxs-lookup"><span data-stu-id="1f157-357">Building *BeanTraderClient.Core.csproj* will help to identify where these changes need to be made.</span></span> <span data-ttu-id="1f157-358">C# 和 XAML 源文件中都需要进行修复。</span><span class="sxs-lookup"><span data-stu-id="1f157-358">Fixes will be needed both in C# and in XAML source files.</span></span>

01. <span data-ttu-id="1f157-359">最后会发现 BeanTraderServiceClientFactory.cs 中有一个错误，因为 `BeanTraderServiceClient` 类型的可用构造函数已更改。</span><span class="sxs-lookup"><span data-stu-id="1f157-359">Finally, you'll discover that there is an error in *BeanTraderServiceClientFactory.cs* because the available constructors for the `BeanTraderServiceClient` type have changed.</span></span> <span data-ttu-id="1f157-360">过去可以提供 `InstanceContext` 参数（从 `Castle.Windsor` IoC 容器使用 `CallbackHandler` 进行创建）。</span><span class="sxs-lookup"><span data-stu-id="1f157-360">It used to be possible to supply an `InstanceContext` argument (which was created using a `CallbackHandler` from the `Castle.Windsor` IoC container).</span></span> <span data-ttu-id="1f157-361">新构造函数会创建新 `CallbackHandler`。</span><span class="sxs-lookup"><span data-stu-id="1f157-361">The new constructors create new `CallbackHandler`s.</span></span> <span data-ttu-id="1f157-362">但是，`BeanTraderServiceClient`的基类型中存在与所需内容匹配的构造函数。</span><span class="sxs-lookup"><span data-stu-id="1f157-362">There are, however, constructors in `BeanTraderServiceClient`'s base type that match what you want.</span></span> <span data-ttu-id="1f157-363">由于自动生成的 WCF 客户端代码全都存在于分部类中，因此可以轻松地对它进行扩展。</span><span class="sxs-lookup"><span data-stu-id="1f157-363">Since the autogenerated WCF client code all exists in partial classes, you can easily extend it.</span></span> <span data-ttu-id="1f157-364">为此，请创建一个名为 BeanTraderServiceClient.cs 的新文件，然后创建一个具有该相同名称的分部类（使用 BeanTrader.Service 命名空间）。</span><span class="sxs-lookup"><span data-stu-id="1f157-364">To do this, create a new file called *BeanTraderServiceClient.cs* and then create a partial class with that same name (using the BeanTrader.Service namespace).</span></span> <span data-ttu-id="1f157-365">然后，将一个构造函数添加到该分部类型，如下所示。</span><span class="sxs-lookup"><span data-stu-id="1f157-365">Then, add one constructor to the partial type as shown here.</span></span>

    ```csharp
    public BeanTraderServiceClient(System.ServiceModel.InstanceContext callbackInstance) :
        base(callbackInstance, EndpointConfiguration.NetTcpBinding_BeanTraderService)
            { }
    ```

<span data-ttu-id="1f157-366">进行这些更改后，Bean Trader 示例现在使用与 .NET Standard 兼容的新 WCF 客户端，你可以在 TradingService.cs 中进行更改 `Open` 调用的最终修复，以改用使用 `await OpenAsync`。</span><span class="sxs-lookup"><span data-stu-id="1f157-366">With those changes made, the Bean Trader sample will now be using a new .NET Standard-compatible WCF client and you can make the final fix of changing the `Open` call in *TradingService.cs* to use `await OpenAsync` instead.</span></span>

<span data-ttu-id="1f157-367">解决了 WCF 问题后，Bean Trader 示例的 .NET Core 版本现在可完全生成！</span><span class="sxs-lookup"><span data-stu-id="1f157-367">With the WCF issues addressed, the .NET Core version of the Bean Trader sample now builds cleanly!</span></span>

## <a name="runtime-testing"></a><span data-ttu-id="1f157-368">运行时测试</span><span class="sxs-lookup"><span data-stu-id="1f157-368">Runtime testing</span></span>

<span data-ttu-id="1f157-369">很容易忘记的一点是，项目针对 .NET Core 完全生成后，迁移工作并未就此完成。</span><span class="sxs-lookup"><span data-stu-id="1f157-369">It's easy to forget that migration work isn't done as soon as the project builds cleanly against .NET Core.</span></span> <span data-ttu-id="1f157-370">为测试移植的应用留出时间也非常重要。</span><span class="sxs-lookup"><span data-stu-id="1f157-370">It's important to leave time for testing the ported app, too.</span></span> <span data-ttu-id="1f157-371">成功生成后，确保应用可按预期运行和工作，尤其是在使用任何面向 .NET Framework 的包时。</span><span class="sxs-lookup"><span data-stu-id="1f157-371">Once things build successfully, make sure the app runs and works as expected, especially if you are using any packages targeting .NET Framework.</span></span>

<span data-ttu-id="1f157-372">让我们尝试启动移植的 Bean Trader 应用，来看看会发生什么情况。</span><span class="sxs-lookup"><span data-stu-id="1f157-372">Let's try launching the ported Bean Trader app and see what happens.</span></span> <span data-ttu-id="1f157-373">该应用不久便失败，出现以下异常。</span><span class="sxs-lookup"><span data-stu-id="1f157-373">The app doesn't get far before failing with the following exception.</span></span>

```output
System.Configuration.ConfigurationErrorsException: 'Configuration system failed to initialize'

Inner Exception
ConfigurationErrorsException: Unrecognized configuration section system.serviceModel.
```

<span data-ttu-id="1f157-374">这当然很有意义。</span><span class="sxs-lookup"><span data-stu-id="1f157-374">This makes sense, of course.</span></span> <span data-ttu-id="1f157-375">请记住，WCF 不再使用应用配置，因此需要删除 app.config 文件的旧 system.serviceModel 节。</span><span class="sxs-lookup"><span data-stu-id="1f157-375">Remember that WCF no longer uses app configuration, so the old system.serviceModel section of the app.config file needs to be removed.</span></span> <span data-ttu-id="1f157-376">更新的 WCF 客户端在其代码中包含所有相同的信息，因此不再需要该 config 节。</span><span class="sxs-lookup"><span data-stu-id="1f157-376">The updated WCF client includes all of the same information in its code, so the config section isn't needed anymore.</span></span> <span data-ttu-id="1f157-377">如果希望可在 app.config 中配置 WCF 终结点，则可以将它添加为应用设置，并更新 WCF 客户端代码，以从配置中检索 WCF 服务终结点。</span><span class="sxs-lookup"><span data-stu-id="1f157-377">If you wanted the WCF endpoint to be configurable in app.config, you could add it as an app setting and update the WCF client code to retrieve the WCF service endpoint from configuration.</span></span>

<span data-ttu-id="1f157-378">删除 app.config 的 system.serviceModel 节之后，应用将启动，但是在用户登录时会失败，并出现另一个异常。</span><span class="sxs-lookup"><span data-stu-id="1f157-378">After removing the system.serviceModel section of *app.config*, the app launches but fails with another exception when a user signs in.</span></span>

```output
System.PlatformNotSupportedException: 'Operation is not supported on this platform.'
```

<span data-ttu-id="1f157-379">不支持的 API 为 `Func<T>.BeginInvoke`。</span><span class="sxs-lookup"><span data-stu-id="1f157-379">The unsupported API is `Func<T>.BeginInvoke`.</span></span> <span data-ttu-id="1f157-380">如 [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940) 中所述，由于基础远程处理依赖项，.NET Core 不支持委托类型上的 `BeginInvoke` 和 `EndInvoke` 方法。</span><span class="sxs-lookup"><span data-stu-id="1f157-380">As explained in [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET Core doesn't support the `BeginInvoke` and `EndInvoke` methods on delegate types due to underlying remoting dependencies.</span></span> <span data-ttu-id="1f157-381">此问题及其修复在[针对 .NET Core 迁移 Delegate.BeginInvoke 调用](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/)博客文章中进行了更详细的说明，但要点是应将 `BeginInvoke` 和 `EndInvoke` 调用替换为 `Task.Run`（如果可能，则替换为异步替代方法）。</span><span class="sxs-lookup"><span data-stu-id="1f157-381">This issue and its fix are explained in more detail in the [Migrating Delegate.BeginInvoke Calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blog post, but the gist is that `BeginInvoke` and `EndInvoke` calls should be replaced with `Task.Run` (or async alternatives, if possible).</span></span> <span data-ttu-id="1f157-382">在此处应用常规解决方案，`BeginInvoke` 调用可以替换为由 `Task.Run` 启动的 `Invoke` 调用。</span><span class="sxs-lookup"><span data-stu-id="1f157-382">Applying the general solution here, the `BeginInvoke` call can be replaced with an `Invoke` call launched by `Task.Run`.</span></span>

```csharp
Task.Run(() =>
{
    return userInfoRetriever.Invoke();
}).ContinueWith(result =>
{
    // BeginInvoke's callback is replaced with ContinueWith
    var task = result.ConfigureAwait(false);
    CurrentTrader = task.GetAwaiter().GetResult();
}, TaskScheduler.Default);
```

<span data-ttu-id="1f157-383">删除 `BeginInvoke` 使用之后，Bean Trader 应用可在 .NET Core 上成功运行！</span><span class="sxs-lookup"><span data-stu-id="1f157-383">After removing the `BeginInvoke` usage, the Bean Trader app runs successfully on .NET Core!</span></span>

![在 .NET Core 上运行的 Bean Trader](./media/convert-project-from-net-framework/running-on-core.png)

<span data-ttu-id="1f157-385">所有应用都是不同的，因此将自己的应用迁移到 .NET Core 所需的具体步骤会有所不同。</span><span class="sxs-lookup"><span data-stu-id="1f157-385">All apps are different, so the specific steps needed to migrate your own apps to .NET Core will vary.</span></span> <span data-ttu-id="1f157-386">不过希望 Bean Trader 示例可演示常规工作流以及可以预期的问题类型。</span><span class="sxs-lookup"><span data-stu-id="1f157-386">But hopefully the Bean Trader sample demonstrates the general workflow and the types of issues that can be expected.</span></span> <span data-ttu-id="1f157-387">而且，尽管本文篇幅很长，但是 Bean Trader 示例中使它可在 .NET Core 上正常工作所需的实际更改是相当有限的。</span><span class="sxs-lookup"><span data-stu-id="1f157-387">And, despite this article's length, the actual changes needed in the Bean Trader sample to make it work on .NET Core were fairly limited.</span></span> <span data-ttu-id="1f157-388">许多应用以相同方式迁移到 .NET Core；只需要进行有限的代码更改，甚至不需要任何更改。</span><span class="sxs-lookup"><span data-stu-id="1f157-388">Many apps migrate to .NET Core in this same way; with limited or even no code changes needed.</span></span>
