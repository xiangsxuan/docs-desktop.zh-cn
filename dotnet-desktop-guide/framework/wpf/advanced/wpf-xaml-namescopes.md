---
title: XAML 名称范围
ms.date: 03/30/2017
helpviewer_keywords:
- namescopes [WPF]
- styles [WPF], namescopes in
- templates [WPF], namescopes in
- APIs [WPF], name-related
- name-related APIs
- XAML [WPF], namescopes
- classes [WPF], FrameworkContentElement
ms.assetid: 52bbf4f2-15fc-40d4-837b-bb4c21ead7d4
ms.openlocfilehash: d78523e608b41e26123b28f16299e749bec4375b
ms.sourcegitcommit: 069786bcadbf9cd931d7dc3d892262cd852d2ffb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/19/2021
ms.locfileid: "104667325"
---
# <a name="wpf-xaml-namescopes"></a><span data-ttu-id="4e7b7-102">WPF XAML 名称范围</span><span class="sxs-lookup"><span data-stu-id="4e7b7-102">WPF XAML Namescopes</span></span>
<span data-ttu-id="4e7b7-103">XAML 名称范围是关于标识 XAML 中定义的对象的一个概念。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-103">XAML namescopes are a concept that identifies objects that are defined in XAML.</span></span> <span data-ttu-id="4e7b7-104">XAML 名称范围中的名称可用于在对象树的对象 XAML 定义名称和其实例等效项之间建立关系。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-104">The names in a XAML namescope can be used to establish relationships between the XAML-defined names of objects and their instance equivalents in an object tree.</span></span> <span data-ttu-id="4e7b7-105">通常，在加载 XAML 应用程序的各个 XAML 页面根时会以 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 托管代码创建 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-105">Typically, XAML namescopes in [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] managed code are created when loading the individual XAML page roots for a XAML application.</span></span> <span data-ttu-id="4e7b7-106">XAML 名称范围作为编程对象由 <xref:System.Windows.Markup.INameScope> 接口定义，并且还由实际类实现 <xref:System.Windows.NameScope> 。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-106">XAML namescopes as the programming object are defined by the <xref:System.Windows.Markup.INameScope> interface and are also implemented by the practical class <xref:System.Windows.NameScope>.</span></span>  

<a name="Namescopes_in_Loaded_XAML_Applications"></a>
## <a name="namescopes-in-loaded-xaml-applications"></a><span data-ttu-id="4e7b7-107">加载的 XAML 应用程序中的名称范围</span><span class="sxs-lookup"><span data-stu-id="4e7b7-107">Namescopes in Loaded XAML Applications</span></span>  
 <span data-ttu-id="4e7b7-108">从更广泛的编程或计算机科学来说，编程概念通常包括可用于访问对象的唯一标识符或名称的原则。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-108">In a broader programming or computer science context, programming concepts often include the principle of a unique identifier or name that can be used to access an object.</span></span> <span data-ttu-id="4e7b7-109">对于使用标识符或名称的系统，名称范围会定义边界，在该边界中，进程或技术会搜索是否请求了具有该名称的对象或者是否执行了标识名称唯一性。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-109">For systems that use identifiers or names, the namescope defines the boundaries within which a process or technique will search if an object of that name is requested, or the boundaries wherein uniqueness of identifying names is enforced.</span></span> <span data-ttu-id="4e7b7-110">这些一般原则适用于 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-110">These general principles are true for XAML namescopes.</span></span> <span data-ttu-id="4e7b7-111">在 WPF 中，当 XAML 页面加载时，会在该页面的根元素上创建 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-111">In WPF, XAML namescopes are created on the root element for a XAML page when the page is loaded.</span></span> <span data-ttu-id="4e7b7-112">在 XAML 页面的页面根位置处指定的每个名称会添加到相关的 XAML 名称范围中。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-112">Each name specified within the XAML page starting at the page root is added to a pertinent XAML namescope.</span></span>  
  
 <span data-ttu-id="4e7b7-113">在 WPF XAML 中，作为常见 root 元素的元素 (例如 <xref:System.Windows.Controls.Page> ， <xref:System.Windows.Window>) 始终控制 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-113">In WPF XAML, elements that are common root elements (such as <xref:System.Windows.Controls.Page>, and <xref:System.Windows.Window>) always control a XAML namescope.</span></span> <span data-ttu-id="4e7b7-114">如果元素（如 <xref:System.Windows.FrameworkElement> 或） <xref:System.Windows.FrameworkContentElement> 是标记中页面的根元素，则处理器会 [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] <xref:System.Windows.Controls.Page> 隐式添加根，以便 <xref:System.Windows.Controls.Page> 能够提供工作的 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-114">If an element such as <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> is the root element of the page in markup, a [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] processor adds a <xref:System.Windows.Controls.Page> root implicitly so that the <xref:System.Windows.Controls.Page> can provide a working XAML namescope.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="4e7b7-115">即使在 [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] 标记中的任何元素上都没有定义 `Name` 或 `x:Name` 特性，WPF 生成操作也将为 XAML 生产创建 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-115">WPF build actions create a XAML namescope for a XAML production even if no `Name` or `x:Name` attributes are defined on any elements in the [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] markup.</span></span>  
  
 <span data-ttu-id="4e7b7-116">如果尝试在任何 XAML 名称范围中两次使用相同的名称，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-116">If you try to use the same name twice in any XAML namescope, an exception is raised.</span></span> <span data-ttu-id="4e7b7-117">对于具有代码隐藏且作为已编译应用程序的一部分的 WPF XAML，在初始标记编译期间为页面创建生成类时，WPF 生成操作在生成时会引发异常。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-117">For WPF XAML that has code-behind and is part of a compiled application, the exception is raised at build time by WPF build actions, when creating the generated class for the page during the initial markup compile.</span></span> <span data-ttu-id="4e7b7-118">对于不由任何生成操作进行标记编译的 XAML，加载 XAML 时可能会引发与 XAML 名称范围问题相关的异常。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-118">For XAML that is not markup-compiled by any build action, exceptions related to XAML namescope issues might be raised when the XAML is loaded.</span></span> <span data-ttu-id="4e7b7-119">XAML 设计器在设计时也可能会出现 XAML 名称范围问题。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-119">XAML designers might also anticipate XAML namescope issues at design time.</span></span>  
  
### <a name="adding-objects-to-runtime-object-trees"></a><span data-ttu-id="4e7b7-120">将对象添加到运行时对象树</span><span class="sxs-lookup"><span data-stu-id="4e7b7-120">Adding Objects to Runtime Object Trees</span></span>  
 <span data-ttu-id="4e7b7-121">分析 XAML 时即意味着创建并定义 WPF XAML 名称范围的时刻。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-121">The moment that XAML is parsed represents the moment in time that a WPF XAML namescope is created and defined.</span></span> <span data-ttu-id="4e7b7-122">如果在分析生成对象树的 XAML 之后的时间点将对象添加到对象树，新对象上的 `Name` 或 `x:Name` 值不会在 XAML 名称范围中自动更新信息。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-122">If you add an object to an object tree at a point in time after the XAML that produced that tree was parsed, a `Name` or `x:Name` value on the new object does not automatically update the information in a XAML namescope.</span></span> <span data-ttu-id="4e7b7-123">若要在加载 XAML 后将对象的名称添加到 WPF XAML 名称范围，则必须 <xref:System.Windows.Markup.INameScope.RegisterName%2A> 在定义 xaml 名称范围的对象（通常为 xaml 页根）上调用相应的实现。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-123">To add a name for an object into a WPF XAML namescope after XAML is loaded, you must call the appropriate implementation of <xref:System.Windows.Markup.INameScope.RegisterName%2A> on the object that defines the XAML namescope, which is typically the XAML page root.</span></span> <span data-ttu-id="4e7b7-124">如果该名称未注册，则无法通过方法（如）通过名称引用添加的对象， <xref:System.Windows.FrameworkElement.FindName%2A> 并且不能将该名称用于动画目标。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-124">If the name is not registered, the added object cannot be referenced by name through methods such as <xref:System.Windows.FrameworkElement.FindName%2A>, and you cannot use that name for animation targeting.</span></span>  
  
 <span data-ttu-id="4e7b7-125">对于应用程序开发人员而言，最常见的方案是使用将 <xref:System.Windows.FrameworkElement.RegisterName%2A> 名称注册到页的当前根的 XAML 名称范围中。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-125">The most common scenario for application developers is that you will use <xref:System.Windows.FrameworkElement.RegisterName%2A> to register names into the XAML namescope on the current root of the page.</span></span> <span data-ttu-id="4e7b7-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> 是面向动画对象的情节提要的一个重要方案的一部分。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> is part of an important scenario for storyboards that target objects for animations.</span></span> <span data-ttu-id="4e7b7-127">有关详细信息，请参阅[情节提要概述](../graphics-multimedia/storyboards-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-127">For more information, see [Storyboards Overview](../graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="4e7b7-128">如果对 <xref:System.Windows.FrameworkElement.RegisterName%2A> 定义 XAML 名称范围的对象之外的对象调用，则该名称仍将注册到调用对象所在的 xaml 名称范围中，就像你 <xref:System.Windows.FrameworkElement.RegisterName%2A> 在定义对象的 xaml 名称范围中调用一样。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-128">If you call <xref:System.Windows.FrameworkElement.RegisterName%2A> on an object other than the object that defines the XAML namescope, the name is still registered to the XAML namescope that the calling object is held within, as if you had called <xref:System.Windows.FrameworkElement.RegisterName%2A> on the XAML namescope defining object.</span></span>  
  
### <a name="xaml-namescopes-in-code"></a><span data-ttu-id="4e7b7-129">代码中的 XAML 名称范围</span><span class="sxs-lookup"><span data-stu-id="4e7b7-129">XAML Namescopes in Code</span></span>  
 <span data-ttu-id="4e7b7-130">可以通过代码创建然后使用 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-130">You can create and then use XAML namescopes in code.</span></span> <span data-ttu-id="4e7b7-131">创建 XAML 名称范围所涉及的 API 和概念甚至与使用纯代码相同，因为 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 的 XAML 处理器在自身处理 XAML 时就会使用这些 API 和概念。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-131">The APIs and the concepts involved in XAML namescope creation are the same even for a pure code usage, because the XAML processor for [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] uses these APIs and concepts when it processes XAML itself.</span></span> <span data-ttu-id="4e7b7-132">这些概念和 API 存在的主要目的是为了能够在对象树中按名称查找对象（此对象树通常在 XAML 中完全或部分定义）。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-132">The concepts and API exist mainly for the purpose of being able to find objects by name within an object tree that is typically defined partially or entirely in XAML.</span></span>  
  
 <span data-ttu-id="4e7b7-133">对于以编程方式而不是从加载的 XAML 创建的应用程序，定义 XAML 名称范围的对象必须实现 <xref:System.Windows.Markup.INameScope> 或为 <xref:System.Windows.FrameworkElement> 或 <xref:System.Windows.FrameworkContentElement> 派生类，以便支持在其实例上创建 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-133">For applications that are created programmatically, and not from loaded XAML, the object that defines a XAML namescope must implement <xref:System.Windows.Markup.INameScope>, or be a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> derived class, in order to support creation of a XAML namescope on its instances.</span></span>  
  
 <span data-ttu-id="4e7b7-134">此外，对于任何不由 XAML 处理器加载和处理的元素，默认情况下不会创建或初始化对象的 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-134">Also, for any element that is not loaded and processed by a XAML processor, the XAML namescope for the object is not created or initialized by default.</span></span> <span data-ttu-id="4e7b7-135">必须为随后要将名称注册到其中的任何对象显式创建新的 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-135">You must explicitly create a new XAML namescope for any object that you intend to register names into subsequently.</span></span> <span data-ttu-id="4e7b7-136">若要创建 XAML 名称范围，请调用静态 <xref:System.Windows.NameScope.SetNameScope%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-136">To create a XAML namescope, you call the static <xref:System.Windows.NameScope.SetNameScope%2A> method.</span></span> <span data-ttu-id="4e7b7-137">指定将该对象作为参数的对象 `dependencyObject` ，并指定一个新的 <xref:System.Windows.NameScope.%23ctor%2A> 构造函数调用作为 `value` 参数。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-137">Specify the object that will own it as the `dependencyObject` parameter, and a new <xref:System.Windows.NameScope.%23ctor%2A> constructor call as the `value` parameter.</span></span>  
  
 <span data-ttu-id="4e7b7-138">如果为提供的对象 `dependencyObject` <xref:System.Windows.NameScope.SetNameScope%2A> 不是 <xref:System.Windows.Markup.INameScope> 实现 <xref:System.Windows.FrameworkElement> 或，则 <xref:System.Windows.FrameworkContentElement> <xref:System.Windows.FrameworkElement.RegisterName%2A> 对任何子元素调用都不起作用。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-138">If the object provided as `dependencyObject` for <xref:System.Windows.NameScope.SetNameScope%2A> is not a <xref:System.Windows.Markup.INameScope> implementation, <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, calling <xref:System.Windows.FrameworkElement.RegisterName%2A> on any child elements will have no effect.</span></span> <span data-ttu-id="4e7b7-139">如果无法显式创建新的 XAML 名称范围，则对的调用 <xref:System.Windows.FrameworkElement.RegisterName%2A> 将引发异常。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-139">If you fail to create the new XAML namescope explicitly, then calls to <xref:System.Windows.FrameworkElement.RegisterName%2A> will raise an exception.</span></span>  
  
 <span data-ttu-id="4e7b7-140">有关以代码方式使用 XAML 名称范围 API 的示例，请参阅[定义名称范围](../graphics-multimedia/how-to-define-a-name-scope.md)。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-140">For an example of using XAML namescope APIs in code, see [Define a Name Scope](../graphics-multimedia/how-to-define-a-name-scope.md).</span></span>  
  
<a name="Namescopes_in_Styles_and_Templates"></a>
## <a name="xaml-namescopes-in-styles-and-templates"></a><span data-ttu-id="4e7b7-141">样式和模板中的 XAML 名称范围</span><span class="sxs-lookup"><span data-stu-id="4e7b7-141">XAML Namescopes in Styles and Templates</span></span>  
 <span data-ttu-id="4e7b7-142">通过 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 中的样式和模板，可以直接重复使用和重复应用内容。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-142">Styles and templates in [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] provide the ability to reuse and reapply content in a straightforward way.</span></span> <span data-ttu-id="4e7b7-143">但是，样式和模板可能还包含具有模板级别定义的 XAML 名称的元素。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-143">However, styles and templates might also include elements with XAML names defined at the template level.</span></span> <span data-ttu-id="4e7b7-144">此相同模板可在一个页面中多次使用。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-144">That same template might be used multiple times in a page.</span></span> <span data-ttu-id="4e7b7-145">出于此原因，样式和模板皆定义其自身的 XAML 名称范围，与在应用样式或模板的对象树中的位置无关。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-145">For this reason, styles and templates both define their own XAML namescopes, independent of whatever location in an object tree where the style or template is applied.</span></span>  
  
 <span data-ttu-id="4e7b7-146">请看下面的示例：</span><span class="sxs-lookup"><span data-stu-id="4e7b7-146">Consider the following example:</span></span>  
  
 [!code-xaml[XamlOvwSupport#NameScopeTemplates](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page6.xaml#namescopetemplates)]  
  
 <span data-ttu-id="4e7b7-147">此处，同一模板应用到两个不同的按钮。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-147">Here, the same template is applied to two different buttons.</span></span> <span data-ttu-id="4e7b7-148">如果模板不具有离散的 XAML 名称范围，则模板中使用的 `TheBorder` 名称会导致 XAML 名称范围中的名称冲突。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-148">If templates did not have discrete XAML namescopes, the `TheBorder` name used in the template would cause a name collision in the XAML namescope.</span></span> <span data-ttu-id="4e7b7-149">模板的每个实例都具有其自己的 XAML 名称范围，因此在本例中，每个实例化模板的 XAML 名称范围仅包含一个名称。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-149">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</span></span>  
  
 <span data-ttu-id="4e7b7-150">样式也定义其自身的 XAML 名称范围，因此情节提要的各部分均可分配有特定的名称。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-150">Styles also define their own XAML namescope, mostly so that parts of storyboards can have particular names assigned.</span></span> <span data-ttu-id="4e7b7-151">即使在控件自定义过程中重新定义模板，这些名称也可实现控件特定行为，定位具有该名称的元素。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-151">These names enable control specific behaviors that will target elements of that name, even if the template was re-defined as part of control customization.</span></span>  
  
 <span data-ttu-id="4e7b7-152">由于这些分开的 XAML 名称范围，在模板中查找命名元素比在页面中查找非模板命名元素难度更大。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-152">Because of the separate XAML namescopes, finding named elements in a template is more challenging than finding a non-templated named element in a page.</span></span> <span data-ttu-id="4e7b7-153">首先需要通过获取 <xref:System.Windows.Controls.Control.Template%2A> 应用模板的控件的属性值来确定已应用的模板。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-153">You first need to determine the applied template, by getting the <xref:System.Windows.Controls.Control.Template%2A> property value of the control where the template is applied.</span></span> <span data-ttu-id="4e7b7-154">然后，调用的模板版本 <xref:System.Windows.FrameworkTemplate.FindName%2A> ，并将作为第二个参数应用了模板的控件传递给它。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-154">Then, you call the template version of <xref:System.Windows.FrameworkTemplate.FindName%2A>, passing the control where the template was applied as the second parameter.</span></span>  
  
 <span data-ttu-id="4e7b7-155">如果你是控件作者，而你正在生成一个约定，其中应用的模板中的特定命名元素是控件本身定义的行为的目标，则可以使用 <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> 控件实现代码中的方法。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-155">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method from your control implementation code.</span></span> <span data-ttu-id="4e7b7-156">此 <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> 方法是受保护的，因此只有控件作者可以访问它。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-156">The <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method is protected, so only the control author has access to it.</span></span>  
  
 <span data-ttu-id="4e7b7-157">如果是在模板中工作，并且需要访问应用了模板的 XAML 名称范围，请获取的值 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> ，然后调用该名称 <xref:System.Windows.FrameworkElement.FindName%2A> 。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-157">If you are working from within a template, and need to get to the XAML namescope where the template is applied, get the value of <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, and then call <xref:System.Windows.FrameworkElement.FindName%2A> there.</span></span> <span data-ttu-id="4e7b7-158">从模板内入手的一个示例是编写事件将从已应用模板中的元素引发的事件处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-158">An example of working within the template would be if you are writing the event handler implementation where the event will be raised from an element in an applied template.</span></span>  
  
<a name="Namescopes_and_Name_related_APIs"></a>
## <a name="xaml-namescopes-and-name-related-apis"></a><span data-ttu-id="4e7b7-159">XAML 名称范围和与名称相关的 API</span><span class="sxs-lookup"><span data-stu-id="4e7b7-159">XAML Namescopes and Name-related APIs</span></span>  
 <span data-ttu-id="4e7b7-160"><xref:System.Windows.FrameworkElement> 具有 <xref:System.Windows.FrameworkElement.FindName%2A> <xref:System.Windows.FrameworkElement.RegisterName%2A> 和 <xref:System.Windows.FrameworkElement.UnregisterName%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-160"><xref:System.Windows.FrameworkElement> has <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> and <xref:System.Windows.FrameworkElement.UnregisterName%2A> methods.</span></span> <span data-ttu-id="4e7b7-161">如果在其上调用这些方法的对象拥有 XAML 名称范围，则这些方法会调入相关 XAML 名称范围的方法。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-161">If the object you call these methods on owns a XAML namescope, the methods call into the methods of the relevant XAML namescope.</span></span> <span data-ttu-id="4e7b7-162">否则，将检查父元素以查看其是否拥有 XAML 名称范围，此过程以递归方式持续发生，直到找到 XAML 名称范围（由于 XAML 处理器行为，根处必定存在一个 XAML 名称范围）。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-162">Otherwise, the parent element is checked to see if it owns a XAML namescope, and this process continues recursively until a XAML namescope is found (because of the XAML processor behavior, there is guaranteed to be a XAML namescope at the root).</span></span> <span data-ttu-id="4e7b7-163"><xref:System.Windows.FrameworkContentElement> 具有类似的行为，但不会有任何 <xref:System.Windows.FrameworkContentElement> 一个 XAML 名称范围。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-163"><xref:System.Windows.FrameworkContentElement> has analogous behaviors, with the exception that no <xref:System.Windows.FrameworkContentElement> will ever own a XAML namescope.</span></span> <span data-ttu-id="4e7b7-164">方法存在于中， <xref:System.Windows.FrameworkContentElement> 以便可以将调用最终转发到 <xref:System.Windows.FrameworkElement> 父元素。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-164">The methods exist on <xref:System.Windows.FrameworkContentElement> so that the calls can be forwarded eventually to a <xref:System.Windows.FrameworkElement> parent element.</span></span>  
  
 <span data-ttu-id="4e7b7-165"><xref:System.Windows.NameScope.SetNameScope%2A> 用于将新的 XAML 名称范围映射到现有对象。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-165"><xref:System.Windows.NameScope.SetNameScope%2A> is used to map a new XAML namescope to an existing object.</span></span> <span data-ttu-id="4e7b7-166">可以多次调用 <xref:System.Windows.NameScope.SetNameScope%2A> 以重置或清除 XAML 名称范围，但这不是常见的用法。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-166">You can call <xref:System.Windows.NameScope.SetNameScope%2A> more than once in order to reset or clear the XAML namescope, but that is not a common usage.</span></span> <span data-ttu-id="4e7b7-167">而且， <xref:System.Windows.NameScope.GetNameScope%2A> 通常不会从代码中使用。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-167">Also, <xref:System.Windows.NameScope.GetNameScope%2A> is not typically used from code.</span></span>  
  
### <a name="xaml-namescope-implementations"></a><span data-ttu-id="4e7b7-168">XAML 名称范围实现</span><span class="sxs-lookup"><span data-stu-id="4e7b7-168">XAML Namescope Implementations</span></span>  
 <span data-ttu-id="4e7b7-169">以下类直接实现 <xref:System.Windows.Markup.INameScope> ：</span><span class="sxs-lookup"><span data-stu-id="4e7b7-169">The following classes implement <xref:System.Windows.Markup.INameScope> directly:</span></span>  
  
- <xref:System.Windows.NameScope>  
  
- <xref:System.Windows.Style>  
  
- <xref:System.Windows.ResourceDictionary>  
  
- <xref:System.Windows.FrameworkTemplate>  
  
 <span data-ttu-id="4e7b7-170"><xref:System.Windows.ResourceDictionary> 不使用 XAML 名称或名称范围;它使用键，因为它是字典实现。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-170"><xref:System.Windows.ResourceDictionary> does not use XAML names or namescopes ; it uses keys instead, because it is a dictionary implementation.</span></span> <span data-ttu-id="4e7b7-171">实现的唯一原因 <xref:System.Windows.ResourceDictionary> <xref:System.Windows.Markup.INameScope> 是，它会向用户代码引发异常，以帮助阐明真正的 XAML 名称范围与如何处理键之间的区别 <xref:System.Windows.ResourceDictionary> ，还可以确保不会将 XAML 名称范围应用于 <xref:System.Windows.ResourceDictionary> 父元素。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-171">The only reason that <xref:System.Windows.ResourceDictionary> implements <xref:System.Windows.Markup.INameScope> is so it can raise exceptions to user code that help clarify the distinction between a true XAML namescope and how a <xref:System.Windows.ResourceDictionary> handles keys, and also to assure that XAML namescopes are not applied to a <xref:System.Windows.ResourceDictionary> by parent elements.</span></span>  
  
 <span data-ttu-id="4e7b7-172"><xref:System.Windows.FrameworkTemplate> 和 <xref:System.Windows.Style> <xref:System.Windows.Markup.INameScope> 通过显式接口定义实现。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-172"><xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> implement <xref:System.Windows.Markup.INameScope> through explicit interface definitions.</span></span> <span data-ttu-id="4e7b7-173">当通过接口访问 XAML 名称范围时，显式实现允许这些 XAML 名称范围正常运行 <xref:System.Windows.Markup.INameScope> ，这是内部进程如何传递 xaml 名称范围 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-173">The explicit implementations allow these XAML namescopes to behave conventionally when they are accessed through the <xref:System.Windows.Markup.INameScope> interface, which is how XAML namescopes are communicated by [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] internal processes.</span></span> <span data-ttu-id="4e7b7-174">但显式接口定义不是和的常规 API 图面的一部分， <xref:System.Windows.FrameworkTemplate> <xref:System.Windows.Style> 因为您很少需要直接调用和中的 <xref:System.Windows.Markup.INameScope> 方法 <xref:System.Windows.FrameworkTemplate> <xref:System.Windows.Style> ，而是使用其他 API （例如） <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> 。</span><span class="sxs-lookup"><span data-stu-id="4e7b7-174">But the explicit interface definitions are not part of the conventional API surface of <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style>, because you seldom need to call the <xref:System.Windows.Markup.INameScope> methods on <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> directly, and instead would use other API such as <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span></span>  
  
 <span data-ttu-id="4e7b7-175">以下类定义自己的 XAML 名称范围，方法是使用 <xref:System.Windows.NameScope?displayProperty=nameWithType> helper 类并通过附加属性连接到其 xaml 名称范围实现 <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> ：</span><span class="sxs-lookup"><span data-stu-id="4e7b7-175">The following classes define their own XAML namescope, by using the <xref:System.Windows.NameScope?displayProperty=nameWithType> helper class and connecting to its XAML namescope implementation through the <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> attached property:</span></span>  
  
- <xref:System.Windows.FrameworkElement>  
  
- <xref:System.Windows.FrameworkContentElement>  
  
## <a name="see-also"></a><span data-ttu-id="4e7b7-176">请参阅</span><span class="sxs-lookup"><span data-stu-id="4e7b7-176">See also</span></span>

- [<span data-ttu-id="4e7b7-177">WPF XAML 的 XAML 命名空间和命名空间映射</span><span class="sxs-lookup"><span data-stu-id="4e7b7-177">XAML Namespaces and Namespace Mapping for WPF XAML</span></span>](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)
- [<span data-ttu-id="4e7b7-178">x:Name 指令</span><span class="sxs-lookup"><span data-stu-id="4e7b7-178">x:Name Directive</span></span>](/dotnet/desktop-wpf/xaml-services/xname-directive)
