---
title: 将路由事件标记为“已处理”和“类处理”
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 26739463cdb3fe7d7f6926d7c5a7de5f8979fa87
ms.sourcegitcommit: 069786bcadbf9cd931d7dc3d892262cd852d2ffb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/19/2021
ms.locfileid: "104665596"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a><span data-ttu-id="9f47b-102">将路由事件标记为“已处理”和“类处理”</span><span class="sxs-lookup"><span data-stu-id="9f47b-102">Marking Routed Events as Handled, and Class Handling</span></span>
<span data-ttu-id="9f47b-103">路由事件的处理程序可以在事件数据内将事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="9f47b-103">Handlers for a routed event can mark the event handled within the event data.</span></span> <span data-ttu-id="9f47b-104">处理事件将有效地缩短路由。</span><span class="sxs-lookup"><span data-stu-id="9f47b-104">Handling the event will effectively shorten the route.</span></span> <span data-ttu-id="9f47b-105">类处理是一个编程概念，受路由事件支持。</span><span class="sxs-lookup"><span data-stu-id="9f47b-105">Class handling is a programming concept that is supported by routed events.</span></span> <span data-ttu-id="9f47b-106">类处理程序有机会在类级别使用处理程序处理特定路由事件，在类的任何实例上存在任何实例处理程序之前调用该处理程序。</span><span class="sxs-lookup"><span data-stu-id="9f47b-106">A class handler has the opportunity to handle a particular routed event at a class level with a handler that is invoked before any instance handler on any instance of the class.</span></span>  

<a name="prerequisites"></a>
## <a name="prerequisites"></a><span data-ttu-id="9f47b-107">必备条件</span><span class="sxs-lookup"><span data-stu-id="9f47b-107">Prerequisites</span></span>  
 <span data-ttu-id="9f47b-108">本主题将详细介绍[路由事件概述](routed-events-overview.md)中引入的概念。</span><span class="sxs-lookup"><span data-stu-id="9f47b-108">This topic elaborates on concepts introduced in the [Routed Events Overview](routed-events-overview.md).</span></span>  
  
<a name="When_to_Mark_Events_as_Handled"></a>
## <a name="when-to-mark-events-as-handled"></a><span data-ttu-id="9f47b-109">何时将事件标记为“已处理”</span><span class="sxs-lookup"><span data-stu-id="9f47b-109">When to Mark Events as Handled</span></span>  
 <span data-ttu-id="9f47b-110">在 <xref:System.Windows.RoutedEventArgs.Handled%2A> 路由事件的事件数据中将属性的值设置为时 `true` ，这称为 "将事件标记为已处理"。</span><span class="sxs-lookup"><span data-stu-id="9f47b-110">When you set the value of the <xref:System.Windows.RoutedEventArgs.Handled%2A> property to `true` in the event data for a routed event, this is referred to as "marking the event handled".</span></span> <span data-ttu-id="9f47b-111">对于应用程序创作者或者响应现有路由事件或实现新路由事件的控件创建者而言，何时应将路由事件标记为已处理，没有绝对规则。</span><span class="sxs-lookup"><span data-stu-id="9f47b-111">There is no absolute rule for when you should mark routed events as handled, either as an application author, or as a control author who responds to existing routed events or implements new routed events.</span></span> <span data-ttu-id="9f47b-112">大多数情况下，路由事件的事件数据中的 "已处理" 概念应作为有限的协议，用于自己的应用程序对 api 中公开的各种路由事件的响应，以及 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 适用于任何自定义路由事件。</span><span class="sxs-lookup"><span data-stu-id="9f47b-112">For the most part, the concept of "handled" as carried in the routed event's event data should be used as a limited protocol for your own application's responses to the various routed events exposed in [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] APIs as well as for any custom routed events.</span></span> <span data-ttu-id="9f47b-113">考虑“已处理”问题的另一种方式为：如果代码以重要且相对完整的方式响应路由事件，则通常应将路由事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="9f47b-113">Another way to consider the "handled" issue is that you should generally mark a routed event handled if your code responded to the routed event in a significant and relatively complete way.</span></span> <span data-ttu-id="9f47b-114">通常，重要响应不应该超过一个。所谓重要响应，是指对于单个任意路由事件，都需要单独的处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="9f47b-114">Typically, there should not be more than one significant response that requires separate handler implementations for any single routed event occurrence.</span></span> <span data-ttu-id="9f47b-115">如果需要多个响应，则应通过在单个处理程序内链接的应用程序逻辑实现必要的代码，而不是使用路由事件系统进行转发。</span><span class="sxs-lookup"><span data-stu-id="9f47b-115">If more responses are needed, then the necessary code should be implemented through application logic that is chained within a single handler rather than by using the routed event system for forwarding.</span></span> <span data-ttu-id="9f47b-116">是否“重要”这一概念比较主观，视应用程序或代码而定。</span><span class="sxs-lookup"><span data-stu-id="9f47b-116">The concept of what is "significant" is also subjective, and depends on your application or code.</span></span> <span data-ttu-id="9f47b-117">作为一般性指导原则，一些“重要响应”示例包括：设置焦点、修改公共状态、设置影响视觉表示形式的属性以及引发其他新事件。</span><span class="sxs-lookup"><span data-stu-id="9f47b-117">As general guidance, some "significant response" examples include: setting focus, modifying public state, setting properties that affect the visual representation, and raising other new events.</span></span> <span data-ttu-id="9f47b-118">非重要响应的示例包括：修改私有状态（无视觉影响，或编程表示形式）、记录事件或查看事件参数并选择不响应该事件。</span><span class="sxs-lookup"><span data-stu-id="9f47b-118">Examples of nonsignificant responses include: modifying private state (with no visual impact, or programmatic representation), logging of events, or looking at arguments of an event and choosing not to respond to it.</span></span>  
  
 <span data-ttu-id="9f47b-119">路由事件系统行为为使用路由事件的已处理状态强化此 "重要响应" 模型，因为在中添加的处理程序 [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] 或的公共签名 <xref:System.Windows.UIElement.AddHandler%2A> 不会被调用，而是为了响应事件数据已标记为已处理的路由事件。</span><span class="sxs-lookup"><span data-stu-id="9f47b-119">The routed event system behavior reinforces this "significant response" model for using handled state of a routed event, because handlers added in [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] or the common signature of <xref:System.Windows.UIElement.AddHandler%2A> are not invoked in response to a routed event where the event data is already marked handled.</span></span> <span data-ttu-id="9f47b-120">必须完成添加具有参数版本 () 的处理程序的额外操作， `handledEventsToo` <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 才能处理由事件路由中的早期参与者处理的路由事件。</span><span class="sxs-lookup"><span data-stu-id="9f47b-120">You must go through the extra effort of adding a handler with the `handledEventsToo` parameter version (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) in order to handle routed events that are marked handled by earlier participants in the event route.</span></span>  
  
 <span data-ttu-id="9f47b-121">在某些情况下，控件本身会将某些路由事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="9f47b-121">In some circumstances, controls themselves mark certain routed events as handled.</span></span> <span data-ttu-id="9f47b-122">已处理的路由事件表示 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 控件作者做出的以下决定：响应路由事件的控件操作是重要的，或者作为控件实现的一部分已完成，并且事件无需进一步处理。</span><span class="sxs-lookup"><span data-stu-id="9f47b-122">A handled routed event represents a decision by [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] control authors that the control's actions in response to the routed event are significant or complete as part of the control implementation, and the event needs no further handling.</span></span> <span data-ttu-id="9f47b-123">通常，通过为事件添加一个类处理程序，或重写存在于基类上的其中一个类处理程序虚方法，可以完成此操作。</span><span class="sxs-lookup"><span data-stu-id="9f47b-123">Usually this is done by adding a class handler for an event, or by overriding one of the class handler virtuals that exist on a base class.</span></span> <span data-ttu-id="9f47b-124">必要时仍然可以应对此事件处理；请参阅本主题后面部分的[通过控件解决事件禁止问题](#WorkingAroundEventSuppressionByControls)。</span><span class="sxs-lookup"><span data-stu-id="9f47b-124">You can still work around this event handling if necessary; see [Working Around Event Suppression by Controls](#WorkingAroundEventSuppressionByControls) later in this topic.</span></span>  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a><span data-ttu-id="9f47b-125">"预览" (隧道) 事件与冒泡事件和事件处理</span><span class="sxs-lookup"><span data-stu-id="9f47b-125">"Preview" (Tunneling) Events vs. Bubbling Events, and Event Handling</span></span>  
 <span data-ttu-id="9f47b-126">预览路由事件是指遵循元素树的隧道路由的事件。</span><span class="sxs-lookup"><span data-stu-id="9f47b-126">Preview routed events are events that follow a tunneling route through the element tree.</span></span> <span data-ttu-id="9f47b-127">命名约定中的“Preview”是指输入事件的一般原则，即预览（隧道）路由事件是在对等的冒泡路由事件之前引发的。</span><span class="sxs-lookup"><span data-stu-id="9f47b-127">The "Preview" expressed in the naming convention is indicative of the general principle for input events that preview (tunneling) routed events are raised prior to the equivalent bubbling routed event.</span></span> <span data-ttu-id="9f47b-128">另外，具有隧道和冒泡对的输入路由事件具有截然不同的处理逻辑。</span><span class="sxs-lookup"><span data-stu-id="9f47b-128">Also, input routed events that have a tunneling and bubbling pair have a distinct handling logic.</span></span> <span data-ttu-id="9f47b-129">如果隧道/预览路由事件标记为已由事件侦听器处理，则冒泡路由事件将标记为已处理，然而此时冒泡路由事件的任何侦听器尚未接收到该事件。</span><span class="sxs-lookup"><span data-stu-id="9f47b-129">If the tunneling/preview routed event is marked as handled by an event listener, then the bubbling routed event will be marked handled even before any listeners of the bubbling routed event receive it.</span></span> <span data-ttu-id="9f47b-130">隧道路由事件和冒泡路由事件在技术层面上是单独的事件，但是它们有意共享相同的事件数据实例以实现此行为。</span><span class="sxs-lookup"><span data-stu-id="9f47b-130">The tunneling and bubbling routed events are technically separate events, but they deliberately share the same instance of event data to enable this behavior.</span></span>  
  
 <span data-ttu-id="9f47b-131">任意给定的 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 类引发其声明的路由事件的方式的内部实现可在隧道路由事件与冒泡路由事件之间建立连接，对于成对的输入路由事件也是如此。</span><span class="sxs-lookup"><span data-stu-id="9f47b-131">The connection between the tunneling and bubbling routed events is accomplished by the internal implementation of how any given [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] class raises its own declared routed events, and this is true of the paired input routed events.</span></span> <span data-ttu-id="9f47b-132">但是除非该类级实现存在，否则共享命名方案的隧道路由事件与冒泡路由事件之间将没有连接：没有上述实现，它们将是两个完全独立的路由事件，不会顺次引发，也不会共享事件数据。</span><span class="sxs-lookup"><span data-stu-id="9f47b-132">But unless this class-level implementation exists, there is no connection between a tunneling routed event and a bubbling routed event that share the naming scheme: without such implementation they would be two entirely separate routed events and would not be raised in sequence or share event data.</span></span>  
  
 <span data-ttu-id="9f47b-133">有关如何在自定义类中实现隧道/冒泡输入路由事件对的详细信息，请参阅[创建自定义路由事件](how-to-create-a-custom-routed-event.md)。</span><span class="sxs-lookup"><span data-stu-id="9f47b-133">For more information about how to implement tunnel/bubble input routed event pairs in a custom class, see [Create a Custom Routed Event](how-to-create-a-custom-routed-event.md).</span></span>  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>
## <a name="class-handlers-and-instance-handlers"></a><span data-ttu-id="9f47b-134">类处理程序和实例处理程序</span><span class="sxs-lookup"><span data-stu-id="9f47b-134">Class Handlers and Instance Handlers</span></span>  
 <span data-ttu-id="9f47b-135">路由事件会考虑事件的两种不同类型的侦听器：类侦听器和实例侦听器。</span><span class="sxs-lookup"><span data-stu-id="9f47b-135">Routed events consider two different types of listeners to the event: class listeners and instance listeners.</span></span> <span data-ttu-id="9f47b-136">类侦听器存在是因为类型 <xref:System.Windows.EventManager> <xref:System.Windows.EventManager.RegisterClassHandler%2A> 在其静态构造函数中调用了特定 API，或已从元素基类重写类处理程序虚方法。</span><span class="sxs-lookup"><span data-stu-id="9f47b-136">Class listeners exist because types have called a particular <xref:System.Windows.EventManager> API ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, in their static constructor, or have overridden a class handler virtual method from an element base class.</span></span> <span data-ttu-id="9f47b-137">实例侦听器是特定的类实例/元素，其中已通过调用为该路由事件附加了一个或多个处理程序 <xref:System.Windows.UIElement.AddHandler%2A> 。</span><span class="sxs-lookup"><span data-stu-id="9f47b-137">Instance listeners are particular class instances/elements where one or more handlers have been attached for that routed event by a call to <xref:System.Windows.UIElement.AddHandler%2A>.</span></span> <span data-ttu-id="9f47b-138">现有 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 路由事件会将调用 <xref:System.Windows.UIElement.AddHandler%2A> 作为公共语言运行时的一部分 (CLR) 事件包装器添加 {} 和移除 {} 事件的实现，这也是 [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] 启用通过特性语法附加事件处理程序的简单机制。</span><span class="sxs-lookup"><span data-stu-id="9f47b-138">Existing [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] routed events make calls to <xref:System.Windows.UIElement.AddHandler%2A> as part of the common language runtime (CLR) event wrapper add{} and remove{} implementations of the event, which is also how the simple [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] mechanism of attaching event handlers via an attribute syntax is enabled.</span></span> <span data-ttu-id="9f47b-139">因此，即使简单 [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] 用法最终也等同于 <xref:System.Windows.UIElement.AddHandler%2A> 调用。</span><span class="sxs-lookup"><span data-stu-id="9f47b-139">Therefore even the simple [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] usage ultimately equates to an <xref:System.Windows.UIElement.AddHandler%2A> call.</span></span>  
  
 <span data-ttu-id="9f47b-140">将检查可视化树内的元素是否有注册的处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="9f47b-140">Elements within the visual tree are checked for registered handler implementations.</span></span> <span data-ttu-id="9f47b-141">可能会在整个路由中以该路由事件的路由策略类型所固有的顺序调用处理程序。</span><span class="sxs-lookup"><span data-stu-id="9f47b-141">Handlers are potentially invoked throughout the route, in the order that is inherent in the type of the routing strategy for that routed event.</span></span> <span data-ttu-id="9f47b-142">例如，冒泡路由事件将首先调用那些附加到引发该路由事件的同一元素的处理程序。</span><span class="sxs-lookup"><span data-stu-id="9f47b-142">For instance, bubbling routed events will first invoke those handlers that are attached to the same element that raised the routed event.</span></span> <span data-ttu-id="9f47b-143">然后，路由事件“冒泡”到下一父元素，以此类推，直到到达应用程序根元素。</span><span class="sxs-lookup"><span data-stu-id="9f47b-143">Then the routed event "bubbles" to the next parent element and so on until the application root element is reached.</span></span>  
  
 <span data-ttu-id="9f47b-144">从冒泡路由中的根元素的角度看，如果类处理或者更靠近路由事件源的任意元素调用那些将事件参数标记为正在处理的处理程序，那么就不会调用根元素上的处理程序，这样在到达该根元素之前的事件路由会大大缩短。</span><span class="sxs-lookup"><span data-stu-id="9f47b-144">From the perspective of the root element in a bubbling route, if class handling or any element closer to the source of the routed event invoke handlers that mark the event arguments as being handled, then handlers on the root elements are not invoked, and the event route is effectively shortened before reaching that root element.</span></span> <span data-ttu-id="9f47b-145">不过，路由并未完全停止，因为可以使用仍应调用处理程序的特殊条件来添加处理程序，即使类处理程序或实例处理程序已将路由事件标记为已处理也是如此。</span><span class="sxs-lookup"><span data-stu-id="9f47b-145">However, the route is not completely halted, because handlers can be added using a special conditional that they should still be invoked, even if a class handler or instance handler has marked the routed event as handled.</span></span> <span data-ttu-id="9f47b-146">本主题后面部分的[即使在事件标记为已处理时也要添加引发的实例处理程序](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled)对此进行了说明。</span><span class="sxs-lookup"><span data-stu-id="9f47b-146">This is explained in [Adding Instance Handlers That Are Raised Even When Events Are Marked Handled](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), later in this topic.</span></span>  
  
 <span data-ttu-id="9f47b-147">在比事件路由更深的级别上，还可能有多个类处理程序处理任意给定的类实例。</span><span class="sxs-lookup"><span data-stu-id="9f47b-147">At a deeper level than the event route, there are also potentially multiple class handlers acting on any given instance of a class.</span></span> <span data-ttu-id="9f47b-148">这是因为，路由事件的类处理模型使得类层次结构中的所有可能的类都可以针对每个路由事件注册自己的类处理程序。</span><span class="sxs-lookup"><span data-stu-id="9f47b-148">This is because the class handling model for routed events enables all possible classes in a class hierarchy to each register its own class handler for each routed event.</span></span> <span data-ttu-id="9f47b-149">每个类处理程序都会添加到一个内部存储，当构造应用程序的事件路由时，所有类处理程序都会添加到该事件路由中。</span><span class="sxs-lookup"><span data-stu-id="9f47b-149">Each class handler is added to an internal store, and when the event route for an application is constructed, the class handlers are all added to the event route.</span></span> <span data-ttu-id="9f47b-150">类处理程序按以下顺序添加到路由：最先调用派生程度最高的类处理程序，然后调用每个后续基类中的类处理程序。</span><span class="sxs-lookup"><span data-stu-id="9f47b-150">Class handlers are added to the route such that the most-derived class handler is invoked first, and class handlers from each successive base class are invoked next.</span></span> <span data-ttu-id="9f47b-151">通常，不会注册类处理程序以便它们也响应标记为已处理的路由事件。</span><span class="sxs-lookup"><span data-stu-id="9f47b-151">Generally, class handlers are not registered such that they also respond to routed events that were already marked handled.</span></span> <span data-ttu-id="9f47b-152">因此，此类处理机制可提供以下两个选项之一：</span><span class="sxs-lookup"><span data-stu-id="9f47b-152">Therefore, this class handling mechanism enables one of two choices:</span></span>  
  
- <span data-ttu-id="9f47b-153">派生类可以通过添加一个不将路由事件标记为已处理的处理程序，来补充从基类继承的类处理，因为有时会在派生类处理程序之后调用基类处理程序。</span><span class="sxs-lookup"><span data-stu-id="9f47b-153">Derived classes can supplement the class handling that is inherited from the base class by adding a handler that does not mark the routed event handled, because the base class handler will be invoked sometime after the derived class handler.</span></span>  
  
- <span data-ttu-id="9f47b-154">派生类可以通过添加一个将路由事件标记为已处理的类处理程序，来替换基类中的类处理。</span><span class="sxs-lookup"><span data-stu-id="9f47b-154">Derived classes can replace the class handling from the base class by adding a class handler that marks the routed event handled.</span></span> <span data-ttu-id="9f47b-155">应慎用此方法，因为它可能会更改视觉外观、状态逻辑、输入处理和命令处理等方面原本的基控件设计。</span><span class="sxs-lookup"><span data-stu-id="9f47b-155">You should be cautious with this approach, because it will potentially change the intended base control design in areas such as visual appearance, state logic, input handling, and command handling.</span></span>  
  
<a name="Class_Handling_of_Routed_Events"></a>
## <a name="class-handling-of-routed-events-by-control-base-classes"></a><span data-ttu-id="9f47b-156">按控件基类进行的路由事件类处理</span><span class="sxs-lookup"><span data-stu-id="9f47b-156">Class Handling of Routed Events by Control Base Classes</span></span>  
 <span data-ttu-id="9f47b-157">在事件路由中的每个给定元素节点上，类侦听器都有机会在元素的任意实例侦听器之前响应路由事件。</span><span class="sxs-lookup"><span data-stu-id="9f47b-157">On each given element node in an event route, class listeners have the opportunity to respond to the routed event before any instance listener on the element can.</span></span> <span data-ttu-id="9f47b-158">为此，类处理程序有时用于禁止某个特定控件类实现不希望继续传播的路由事件，或者用于提供类的一项功能，即对该路由事件进行特殊处理。</span><span class="sxs-lookup"><span data-stu-id="9f47b-158">For this reason, class handlers are sometimes used to suppress routed events that a particular control class implementation does not wish to propagate further, or to provide special handling of that routed event that is a feature of the class.</span></span> <span data-ttu-id="9f47b-159">例如，类可能引发特定于其自身的事件，其中包含有关某个用户输入条件在该特定类的上下文中所代表的意义的更多具体信息。</span><span class="sxs-lookup"><span data-stu-id="9f47b-159">For instance, a class might raise its own class-specific event that contains more specifics about what some user input condition means in the context of that particular class.</span></span> <span data-ttu-id="9f47b-160">然后，此类实现可能会将较为常规的路由事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="9f47b-160">The class implementation might then mark the more general routed event as handled.</span></span> <span data-ttu-id="9f47b-161">通常会添加类处理程序，以便不会为已标记为已处理的共享事件数据的路由事件调用它们，但对于异常情况，还会有一个 <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 签名用于注册类处理程序，甚至当路由事件被标记为已处理时也是如此。</span><span class="sxs-lookup"><span data-stu-id="9f47b-161">Class handlers are typically added such that they are not invoked for routed events where shared event data was already marked handled, but for atypical cases there is also a <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that registers class handlers to invoke even when routed events are marked handled.</span></span>  
  
### <a name="class-handler-virtuals"></a><span data-ttu-id="9f47b-162">类处理程序虚方法</span><span class="sxs-lookup"><span data-stu-id="9f47b-162">Class Handler Virtuals</span></span>  
 <span data-ttu-id="9f47b-163">某些元素（特别是基本元素，如 <xref:System.Windows.UIElement> ）公开空 "On \* 事件" 和 "OnPreview events \* " 虚拟方法，它们对应于其公共路由事件列表。</span><span class="sxs-lookup"><span data-stu-id="9f47b-163">Some elements, particularly the base elements such as <xref:System.Windows.UIElement>, expose empty "On\*Event" and "OnPreview\*Event" virtual methods that correspond to their list of public routed events.</span></span> <span data-ttu-id="9f47b-164">可以重写这些虚方法以便为该路由事件实现类处理程序。</span><span class="sxs-lookup"><span data-stu-id="9f47b-164">These virtual methods can be overridden to implement a class handler for that routed event.</span></span> <span data-ttu-id="9f47b-165">如前文所述，基元素类将这些虚方法注册为每个此类路由事件的类处理程序 <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 。</span><span class="sxs-lookup"><span data-stu-id="9f47b-165">The base element classes register these virtual methods as their class handler for each such routed event using <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> as described earlier.</span></span> <span data-ttu-id="9f47b-166">因为无需在静态构造函数中针对每个类型进行特殊初始化，所以 On\*Event 虚方法使得为相关路由事件实现类处理变得简单得多。</span><span class="sxs-lookup"><span data-stu-id="9f47b-166">The On\*Event virtual methods make it much simpler to implement class handling for the relevant routed events, without requiring special initialization in static constructors for each type.</span></span> <span data-ttu-id="9f47b-167">例如，可以 <xref:System.Windows.UIElement.DragEnter> <xref:System.Windows.UIElement> 通过重写虚拟方法为任何派生类中的事件添加类处理 <xref:System.Windows.UIElement.OnDragEnter%2A> 。</span><span class="sxs-lookup"><span data-stu-id="9f47b-167">For instance, you can add class handling for the <xref:System.Windows.UIElement.DragEnter> event in any <xref:System.Windows.UIElement> derived class by overriding the <xref:System.Windows.UIElement.OnDragEnter%2A> virtual method.</span></span> <span data-ttu-id="9f47b-168">在重写内，可以处理路由事件、引发其他事件、启动可能更改实例的元素属性的特定于类的逻辑或上述操作的任意组合。</span><span class="sxs-lookup"><span data-stu-id="9f47b-168">Within the override, you could handle the routed event, raise other events, initiate class-specific logic that might change element properties on instances, or any combination of those actions.</span></span> <span data-ttu-id="9f47b-169">通常情况下，在此类重写中，即使将事件标记为已处理，也应调用基实现。</span><span class="sxs-lookup"><span data-stu-id="9f47b-169">You should generally call the base implementation in such overrides even if you mark the event handled.</span></span> <span data-ttu-id="9f47b-170">强烈建议调用基实现，因为虚方法是在基类上。</span><span class="sxs-lookup"><span data-stu-id="9f47b-170">Calling the base implementation is strongly recommended because the virtual method is on the base class.</span></span> <span data-ttu-id="9f47b-171">从每个虚方法调用基实现的标准受保护虚拟模式实质上会替换和比较路由事件类处理所固有的类似机制，因此可以在任意给定实例上调用类层次结构中所有类的类处理程序，并从派生程度最高的类的处理程序开始，一直继续到基类处理程序。</span><span class="sxs-lookup"><span data-stu-id="9f47b-171">The standard protected virtual pattern of calling the base implementations from each virtual essentially replaces and parallels a similar mechanism that is native to routed event class handling, whereby class handlers for all classes in a class hierarchy are called on any given instance, starting with the most-derived class' handler and continuing to the base class handler.</span></span> <span data-ttu-id="9f47b-172">如果类明确要求更改基类处理逻辑，则应仅忽略基实现调用。</span><span class="sxs-lookup"><span data-stu-id="9f47b-172">You should only omit the base implementation call if your class has a deliberate requirement to change the base class handling logic.</span></span> <span data-ttu-id="9f47b-173">在重写代码之前还是之后调用基实现取决于实现的性质。</span><span class="sxs-lookup"><span data-stu-id="9f47b-173">Whether you call the base implementation before or after your overriding code will depend on the nature of your implementation.</span></span>  
  
#### <a name="input-event-class-handling"></a><span data-ttu-id="9f47b-174">输入事件类处理</span><span class="sxs-lookup"><span data-stu-id="9f47b-174">Input Event Class Handling</span></span>  
 <span data-ttu-id="9f47b-175">类处理程序虚方法均已注册，只有当存在任何共享事件数据尚未标记为已处理的情况时才调用这些方法。</span><span class="sxs-lookup"><span data-stu-id="9f47b-175">The class handler virtual methods are all registered such that they are only invoked in cases where any shared event data are not already marked handled.</span></span> <span data-ttu-id="9f47b-176">另外，仅仅对于输入事件而言，隧道和冒泡版本通常是顺次引发的，并且共享事件数据。</span><span class="sxs-lookup"><span data-stu-id="9f47b-176">Also, for the input events uniquely, the tunneling and bubbling versions typically are raised in sequence and share event data.</span></span> <span data-ttu-id="9f47b-177">对于一对给定的输入事件的类处理程序（其中一个是隧道版本，另一个是冒泡版本），当你可能不希望立即将事件标记为已处理时也需要此项。</span><span class="sxs-lookup"><span data-stu-id="9f47b-177">This entails that for a given pair of class handlers of input events where one is the tunneling version and the other is the bubbling version, you may not want to mark the event handled immediately.</span></span> <span data-ttu-id="9f47b-178">如果实现隧道类处理虚方法以便将事件标记为已处理，这将会阻止调用冒泡类处理程序（并阻止调用隧道或冒泡事件的任意正常注册的实例处理程序）。</span><span class="sxs-lookup"><span data-stu-id="9f47b-178">If you implement the tunneling class handling virtual method to mark the event handled, that will prevent the bubbling class handler from being invoked (as well as preventing any normally registered instance handlers for either the tunneling or bubbling event from being invoked).</span></span>  
  
 <span data-ttu-id="9f47b-179">节点上的类处理一经完成，就会考虑实例侦听器。</span><span class="sxs-lookup"><span data-stu-id="9f47b-179">Once class handling on a node is complete, the instance listeners are considered.</span></span>  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a><span data-ttu-id="9f47b-180">即使在事件标记为已处理时也要添加引发的实例处理程序</span><span class="sxs-lookup"><span data-stu-id="9f47b-180">Adding Instance Handlers That Are Raised Even When Events Are Marked Handled</span></span>  
 <span data-ttu-id="9f47b-181"><xref:System.Windows.UIElement.AddHandler%2A>方法提供了一个特定的重载，该重载使你能够添加在事件到达路由中的处理元素时事件系统将调用的处理程序，即使其他某个处理程序已经调整了事件数据以将该事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="9f47b-181">The <xref:System.Windows.UIElement.AddHandler%2A> method supplies a particular overload that allows you to add handlers that will be invoked by the event system whenever an event reaches the handling element in the route, even if some other handler has already adjusted the event data to mark that event as handled.</span></span> <span data-ttu-id="9f47b-182">但一般不这样操作。</span><span class="sxs-lookup"><span data-stu-id="9f47b-182">This is not typically done.</span></span> <span data-ttu-id="9f47b-183">通常情况下，不论事件是在元素树中的什么位置处理，即使需要多个最终结果，都可以通过编写处理程序来调整可能受事件影响的应用程序代码的各个方面。</span><span class="sxs-lookup"><span data-stu-id="9f47b-183">Generally, handlers can be written to adjust all areas of application code that might be influenced by an event, regardless of where it was handled in an element tree, even if multiple end results are desired.</span></span> <span data-ttu-id="9f47b-184">另外，通常情况下，需要响应该事件的实际只有一个元素，并且已发生了适当的应用程序逻辑。</span><span class="sxs-lookup"><span data-stu-id="9f47b-184">Also, typically there is really only one element that needs to respond to that event, and the appropriate application logic had already happened.</span></span> <span data-ttu-id="9f47b-185">但是 `handledEventsToo` 重载适用于某些例外情况，例如元素数或控件复合中的某些其他元素已将事件标记为已处理，但是元素数中较高或较低的其他元素（视路由而定）仍希望调用自己的处理程序。</span><span class="sxs-lookup"><span data-stu-id="9f47b-185">But the `handledEventsToo` overload is available for the exceptional cases where some other element in an element tree or control compositing has already marked an event as handled, but other elements either higher or lower in the element tree (depending on route) still wish to have their own handlers invoked.</span></span>  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a><span data-ttu-id="9f47b-186">何时将已处理事件标记为未处理</span><span class="sxs-lookup"><span data-stu-id="9f47b-186">When to Mark Handled Events as Unhandled</span></span>  
 <span data-ttu-id="9f47b-187">通常情况下，标记为已处理的路由事件不应标记为未处理 (<xref:System.Windows.RoutedEventArgs.Handled%2A> 设置回 `false`) ，即使是操作的处理程序 `handledEventsToo` 。</span><span class="sxs-lookup"><span data-stu-id="9f47b-187">Generally, routed events that are marked handled should not be marked unhandled (<xref:System.Windows.RoutedEventArgs.Handled%2A> set back to `false`) even by handlers that act on `handledEventsToo`.</span></span> <span data-ttu-id="9f47b-188">不过，某些输入事件具有高级别和低级别两种事件表示形式，当在树中的一个位置看到高级别事件，在另一个位置看到低级别事件时，这两种表示形式可以重叠。</span><span class="sxs-lookup"><span data-stu-id="9f47b-188">However, some input events have high-level and lower-level event representations that can overlap when the high-level event is seen at one position in the tree and the low-level event at another position.</span></span> <span data-ttu-id="9f47b-189">例如，假设 <xref:System.Windows.UIElement.TextInput> 当父元素侦听低级别事件（例如）时，子元素会侦听高级键事件 <xref:System.Windows.UIElement.KeyDown> 。</span><span class="sxs-lookup"><span data-stu-id="9f47b-189">For instance, consider the case where a child element listens to a high-level key event such as <xref:System.Windows.UIElement.TextInput> while a parent element listens to a low-level event such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="9f47b-190">如果父元素处理低级别事件，则高级别事件甚至可能在子元素中被禁止，尽管直观看来子元素应该具有处理事件的先机。</span><span class="sxs-lookup"><span data-stu-id="9f47b-190">If the parent element handles the low-level event, the higher-level event can be suppressed even in the child element that intuitively should have first opportunity to handle the event.</span></span>  
  
 <span data-ttu-id="9f47b-191">在上述情形下，可能需要针对低级别事件向父元素和子元素中添加处理程序。</span><span class="sxs-lookup"><span data-stu-id="9f47b-191">In these situations it may be necessary to add handlers to both parent elements and child elements for the low-level event.</span></span> <span data-ttu-id="9f47b-192">子元素处理程序实现可以将低级别事件标记为已处理，但父元素处理程序实现会再次将其设置为未处理，这样树上方的更多元素（以及高级别事件）就可以有机会响应。</span><span class="sxs-lookup"><span data-stu-id="9f47b-192">The child element handler implementation can mark the low-level event as handled, but the parent element handler implementation would set it unhandled again so that further elements up the tree (as well as the high-level event) can have the opportunity to respond.</span></span> <span data-ttu-id="9f47b-193">这种情形应该非常少见。</span><span class="sxs-lookup"><span data-stu-id="9f47b-193">This situation is should be fairly rare.</span></span>  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a><span data-ttu-id="9f47b-194">有意对控件复合禁止输入事件</span><span class="sxs-lookup"><span data-stu-id="9f47b-194">Deliberately Suppressing Input Events for Control Compositing</span></span>  
 <span data-ttu-id="9f47b-195">路由事件的类处理主要是用于输入事件和复合控件。</span><span class="sxs-lookup"><span data-stu-id="9f47b-195">The main scenario where class handling of routed events is used is for input events and composited controls.</span></span> <span data-ttu-id="9f47b-196">按照定义，复合控件是由多个实际控件或控件基类组成的。</span><span class="sxs-lookup"><span data-stu-id="9f47b-196">A composited control is by definition composed of multiple practical controls or control base classes.</span></span> <span data-ttu-id="9f47b-197">控件作者通常希望合并每个子组件可能引发的所有可能的输入事件，以便将整个控件报告为单事件源。</span><span class="sxs-lookup"><span data-stu-id="9f47b-197">Often the author of the control wishes to amalgamate all of the possible input events that each of the subcomponents might raise, in order to report the entire control as the singular event source.</span></span> <span data-ttu-id="9f47b-198">某些情况下，控件作者可能希望完全禁止来自组件的事件，或者替换上携带更多信息或者指示更具体行为的组件定义的事件。</span><span class="sxs-lookup"><span data-stu-id="9f47b-198">In some cases the control author might wish to suppress the events from components entirely, or substitute a component-defined event that carries more information or implies a more specific behavior.</span></span> <span data-ttu-id="9f47b-199">对任何组件作者立即可见的规范示例是如何 [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> 处理任何鼠标事件，这些事件最终将解析为所有按钮都具有的直观事件： <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 事件。</span><span class="sxs-lookup"><span data-stu-id="9f47b-199">The canonical example that is immediately visible to any component author is how a [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> handles any mouse event that will eventually resolve to the intuitive event that all buttons have: a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 <span data-ttu-id="9f47b-200"><xref:System.Windows.Controls.Button>基类 (<xref:System.Windows.Controls.Primitives.ButtonBase>) 派生，而 <xref:System.Windows.Controls.Control> 后者又从和派生 <xref:System.Windows.FrameworkElement> <xref:System.Windows.UIElement> ，而控件输入处理所需的大部分事件基础结构在 <xref:System.Windows.UIElement> 级别可用。</span><span class="sxs-lookup"><span data-stu-id="9f47b-200">The <xref:System.Windows.Controls.Button> base class (<xref:System.Windows.Controls.Primitives.ButtonBase>) derives from <xref:System.Windows.Controls.Control> which in turn derives from <xref:System.Windows.FrameworkElement> and <xref:System.Windows.UIElement>, and much of the event infrastructure needed for control input processing is available at the <xref:System.Windows.UIElement> level.</span></span> <span data-ttu-id="9f47b-201">具体而言， <xref:System.Windows.UIElement> 处理一般 <xref:System.Windows.Input.Mouse> 事件，这些事件在其边界内处理鼠标光标的命中测试，并为最常见的按钮操作（例如）提供不同的事件 <xref:System.Windows.UIElement.MouseLeftButtonDown> 。</span><span class="sxs-lookup"><span data-stu-id="9f47b-201">In particular, <xref:System.Windows.UIElement> processes general <xref:System.Windows.Input.Mouse> events that handle hit testing for the mouse cursor within its bounds, and provides distinct events for the most common button actions, such as <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="9f47b-202"><xref:System.Windows.UIElement> 还提供一个空虚拟 <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> 为的预先注册类处理程序 <xref:System.Windows.UIElement.MouseLeftButtonDown> ，并对 <xref:System.Windows.Controls.Primitives.ButtonBase> 其进行重写。</span><span class="sxs-lookup"><span data-stu-id="9f47b-202"><xref:System.Windows.UIElement> also provides an empty virtual <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> as the preregistered class handler for <xref:System.Windows.UIElement.MouseLeftButtonDown>, and <xref:System.Windows.Controls.Primitives.ButtonBase> overrides it.</span></span> <span data-ttu-id="9f47b-203">同样， <xref:System.Windows.Controls.Primitives.ButtonBase> 使用的类处理程序 <xref:System.Windows.UIElement.MouseLeftButtonUp> 。</span><span class="sxs-lookup"><span data-stu-id="9f47b-203">Similarly, <xref:System.Windows.Controls.Primitives.ButtonBase> uses class handlers for <xref:System.Windows.UIElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="9f47b-204">在传递事件数据的重写中，实现 <xref:System.Windows.RoutedEventArgs> 通过将设置为来将该实例标记为已处理 <xref:System.Windows.RoutedEventArgs.Handled%2A> `true` ，并且相同的事件数据与其他类处理程序的路由的其余部分（也是实例处理程序或事件资源库）继续。</span><span class="sxs-lookup"><span data-stu-id="9f47b-204">In the overrides, which are passed the event data, the implementations mark that <xref:System.Windows.RoutedEventArgs> instance as handled by setting <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`, and that same event data is what continues along the remainder of the route to other class handlers and also to instance handlers or event setters.</span></span> <span data-ttu-id="9f47b-205">此外， <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> 下一次重写会引发 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 事件。</span><span class="sxs-lookup"><span data-stu-id="9f47b-205">Also, the <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> override will next raise the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="9f47b-206">大多数侦听器的最终结果将是 <xref:System.Windows.UIElement.MouseLeftButtonDown> 和 <xref:System.Windows.UIElement.MouseLeftButtonUp> 事件 "消失"，而是替换为 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> ，因为已知此事件源自真正的按钮，而不是某个按钮的某个组合部分或从其他某个元素开始，则该事件具有更多含义。</span><span class="sxs-lookup"><span data-stu-id="9f47b-206">The end result for most listeners will be that the <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseLeftButtonUp> events "disappear" and are replaced instead by <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, an event that holds more meaning because it is known that this event originated from a true button and not some composite piece of the button or from some other element entirely.</span></span>  
  
<a name="WorkingAroundEventSuppressionByControls"></a>
### <a name="working-around-event-suppression-by-controls"></a><span data-ttu-id="9f47b-207">通过控件解决事件禁止问题</span><span class="sxs-lookup"><span data-stu-id="9f47b-207">Working Around Event Suppression by Controls</span></span>  
 <span data-ttu-id="9f47b-208">有时，各个控件内的此事件禁止行为可能会干扰应用程序的事件处理逻辑的某些较为常规的意图。</span><span class="sxs-lookup"><span data-stu-id="9f47b-208">Sometimes this event suppression behavior within individual controls can interfere with some more general intentions of event handling logic for your application.</span></span> <span data-ttu-id="9f47b-209">例如，如果由于某种原因您的应用程序具有 <xref:System.Windows.UIElement.MouseLeftButtonDown> 位于应用程序根元素的处理程序，则您会注意到，任何鼠标单击按钮都不会 <xref:System.Windows.UIElement.MouseLeftButtonDown> <xref:System.Windows.UIElement.MouseLeftButtonUp> 在根级别调用或处理程序。</span><span class="sxs-lookup"><span data-stu-id="9f47b-209">For instance, if for some reason your application had a handler for <xref:System.Windows.UIElement.MouseLeftButtonDown> located at the application root element, you would notice that any mouse click on a button would not invoke <xref:System.Windows.UIElement.MouseLeftButtonDown> or <xref:System.Windows.UIElement.MouseLeftButtonUp> handlers at the root level.</span></span> <span data-ttu-id="9f47b-210">事件本身实际上会向上冒泡（同样，事件路由未真正结束，但路由事件系统会在事件标记为已处理后更改其处理程序调用行为）。</span><span class="sxs-lookup"><span data-stu-id="9f47b-210">The event itself actually did bubble up (again, event routes are not truly ended, but the routed event system changes their handler invocation behavior after being marked handled).</span></span> <span data-ttu-id="9f47b-211">当路由事件到达按钮时， <xref:System.Windows.Controls.Primitives.ButtonBase> 类处理会将其标记为已 <xref:System.Windows.UIElement.MouseLeftButtonDown> 处理，因为它希望用 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 更多含义替换事件。</span><span class="sxs-lookup"><span data-stu-id="9f47b-211">When the routed event reached the button, the <xref:System.Windows.Controls.Primitives.ButtonBase> class handling marked the <xref:System.Windows.UIElement.MouseLeftButtonDown> handled because it wished to substitute the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event with more meaning.</span></span> <span data-ttu-id="9f47b-212">因此， <xref:System.Windows.UIElement.MouseLeftButtonDown> 不会调用在路由上进一步的任何标准处理程序。</span><span class="sxs-lookup"><span data-stu-id="9f47b-212">Therefore, any standard <xref:System.Windows.UIElement.MouseLeftButtonDown> handler further up the route would not be invoked.</span></span> <span data-ttu-id="9f47b-213">可以使用两种方法来确保在此情形下会调用处理程序。</span><span class="sxs-lookup"><span data-stu-id="9f47b-213">There are two techniques you can use to ensure that your handlers would be invoked in this circumstance.</span></span>  
  
 <span data-ttu-id="9f47b-214">第一种方法是使用的签名有意添加处理程序 `handledEventsToo` <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 。</span><span class="sxs-lookup"><span data-stu-id="9f47b-214">The first technique is to deliberately add the handler using the `handledEventsToo` signature of <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span></span> <span data-ttu-id="9f47b-215">这种方法的局限性在于用于附加事件处理程序的这种技术只可能来自代码，而不能来自标记。</span><span class="sxs-lookup"><span data-stu-id="9f47b-215">A limitation of this approach is that this technique for attaching an event handler is only possible from code, not from markup.</span></span> <span data-ttu-id="9f47b-216">通过 [!INCLUDE[TLA#tla_xaml](../../../includes/tlasharptla-xaml-md.md)] 将事件处理程序名称指定为事件特性值的简单语法不能实现此行为。</span><span class="sxs-lookup"><span data-stu-id="9f47b-216">The simple syntax of specifying the event handler name as an event attribute value via [!INCLUDE[TLA#tla_xaml](../../../includes/tlasharptla-xaml-md.md)] does not enable that behavior.</span></span>  
  
 <span data-ttu-id="9f47b-217">第二种技术仅适用于输入事件，其中路由事件的隧道版本和冒泡版本是配对的。</span><span class="sxs-lookup"><span data-stu-id="9f47b-217">The second technique works only for input events, where the tunneling and bubbling versions of the routed event are paired.</span></span> <span data-ttu-id="9f47b-218">对于这些路由事件，可以改为将处理程序添加到预览/隧道对等路由事件。</span><span class="sxs-lookup"><span data-stu-id="9f47b-218">For these routed events, you can add handlers to the preview/tunneling equivalent routed event instead.</span></span> <span data-ttu-id="9f47b-219">假如在应用程序的元素树中的某个上级元素级别附加了 Preview 处理程序，该路由事件将从根开始在路由中传递，所以按钮类处理代码不会截获到该事件。</span><span class="sxs-lookup"><span data-stu-id="9f47b-219">That routed event will tunnel through the route starting from the root, so the button class handling code would not intercept it, presuming that you attached the Preview handler at some ancestor element level in the application's element tree.</span></span> <span data-ttu-id="9f47b-220">如果使用此方法，则将任意 Preview 事件标记为已处理时一定要谨慎。</span><span class="sxs-lookup"><span data-stu-id="9f47b-220">If you use this approach, be cautious about marking any Preview event handled.</span></span> <span data-ttu-id="9f47b-221">对于以根元素处理的给定的示例 <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> ，如果在处理程序实现中将事件标记为， <xref:System.Windows.RoutedEventArgs.Handled%2A> 则实际上会禁止显示该 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 事件。</span><span class="sxs-lookup"><span data-stu-id="9f47b-221">For the example given with <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> being handled at the root element, if you marked the event as <xref:System.Windows.RoutedEventArgs.Handled%2A> in the handler implementation, you would actually suppress the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="9f47b-222">这通常不是希望的行为。</span><span class="sxs-lookup"><span data-stu-id="9f47b-222">That is typically not desirable behavior.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9f47b-223">请参阅</span><span class="sxs-lookup"><span data-stu-id="9f47b-223">See also</span></span>

- <xref:System.Windows.EventManager>
- [<span data-ttu-id="9f47b-224">预览事件</span><span class="sxs-lookup"><span data-stu-id="9f47b-224">Preview Events</span></span>](preview-events.md)
- [<span data-ttu-id="9f47b-225">创建自定义路由事件</span><span class="sxs-lookup"><span data-stu-id="9f47b-225">Create a Custom Routed Event</span></span>](how-to-create-a-custom-routed-event.md)
- [<span data-ttu-id="9f47b-226">路由事件概述</span><span class="sxs-lookup"><span data-stu-id="9f47b-226">Routed Events Overview</span></span>](routed-events-overview.md)
