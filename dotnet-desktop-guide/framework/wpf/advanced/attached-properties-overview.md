---
title: 附加属性概述
description: 了解 Windows Presentation Foundation 中的附加属性，这些属性是可在任何对象上设置的全局属性。
ms.date: 03/30/2017
ms.topic: overview
dev_langs:
- csharp
- vb
helpviewer_keywords:
- attached properties [WPF Designer]
ms.assetid: 75928354-dc01-47e8-a018-8409aec1f32d
ms.openlocfilehash: f8c6b2c7cca2fb12180bea4e803194f92f72b94f
ms.sourcegitcommit: bf5dd80f4d7b202afa90e90d1148402c5474d826
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/30/2021
ms.locfileid: "96971976"
---
# <a name="attached-properties-overview"></a><span data-ttu-id="dc3a5-103">附加属性概述</span><span class="sxs-lookup"><span data-stu-id="dc3a5-103">Attached Properties Overview</span></span>

<span data-ttu-id="dc3a5-104">附加属性是由 XAML 定义的概念。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-104">An attached property is a concept defined by XAML.</span></span> <span data-ttu-id="dc3a5-105">附加属性旨在用作可在任何对象上设置的一类全局属性。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-105">An attached property is intended to be used as a type of global property that is settable on any object.</span></span> <span data-ttu-id="dc3a5-106">在 [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] 中，附加属性通常定义为没有常规属性“包装器”的依赖性属性的专用形式。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-106">In [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)], attached properties are typically defined as a specialized form of dependency property that does not have the conventional property "wrapper".</span></span>

## <a name="prerequisites"></a><span data-ttu-id="dc3a5-107">先决条件 <a name="prerequisites"></a></span><span class="sxs-lookup"><span data-stu-id="dc3a5-107">Prerequisites <a name="prerequisites"></a></span></span>

<span data-ttu-id="dc3a5-108">本文假设你从类的现有依赖属性的使用者角度了解依赖属性 [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] ，并且已阅读 [依赖属性概述](dependency-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-108">This article assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md).</span></span> <span data-ttu-id="dc3a5-109">若要遵循本文中的示例，还应了解 XAML 并了解如何编写 WPF 应用程序。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-109">To follow the examples in this article, you should also understand XAML and know how to write WPF applications.</span></span>

## <a name="why-use-attached-properties"></a><span data-ttu-id="dc3a5-110">为什么使用附加属性 <a name="attached_properties_usage"></a></span><span class="sxs-lookup"><span data-stu-id="dc3a5-110">Why Use Attached Properties <a name="attached_properties_usage"></a></span></span>

<span data-ttu-id="dc3a5-111">附加属性的一个用途是允许不同的子元素为父元素中定义的属性指定唯一的值。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-111">One purpose of an attached property is to allow different child elements to specify unique values for a property that's defined in a parent element.</span></span> <span data-ttu-id="dc3a5-112">此方案的一个具体应用是，让子元素通知父元素它们在 [!INCLUDE[TLA#tla_ui](../../../includes/tlasharptla-ui-md.md)] 中的呈现方式。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-112">A specific application of this scenario is having child elements inform the parent element of how they are to be presented in the [!INCLUDE[TLA#tla_ui](../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="dc3a5-113">一个示例是 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-113">One example is the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="dc3a5-114">该 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 属性是作为附加属性创建的，因为它设计为在中包含的元素上设置，而不是在自身中包含的元素上设置 <xref:System.Windows.Controls.DockPanel> <xref:System.Windows.Controls.DockPanel> 。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-114">The <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property is created as an attached property because it is designed to be set on elements that are contained within a <xref:System.Windows.Controls.DockPanel> rather than on <xref:System.Windows.Controls.DockPanel> itself.</span></span> <span data-ttu-id="dc3a5-115"><xref:System.Windows.Controls.DockPanel>类定义 <xref:System.Windows.DependencyProperty> 名为的静态字段 <xref:System.Windows.Controls.DockPanel.DockProperty> ，然后提供 <xref:System.Windows.Controls.DockPanel.GetDock%2A> 和 <xref:System.Windows.Controls.DockPanel.SetDock%2A> 方法作为附加属性的公共访问器。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-115">The <xref:System.Windows.Controls.DockPanel> class defines the static <xref:System.Windows.DependencyProperty> field named <xref:System.Windows.Controls.DockPanel.DockProperty>, and then provides the <xref:System.Windows.Controls.DockPanel.GetDock%2A> and <xref:System.Windows.Controls.DockPanel.SetDock%2A> methods as public accessors for the attached property.</span></span>

## <a name="attached-properties-in-xaml"></a><span data-ttu-id="dc3a5-116">XAML 中的附加属性 <a name="attached_properties_xaml"></a></span><span class="sxs-lookup"><span data-stu-id="dc3a5-116">Attached Properties in XAML <a name="attached_properties_xaml"></a></span></span>

<span data-ttu-id="dc3a5-117">在 XAML 中，可以使用语法 AttachedPropertyProvider.PropertyName 来设置附加属性</span><span class="sxs-lookup"><span data-stu-id="dc3a5-117">In XAML, you set attached properties by using the syntax *AttachedPropertyProvider*.*PropertyName*</span></span>

<span data-ttu-id="dc3a5-118">下面是如何 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 在 XAML 中设置的示例：</span><span class="sxs-lookup"><span data-stu-id="dc3a5-118">The following is an example of how you can set <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> in XAML:</span></span>

[!code-xaml[PropertiesOvwSupport#APBasicUsage](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#apbasicusage)]

<span data-ttu-id="dc3a5-119">用法在某种程度上类似于静态属性;始终引用 <xref:System.Windows.Controls.DockPanel> 拥有和注册附加属性的类型，而不是引用任何由 name 指定的实例。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-119">The usage is somewhat similar to a static property; you always reference the type <xref:System.Windows.Controls.DockPanel> that owns and registers the attached property, rather than referring to any instance specified by name.</span></span>

<span data-ttu-id="dc3a5-120">此外，由于 XAML 中的附加属性是在标记中设置的属性，因此，只有设置操作具有相关性。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-120">Also, because an attached property in XAML is an attribute that you set in markup, only the set operation has any relevance.</span></span> <span data-ttu-id="dc3a5-121">尽管存在一些用于比较值的间接机制（如在样式中触发），但无法直接在 XAML 中直接获取属性（有关详细信息，请参阅[样式设置和模板化](/dotnet/desktop-wpf/fundamentals/styles-templates-overview)）。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-121">You cannot directly get a property in XAML, although there are some indirect mechanisms for comparing values, such as triggers in styles (for details, see [Styling and Templating](/dotnet/desktop-wpf/fundamentals/styles-templates-overview)).</span></span>

### <a name="attached-property-implementation-in-wpf"></a><span data-ttu-id="dc3a5-122">WPF 中的附加属性实现</span><span class="sxs-lookup"><span data-stu-id="dc3a5-122">Attached Property Implementation in WPF</span></span>

<span data-ttu-id="dc3a5-123">在中 [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] ，WPF 类型上大多数与 UI 相关的附加属性都作为依赖属性实现。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-123">In [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)], most of the UI-related attached properties on WPF types are implemented as dependency properties.</span></span> <span data-ttu-id="dc3a5-124">附加属性是 XAML 概念，而依赖属性是 WPF 概念。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-124">Attached properties are a XAML concept, whereas dependency properties are a WPF concept.</span></span> <span data-ttu-id="dc3a5-125">因为 WPF 附加属性是依赖属性，所以它们支持依赖属性概念（如属性元数据）和来自该属性元数据的默认值。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-125">Because WPF attached properties are dependency properties, they support dependency property concepts such as property metadata, and default values from that property metadata.</span></span>

## <a name="how-attached-properties-are-used-by-the-owning-type"></a><span data-ttu-id="dc3a5-126">所属类型使用附加属性的方式 <a name="howused"></a></span><span class="sxs-lookup"><span data-stu-id="dc3a5-126">How Attached Properties Are Used by the Owning Type <a name="howused"></a></span></span>

<span data-ttu-id="dc3a5-127">尽管可以在任何对象上设置附加属性，但这并不自动意味着设置该属性会产生实际的结果，或者该值会被其他对象使用。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-127">Although attached properties are settable on any object, that does not automatically mean that setting the property will produce a tangible result, or that the value will ever be used by another object.</span></span> <span data-ttu-id="dc3a5-128">通常，附加属性是为了使来自各种可能的类层次结构或逻辑关系的对象都可以向用于定义附加属性的类型报告公用信息。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-128">Generally, attached properties are intended so that objects coming from a wide variety of possible class hierarchies or logical relationships can each report common information to the type that defines the attached property.</span></span> <span data-ttu-id="dc3a5-129">定义附加属性的类型通常采用以下模型之一：</span><span class="sxs-lookup"><span data-stu-id="dc3a5-129">The type that defines the attached property typically follows one of these models:</span></span>

- <span data-ttu-id="dc3a5-130">设计定义附加属性的类型，以便它可以是将为附加属性设置值的元素的父元素。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-130">The type that defines the attached property is designed so that it can be the parent element of the elements that will set values for the attached property.</span></span> <span data-ttu-id="dc3a5-131">随后，该类型将在内部逻辑中对照某些对象树结构循环访问其子对象，获取值，并以某种方式作用于这些值。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-131">The type then iterates its child objects through internal logic against some object tree structure, obtains the values, and acts on those values in some manner.</span></span>

- <span data-ttu-id="dc3a5-132">定义附加属性的类型将用作各种可能的父元素和内容模型的子元素。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-132">The type that defines the attached property will be used as the child element for a variety of possible parent elements and content models.</span></span>

- <span data-ttu-id="dc3a5-133">定义附加属性的类型表示一项服务。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-133">The type that defines the attached property represents a service.</span></span> <span data-ttu-id="dc3a5-134">其他类型为该附加属性设置值。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-134">Other types set values for the attached property.</span></span> <span data-ttu-id="dc3a5-135">然后，当在服务的上下文中计算设置该属性的元素时，将通过服务类的内部逻辑获取附加属性的值。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-135">Then, when the element that set the property is evaluated in the context of the service, the attached property values are obtained through internal logic of the service class.</span></span>

### <a name="an-example-of-a-parent-defined-attached-property"></a><span data-ttu-id="dc3a5-136">父级定义的附加属性示例</span><span class="sxs-lookup"><span data-stu-id="dc3a5-136">An Example of a Parent-Defined Attached Property</span></span>

<span data-ttu-id="dc3a5-137">WPF 定义附加属性的最典型方案是：当父元素支持子元素集合时，还实现了一种行为，其中为每个子元素单独报告了行为的细节。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-137">The most typical scenario where WPF defines an attached property is when a parent element supports a child element collection, and also implements a behavior where the specifics of the behavior are reported individually for each child element.</span></span>

<span data-ttu-id="dc3a5-138"><xref:System.Windows.Controls.DockPanel> 定义 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 附加属性，并将 <xref:System.Windows.Controls.DockPanel> 类级代码作为其呈现逻辑的一部分 (具体说来， <xref:System.Windows.Controls.DockPanel.MeasureOverride%2A> 并 <xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>) 。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-138"><xref:System.Windows.Controls.DockPanel> defines the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property, and <xref:System.Windows.Controls.DockPanel> has class-level code as part of its rendering logic (specifically, <xref:System.Windows.Controls.DockPanel.MeasureOverride%2A> and <xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>).</span></span> <span data-ttu-id="dc3a5-139"><xref:System.Windows.Controls.DockPanel>实例将始终检查其任意直接子元素是否已设置的值 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-139">A <xref:System.Windows.Controls.DockPanel> instance will always check to see whether any of its immediate child elements have set a value for <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="dc3a5-140">如果已设置，这些值将变为应用于该特定子元素的呈现逻辑的输入。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-140">If so, those values become input for the rendering logic applied to that particular child element.</span></span> <span data-ttu-id="dc3a5-141">嵌套 <xref:System.Windows.Controls.DockPanel> 实例分别处理它们自己的直接子元素集合，但该行为是特定于实现的，其 <xref:System.Windows.Controls.DockPanel> 处理值的方式 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-141">Nested <xref:System.Windows.Controls.DockPanel> instances each treat their own immediate child element collections, but that behavior is implementation-specific to how <xref:System.Windows.Controls.DockPanel> processes <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> values.</span></span> <span data-ttu-id="dc3a5-142">理论上，可以有影响直接父级之外的元素的附加属性。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-142">It is theoretically possible to have attached properties that influence elements beyond the immediate parent.</span></span> <span data-ttu-id="dc3a5-143">如果 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 在没有父元素的元素上设置附加属性 <xref:System.Windows.Controls.DockPanel> ，则不会引发错误或异常。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-143">If the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property is set on an element that has no <xref:System.Windows.Controls.DockPanel> parent element to act upon it, no error or exception is raised.</span></span> <span data-ttu-id="dc3a5-144">这只是表示已设置全局属性值，但没有 <xref:System.Windows.Controls.DockPanel> 可使用该信息的当前父级。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-144">This simply means that a global property value was set, but it has no current <xref:System.Windows.Controls.DockPanel> parent that could consume the information.</span></span>

## <a name="attached-properties-in-code"></a><span data-ttu-id="dc3a5-145">代码中的附加属性 <a name="attached_properties_code"></a></span><span class="sxs-lookup"><span data-stu-id="dc3a5-145">Attached Properties in Code <a name="attached_properties_code"></a></span></span>

<span data-ttu-id="dc3a5-146">WPF 中的附加属性没有用于轻松获取/设置访问的典型 CLR "包装器" 方法。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-146">Attached properties in WPF do not have the typical CLR "wrapper" methods for easy get/set access.</span></span> <span data-ttu-id="dc3a5-147">这是因为，附加属性不一定是设置了属性的实例的 CLR 命名空间的一部分。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-147">This is because the attached property is not necessarily part of the CLR namespace for instances where the property is set.</span></span> <span data-ttu-id="dc3a5-148">但是，分析 XAML 时，XAML 处理器必须能够设置这些值。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-148">However, a XAML processor must be able to set those values when XAML is parsed.</span></span> <span data-ttu-id="dc3a5-149">若要支持有效的附加属性用法，附加属性的所有者类型必须以 **Get \* PropertyName**\* 和 \**Set* PropertyName \* \* \* 格式实现专用访问器方法。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-149">To support an effective attached property usage, the owner type of the attached property must implement dedicated accessor methods in the form **Get\*PropertyName**\* and \**Set* PropertyName\*\*\*.</span></span> <span data-ttu-id="dc3a5-150">这些专用访问器方法对在代码中设置附加属性也很有帮助。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-150">These dedicated accessor methods are also useful to get or set the attached property in code.</span></span> <span data-ttu-id="dc3a5-151">从代码的角度来看，附加属性类似于具有方法访问器而不是属性访问器的支持字段，且支持字段可在任何对象上存在，无需专门定义。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-151">From a code perspective, an attached property is similar to a backing field that has method accessors instead of property accessors, and that backing field can exist on any object rather than needing to be specifically defined.</span></span>

<span data-ttu-id="dc3a5-152">下面的示例演示如何在代码中设置附加属性。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-152">The following example shows how you can set an attached property in code.</span></span> <span data-ttu-id="dc3a5-153">在此示例中， `myCheckBox` 是类的实例 <xref:System.Windows.Controls.CheckBox> 。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-153">In this example, `myCheckBox` is an instance of the <xref:System.Windows.Controls.CheckBox> class.</span></span>

[!code-csharp[PropertiesOvwSupport#APCode](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#apcode)]
[!code-vb[PropertiesOvwSupport#APCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#apcode)]

<span data-ttu-id="dc3a5-154">类似于 XAML 情况，如果 `myCheckBox` 尚未添加为第四行代码的的子元素 `myDockPanel` ，则第五行代码不会引发异常，但属性值不会与父级交互， <xref:System.Windows.Controls.DockPanel> 因此不会执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-154">Similar to the XAML case, if `myCheckBox` had not already been added as a child element of `myDockPanel` by the fourth line of code, the fifth line of code would not raise an exception, but the property value would not interact with a <xref:System.Windows.Controls.DockPanel> parent and thus would do nothing.</span></span> <span data-ttu-id="dc3a5-155">只有 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 在子元素上设置的值与父元素的存在结合使用 <xref:System.Windows.Controls.DockPanel> 将导致呈现的应用程序中出现有效的行为。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-155">Only a <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> value set on a child element combined with the presence of a <xref:System.Windows.Controls.DockPanel> parent element will cause an effective behavior in the rendered application.</span></span> <span data-ttu-id="dc3a5-156">（在这种情况下，可以设置附加属性，然后附加到树。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-156">(In this case, you could set the attached property, then attach to the tree.</span></span> <span data-ttu-id="dc3a5-157">或者，可以先附加到该树中，然后设置附加属性。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-157">Or you could attach to the tree then set the attached property.</span></span> <span data-ttu-id="dc3a5-158">这两种操作顺序结果都相同。）</span><span class="sxs-lookup"><span data-stu-id="dc3a5-158">Either action order provides the same result.)</span></span>

## <a name="attached-property-metadata"></a><span data-ttu-id="dc3a5-159">附加属性元数据 <a name="attached_properties_metadata"></a></span><span class="sxs-lookup"><span data-stu-id="dc3a5-159">Attached Property Metadata <a name="attached_properties_metadata"></a></span></span>

<span data-ttu-id="dc3a5-160">注册属性时，将 <xref:System.Windows.FrameworkPropertyMetadata> 设置为指定属性的特性，例如属性是否影响呈现、度量等。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-160">When registering the property, <xref:System.Windows.FrameworkPropertyMetadata> is set to specify characteristics of the property, such as whether the property affects rendering, measurement, and so on.</span></span> <span data-ttu-id="dc3a5-161">附加属性的元数据通常与依赖属性上的元数据基本上都相同。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-161">Metadata for an attached property is generally no different than on a dependency property.</span></span> <span data-ttu-id="dc3a5-162">如果在附加属性元数据替代中指定默认值，该值将成为替代类实例上显式附加属性的默认值。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-162">If you specify a default value in an override to attached property metadata, that value becomes the default value of the implicit attached property on instances of the overriding class.</span></span> <span data-ttu-id="dc3a5-163">具体而言，当某些进程通过该属性的 `Get` 方法访问器请求附加属性值，并指定在其中指定元数据的类的示例时，将报告默认值，而不会设置该附加属性的值。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-163">Specifically, your default value is reported if some process queries for the value of an attached property through the `Get` method accessor for that property, specifying an instance of the class where you specified the metadata, and the value for that attached property was otherwise not set.</span></span>

<span data-ttu-id="dc3a5-164">如果希望对属性启用属性值继承，应使用附加属性，而不是非附加的依赖属性。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-164">If you want to enable property value inheritance on a property, you should use attached properties rather than non-attached dependency properties.</span></span> <span data-ttu-id="dc3a5-165">有关详细信息，请参阅[属性值继承](property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-165">For details, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

## <a name="custom-attached-properties"></a><span data-ttu-id="dc3a5-166">自定义附加属性 <a name="custom"></a></span><span class="sxs-lookup"><span data-stu-id="dc3a5-166">Custom Attached Properties <a name="custom"></a></span></span>

### <a name="when-to-create-an-attached-property"></a><span data-ttu-id="dc3a5-167">何时创建附加属性 <a name="create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="dc3a5-167">When to Create an Attached Property <a name="create_attached_properties"></a></span></span>

<span data-ttu-id="dc3a5-168">当需要有一个可用于定义类之外的其他类的属性设置机制时，建议创建附加属性。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-168">You might create an attached property when there is a reason to have a property setting mechanism available for classes other than the defining class.</span></span> <span data-ttu-id="dc3a5-169">对于这一情况，最常见的方案是布局。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-169">The most common scenario for this is layout.</span></span> <span data-ttu-id="dc3a5-170">现有布局属性的示例包括 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 、 <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType> 和 <xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-170">Examples of existing layout properties are <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>, <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>, and <xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="dc3a5-171">这里启用的方案是，作为布局控制元素的子元素存在的元素能够分别向其布局父级元素表达布局要求，其中每个元素都设置一个被父级定义为附加属性的属性值。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-171">The scenario enabled here is that elements that exist as child elements to layout-controlling elements are able to express layout requirements to their layout parent elements individually, each setting a property value that the parent defined as an attached property.</span></span>

<span data-ttu-id="dc3a5-172">使用附加属性的另一种情况是，你的类表示一种服务，且你希望类能够以更透明的方式继承该服务。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-172">Another scenario for using an attached property is when your class represents a service, and you want classes to be able to integrate the service more transparently.</span></span>

<span data-ttu-id="dc3a5-173">但另一种情况是接收 Visual Studio WPF 设计器支持，如 " **属性** " 窗口编辑。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-173">Yet another scenario is to receive Visual Studio WPF Designer support, such as **Properties** window editing.</span></span> <span data-ttu-id="dc3a5-174">有关详细信息，请参阅[控件创作概述](../controls/control-authoring-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-174">For more information, see [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>

<span data-ttu-id="dc3a5-175">如前文所述，如果想要使用属性值继承，你应该注册为附加属性。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-175">As mentioned before, you should register as an attached property if you want to use property value inheritance.</span></span>

### <a name="how-to-create-an-attached-property"></a><span data-ttu-id="dc3a5-176">如何创建附加属性 <a name="how_do_i_create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="dc3a5-176">How to Create an Attached Property <a name="how_do_i_create_attached_properties"></a></span></span>

<span data-ttu-id="dc3a5-177">如果你的类将严格定义附加属性以用于其他类型，则该类不必派生自 <xref:System.Windows.DependencyObject> 。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-177">If your class is defining the attached property strictly for use on other types, then the class does not have to derive from <xref:System.Windows.DependencyObject>.</span></span> <span data-ttu-id="dc3a5-178">但 <xref:System.Windows.DependencyObject> 如果遵循的是总体 WPF 模型，而此模型的整体 WPF 模型也是依赖属性，则需要从派生。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-178">But you do need to derive from <xref:System.Windows.DependencyObject> if you follow the overall WPF model of having your attached property also be a dependency property.</span></span>

<span data-ttu-id="dc3a5-179">通过声明类型的字段，将附加属性定义为依赖属性 `public static readonly` <xref:System.Windows.DependencyProperty> 。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-179">Define your attached property as a dependency property by declaring a `public static readonly` field of type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="dc3a5-180">使用方法的返回值定义此字段 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-180">You define this field by using the return value of the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method.</span></span> <span data-ttu-id="dc3a5-181">字段名称必须与附加的属性名称相匹配，并附加字符串 `Property` ，才能遵循为标识字段命名的已建立 WPF 模式，而不是它们所表示的属性。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-181">The field name must match the attached property name, appended with the string `Property`, to follow the established WPF pattern of naming the identifying fields versus the properties that they represent.</span></span> <span data-ttu-id="dc3a5-182">附加属性提供程序还必须提供静态 **Get \* propertyname**\* 和 **Set \* PropertyName**\* 方法作为附加属性的访问器;如果无法执行此操作，则属性系统无法使用您的附加属性。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-182">The attached property provider must also provide static **Get\*PropertyName**\* and **Set\*PropertyName**\* methods as accessors for the attached property; failing to do this results in the property system being unable to use your attached property.</span></span>

> [!NOTE]
> <span data-ttu-id="dc3a5-183">如果省略附加属性的 get 访问器，则属性上的数据绑定将无法在设计工具（如 Visual Studio 和 Blend for Visual Studio）中工作。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-183">If you omit the attached property's get accessor, data binding on the property will not work in design tools, such as Visual Studio and Blend for Visual Studio.</span></span>

#### <a name="the-get-accessor"></a><span data-ttu-id="dc3a5-184">Get 访问器</span><span class="sxs-lookup"><span data-stu-id="dc3a5-184">The Get Accessor</span></span>

<span data-ttu-id="dc3a5-185">**Get \* PropertyName**\* 访问器的签名必须是：</span><span class="sxs-lookup"><span data-stu-id="dc3a5-185">The signature for the **Get\*PropertyName**\* accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="dc3a5-186">`target` 对象在实现中可以指定为更具体的类型。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-186">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="dc3a5-187">例如，方法将 <xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType> 参数类型 <xref:System.Windows.UIElement> 设置为，因为附加属性只用于在实例上进行设置 <xref:System.Windows.UIElement> 。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-187">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType> method types the parameter as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

- <span data-ttu-id="dc3a5-188">返回值在实现中可以指定为更具体的类型。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-188">The return value can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="dc3a5-189">例如，方法将 <xref:System.Windows.Controls.DockPanel.GetDock%2A> 其类型设置为 <xref:System.Windows.Controls.Dock> ，因为只能将值设置为该枚举。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-189">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span>

#### <a name="the-set-accessor"></a><span data-ttu-id="dc3a5-190">Set 访问器</span><span class="sxs-lookup"><span data-stu-id="dc3a5-190">The Set Accessor</span></span>

<span data-ttu-id="dc3a5-191">**Set \* PropertyName**\* 访问器的签名必须是：</span><span class="sxs-lookup"><span data-stu-id="dc3a5-191">The signature for the **Set\*PropertyName**\* accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="dc3a5-192">`target` 对象在实现中可以指定为更具体的类型。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-192">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="dc3a5-193">例如，方法将 <xref:System.Windows.Controls.DockPanel.SetDock%2A> 其类型设置为 <xref:System.Windows.UIElement> ，因为附加属性只用于在实例上进行设置 <xref:System.Windows.UIElement> 。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-193">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

- <span data-ttu-id="dc3a5-194">`value` 对象在实现中可以指定为更具体的类型。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-194">The `value` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="dc3a5-195">例如，方法将 <xref:System.Windows.Controls.DockPanel.SetDock%2A> 其类型设置为 <xref:System.Windows.Controls.Dock> ，因为只能将值设置为该枚举。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-195">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span> <span data-ttu-id="dc3a5-196">请记住，此方法的值是 XAML 加载器在标记中的附加属性用法中遇到附加属性时的输入。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-196">Remember that the value for this method is the input coming from the XAML loader when it encounters your attached property in an attached property usage in markup.</span></span> <span data-ttu-id="dc3a5-197">该输入是在标记中指定为 XAML 属性值的值。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-197">That input is the value specified as a XAML attribute value in markup.</span></span> <span data-ttu-id="dc3a5-198">因此必须存在可用于你所使用的类型的类型转换、值序列化程序或标记扩展支持，以便可以从属性值（最终仅仅是一个字符串）创建相应的类型。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-198">Therefore there must be type conversion, value serializer, or markup extension support for the type you use, such that the appropriate type can be created from the attribute value (which is ultimately just a string).</span></span>

<span data-ttu-id="dc3a5-199">下面的示例演示了使用方法)  (依赖属性注册 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> ，以及 **Get \* propertyname**\* 和 **Set \* propertyname**\* 访问器。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-199">The following example shows the dependency property registration (using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method), as well as the **Get\*PropertyName**\* and **Set\*PropertyName**\* accessors.</span></span> <span data-ttu-id="dc3a5-200">在此示例中，附加属性名称为 `IsBubbleSource`。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-200">In the example, the attached property name is `IsBubbleSource`.</span></span> <span data-ttu-id="dc3a5-201">因此，访问器必须名为 `GetIsBubbleSource` 和 `SetIsBubbleSource`。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-201">Therefore, the accessors must be named `GetIsBubbleSource` and `SetIsBubbleSource`.</span></span>

[!code-csharp[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler)]
[!code-vb[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler)]

#### <a name="attached-property-attributes"></a><span data-ttu-id="dc3a5-202">附加属性特性</span><span class="sxs-lookup"><span data-stu-id="dc3a5-202">Attached Property Attributes</span></span>

<span data-ttu-id="dc3a5-203">WPF 定义了多个 .NET 特性，旨在向反射进程提供附加属性的相关信息，并定义了反射的典型用户和属性信息（如设计器）。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-203">WPF defines several .NET attributes that are intended to provide information about attached properties to reflection processes, and to typical users of reflection and property information such as designers.</span></span> <span data-ttu-id="dc3a5-204">由于附加属性的类型没有范围限制，因此设计者需要一种方法来避免用户查看全局列表时，看到使用 XAML 的特定技术实现中定义的所有附加属性。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-204">Because attached properties have a type of unlimited scope, designers need a way to avoid overwhelming users with a global list of all the attached properties that are defined in a particular technology implementation that uses XAML.</span></span> <span data-ttu-id="dc3a5-205">WPF 为附加属性定义的 .NET 特性可用于确定应该在 "属性" 窗口中显示给定附加属性的情况的作用域。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-205">The .NET attributes that WPF defines for attached properties can be used to scope the situations where a given attached property should be shown in a properties window.</span></span> <span data-ttu-id="dc3a5-206">你还可考虑对自己的自定义附加属性应用这些特性。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-206">You might consider applying these attributes for your own custom attached properties also.</span></span> <span data-ttu-id="dc3a5-207">.NET 特性的目的和语法在相应的参考页上进行了说明：</span><span class="sxs-lookup"><span data-stu-id="dc3a5-207">The purpose and syntax of the .NET attributes is described on the appropriate reference pages:</span></span>

- <xref:System.Windows.AttachedPropertyBrowsableAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForChildrenAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForTypeAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableWhenAttributePresentAttribute>

## <a name="learning-more-about-attached-properties"></a><span data-ttu-id="dc3a5-208">了解有关附加属性的详细信息 <a name="more"></a></span><span class="sxs-lookup"><span data-stu-id="dc3a5-208">Learning More About Attached Properties <a name="more"></a></span></span>

- <span data-ttu-id="dc3a5-209">有关如何创建附加属性的详细信息，请参阅[注册附加属性](how-to-register-an-attached-property.md)。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-209">For more information on creating an attached property, see [Register an Attached Property](how-to-register-an-attached-property.md).</span></span>

- <span data-ttu-id="dc3a5-210">有关依赖属性和附加属性的更多高级使用方案，请参阅[自定义依赖属性](custom-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-210">For more advanced usage scenarios for dependency properties and attached properties, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>

- <span data-ttu-id="dc3a5-211">还可将属性注册为附加属性和依赖属性，但仍需公开“包装器”实现。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-211">You can also register a property as an attached property, and as a dependency property, but then still expose "wrapper" implementations.</span></span> <span data-ttu-id="dc3a5-212">在这种情况下，属性可在该元素上设置，也可通过 XAML 附加属性语法在任何元素上设置。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-212">In this case, the property can be set either on that element, or on any element through the XAML attached property syntax.</span></span> <span data-ttu-id="dc3a5-213">具有适用于标准和附加用法的适当方案的属性示例是 <xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="dc3a5-213">An example of a property with an appropriate scenario for both standard and attached usages is <xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>.</span></span>

## <a name="see-also"></a><span data-ttu-id="dc3a5-214">另请参阅</span><span class="sxs-lookup"><span data-stu-id="dc3a5-214">See also</span></span>

- <xref:System.Windows.DependencyProperty>
- [<span data-ttu-id="dc3a5-215">依赖项属性概述</span><span class="sxs-lookup"><span data-stu-id="dc3a5-215">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="dc3a5-216">自定义依赖项属性</span><span class="sxs-lookup"><span data-stu-id="dc3a5-216">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="dc3a5-217">XAML 概述 (WPF)</span><span class="sxs-lookup"><span data-stu-id="dc3a5-217">XAML Overview (WPF)</span></span>](/dotnet/desktop-wpf/fundamentals/xaml)
- [<span data-ttu-id="dc3a5-218">注册附加属性</span><span class="sxs-lookup"><span data-stu-id="dc3a5-218">Register an Attached Property</span></span>](how-to-register-an-attached-property.md)
