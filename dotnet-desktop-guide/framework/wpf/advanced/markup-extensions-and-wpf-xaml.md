---
title: 标记扩展和 XAML
ms.date: 03/30/2017
helpviewer_keywords:
- brace character [WPF]
- Binding markup extensions [WPF]
- RelativeSource markup extensions [WPF]
- XAML [WPF], markup extensions
- markup extensions [WPF]
- nesting extension syntax [WPF]
- curly brace characters ({})
- TemplateBinding markup extensions [WPF]
- StaticResource markup extensions [WPF]
- literal curly brace characters ({})
- characters [WPF], curly brace
- DynamicResource markup extensions [WPF]
ms.assetid: 618dc745-8b14-4886-833f-486d2254bb78
ms.openlocfilehash: bb197701c67435c7fc4818aef2eb0e94e7a23b44
ms.sourcegitcommit: bf5dd80f4d7b202afa90e90d1148402c5474d826
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/30/2021
ms.locfileid: "96970247"
---
# <a name="markup-extensions-and-wpf-xaml"></a><span data-ttu-id="d4754-102">标记扩展和 WPF XAML</span><span class="sxs-lookup"><span data-stu-id="d4754-102">Markup Extensions and WPF XAML</span></span>
<span data-ttu-id="d4754-103">本主题介绍 XAML 的标记扩展概念，包括其语法规则、用途以及作为其基础的类对象模型。</span><span class="sxs-lookup"><span data-stu-id="d4754-103">This topic introduces the concept of markup extensions for XAML, including their syntax rules, purpose, and the class object model that underlies them.</span></span> <span data-ttu-id="d4754-104">标记扩展是 XAML 语言以及 XAML 服务的 .NET 实现的常规功能。</span><span class="sxs-lookup"><span data-stu-id="d4754-104">Markup extensions are a general feature of the XAML language and of the .NET implementation of XAML services.</span></span> <span data-ttu-id="d4754-105">本主题专门详细讨论用于 WPF XAML 的标记扩展。</span><span class="sxs-lookup"><span data-stu-id="d4754-105">This topic specifically details markup extensions for use in WPF XAML.</span></span>  

<a name="XAML_Processors_and_Markup_Extensions"></a>
## <a name="xaml-processors-and-markup-extensions"></a><span data-ttu-id="d4754-106">XAML 处理器和标记扩展</span><span class="sxs-lookup"><span data-stu-id="d4754-106">XAML Processors and Markup Extensions</span></span>  
 <span data-ttu-id="d4754-107">通常，XAML 分析器可将特性值解释为可转换成基元的文本字符串，或可通过某种方法将特性值转换为对象。</span><span class="sxs-lookup"><span data-stu-id="d4754-107">Generally speaking, a XAML parser can either interpret an attribute value as a literal string that can be converted to a primitive, or convert it to an object by some means.</span></span> <span data-ttu-id="d4754-108">其中一种方法是引用类型转换器；详情请参阅主题 [TypeConverters 和 XAML](typeconverters-and-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="d4754-108">One such means is by referencing a type converter; this is documented in the topic [TypeConverters and XAML](typeconverters-and-xaml.md).</span></span> <span data-ttu-id="d4754-109">不过，也存在要求其他行为的情况。</span><span class="sxs-lookup"><span data-stu-id="d4754-109">However, there are scenarios where different behavior is required.</span></span> <span data-ttu-id="d4754-110">例如，可以指示 XAML 处理器，特性的值不应在对象图中生成新对象。</span><span class="sxs-lookup"><span data-stu-id="d4754-110">For example, a XAML processor can be instructed that a value of an attribute should not result in a new object in the object graph.</span></span> <span data-ttu-id="d4754-111">相反，特性应生成引用对象图另一部分中的已构造对象或引用静态对象的对象图。</span><span class="sxs-lookup"><span data-stu-id="d4754-111">Instead, the attribute should result in an object graph that makes a reference to an already constructed object in another part of the graph, or a static object.</span></span> <span data-ttu-id="d4754-112">另一种情况是，可以指示 XAML 处理器使用向对象的构造函数提供非默认参数的语法。</span><span class="sxs-lookup"><span data-stu-id="d4754-112">Another scenario is that a XAML processor can be instructed to use a syntax that provides non-default arguments to the constructor of an object.</span></span> <span data-ttu-id="d4754-113">在这些类型的情况中，标记扩展可以提供解决方案。</span><span class="sxs-lookup"><span data-stu-id="d4754-113">These are the types of scenarios where a markup extension can provide the solution.</span></span>  
  
<a name="Basic_Markup_Extension_Syntax"></a>
## <a name="basic-markup-extension-syntax"></a><span data-ttu-id="d4754-114">基本标记扩展语法</span><span class="sxs-lookup"><span data-stu-id="d4754-114">Basic Markup Extension Syntax</span></span>  
 <span data-ttu-id="d4754-115">可以实现标记扩展来为特性用法中的属性和/或属性元素用法中的属性提供值。</span><span class="sxs-lookup"><span data-stu-id="d4754-115">A markup extension can be implemented to provide values for properties in an attribute usage, properties in a property element usage, or both.</span></span>  
  
 <span data-ttu-id="d4754-116">当用于提供特性值时，将标记扩展序列与 XAML 处理器区分开的语法是左右大括号（{ 和 }）。</span><span class="sxs-lookup"><span data-stu-id="d4754-116">When used to provide an attribute value, the syntax that distinguishes a markup extension sequence to a XAML processor is the presence of the opening and closing curly braces ({ and }).</span></span> <span data-ttu-id="d4754-117">然后，由紧跟在左大括号后面的字符串标记来标识标记扩展的类型。</span><span class="sxs-lookup"><span data-stu-id="d4754-117">The type of markup extension is then identified by the string token immediately following the opening curly brace.</span></span>  
  
 <span data-ttu-id="d4754-118">当用在属性元素语法中时，标记扩展在外观上与任何其他用于提供属性元素值的元素相同，即：一个将标记扩展类作为元素引用并以尖括号 (<>) 括起的 XAML 元素声明。</span><span class="sxs-lookup"><span data-stu-id="d4754-118">When used in property element syntax, a markup extension is visually the same as any other element used to provide a property element value: a XAML element declaration that references the markup extension class as an element, enclosed within angle brackets (<>).</span></span>  
  
<a name="XAML_Defined_Markup_Extensions"></a>
## <a name="xaml-defined-markup-extensions"></a><span data-ttu-id="d4754-119">XAML 定义的标记扩展</span><span class="sxs-lookup"><span data-stu-id="d4754-119">XAML-Defined Markup Extensions</span></span>  
 <span data-ttu-id="d4754-120">存在这么几种标记扩展，它们并非特定于 XAML 的 WPF 实现，而是语言形式的 XAML 的内部函数或功能的实现。</span><span class="sxs-lookup"><span data-stu-id="d4754-120">Several markup extensions exist that are not specific to the WPF implementation of XAML, but are instead implementations of intrinsics or features of XAML as a language.</span></span> <span data-ttu-id="d4754-121">这些标记扩展在 System.Xaml 程序集中作为常规 .NET Framework XAML 服务的一部分而实现，并且位于 XAML 语言 XAML 命名空间内。</span><span class="sxs-lookup"><span data-stu-id="d4754-121">These markup extensions are implemented in the System.Xaml assembly as part of the general .NET Framework XAML services, and are within the XAML language XAML namespace.</span></span> <span data-ttu-id="d4754-122">就常见标记用法而言，这些标记扩展通常可由用法中的 `x:` 前缀标识。</span><span class="sxs-lookup"><span data-stu-id="d4754-122">In terms of common markup usage, these markup extensions are typically identifiable by the `x:` prefix in the usage.</span></span> <span data-ttu-id="d4754-123"><xref:System.Windows.Markup.MarkupExtension>基类 (也是在) 中定义的，它提供了所有标记扩展应使用的模式，以便在 xaml 读取器和 xaml 编写器（包括在 WPF Xaml 中）中受支持。</span><span class="sxs-lookup"><span data-stu-id="d4754-123">The <xref:System.Windows.Markup.MarkupExtension> base class (also defined in System.Xaml) provides the pattern that all markup extensions should use in order to be supported in XAML readers and XAML writers, including in WPF XAML.</span></span>  
  
- <span data-ttu-id="d4754-124">`x:Type` 为命名类型提供 <xref:System.Type> 对象。</span><span class="sxs-lookup"><span data-stu-id="d4754-124">`x:Type` supplies the <xref:System.Type> object for the named type.</span></span> <span data-ttu-id="d4754-125">此扩展最常用于样式和模板。</span><span class="sxs-lookup"><span data-stu-id="d4754-125">This facility is used most frequently in styles and templates.</span></span> <span data-ttu-id="d4754-126">有关详细信息，请参阅 [x:Type 标记扩展](/dotnet/desktop-wpf/xaml-services/xtype-markup-extension)。</span><span class="sxs-lookup"><span data-stu-id="d4754-126">For details, see [x:Type Markup Extension](/dotnet/desktop-wpf/xaml-services/xtype-markup-extension).</span></span>  
  
- <span data-ttu-id="d4754-127">`x:Static` 生成静态值。</span><span class="sxs-lookup"><span data-stu-id="d4754-127">`x:Static` produces static values.</span></span> <span data-ttu-id="d4754-128">这些值来自于值类型代码实体，它们不直接是目标属性值的类型，但可以计算为该类型。</span><span class="sxs-lookup"><span data-stu-id="d4754-128">The values come from value-type code entities that are not directly the type of a target property's value, but can be evaluated to that type.</span></span> <span data-ttu-id="d4754-129">有关详细信息，请参阅 [x:Static 标记扩展](/dotnet/desktop-wpf/xaml-services/xstatic-markup-extension)。</span><span class="sxs-lookup"><span data-stu-id="d4754-129">For details, see [x:Static Markup Extension](/dotnet/desktop-wpf/xaml-services/xstatic-markup-extension).</span></span>  
  
- <span data-ttu-id="d4754-130">`x:Null` 将 `null` 指定为属性的值，可用于特性或属性元素值。</span><span class="sxs-lookup"><span data-stu-id="d4754-130">`x:Null` specifies `null` as a value for a property and can be used either for attributes or property element values.</span></span> <span data-ttu-id="d4754-131">有关详细信息，请参阅 [x:Null 标记扩展](/dotnet/desktop-wpf/xaml-services/xnull-markup-extension)。</span><span class="sxs-lookup"><span data-stu-id="d4754-131">For details, see [x:Null Markup Extension](/dotnet/desktop-wpf/xaml-services/xnull-markup-extension).</span></span>  
  
- <span data-ttu-id="d4754-132">在特意不使用 WPF 基元素和控件模型提供的集合支持的情况下，`x:Array` 为 XAML 语法中常规数组的创建提供支持。</span><span class="sxs-lookup"><span data-stu-id="d4754-132">`x:Array` provides support for creation of general arrays in XAML syntax, for cases where the collection support provided by WPF base elements and control models is deliberately not used.</span></span> <span data-ttu-id="d4754-133">有关详细信息，请参阅 [x:Array 标记扩展](/dotnet/desktop-wpf/xaml-services/xarray-markup-extension)。</span><span class="sxs-lookup"><span data-stu-id="d4754-133">For details, see [x:Array Markup Extension](/dotnet/desktop-wpf/xaml-services/xarray-markup-extension).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="d4754-134">`x:` 前缀在 XAML 文件或生成的根元素中用于 XAML 语言内部函数的典型 XAML 命名空间映射。</span><span class="sxs-lookup"><span data-stu-id="d4754-134">The `x:` prefix is used for the typical XAML namespace mapping of the XAML language intrinsics, in the root element of a XAML file or production.</span></span> <span data-ttu-id="d4754-135">例如，用于 WPF 应用程序的 Visual Studio 模板会使用此映射启动一个 XAML 文件 `x:` 。</span><span class="sxs-lookup"><span data-stu-id="d4754-135">For example, the Visual Studio templates for WPF applications initiate a XAML file using this `x:` mapping.</span></span> <span data-ttu-id="d4754-136">可以在自己的 XAML 命名空间映射中选择不同的前缀标记，但本文档将采用默认的 `x:` 映射，并通过它来标识属于 XAML 语言的 XAML 命名空间已定义部分的那些实体，这与 WPF 默认命名空间或与特定框架不相关的其他 XAML 命名空间相反。</span><span class="sxs-lookup"><span data-stu-id="d4754-136">You could choose a different prefix token in your own XAML namespace mapping, but this documentation will assume the default `x:` mapping as a means of identifying those entities that are a defined part of the XAML namespace for the XAML language, as opposed to the WPF default namespace or other XAML namespaces not related to a specific framework.</span></span>  
  
<a name="WPF_Specific_Markup_Extensions"></a>
## <a name="wpf-specific-markup-extensions"></a><span data-ttu-id="d4754-137">特定于 WPF 的标记扩展</span><span class="sxs-lookup"><span data-stu-id="d4754-137">WPF-Specific Markup Extensions</span></span>  
 <span data-ttu-id="d4754-138">WPF 编程中最常用的标记扩展是支持资源引用的标记扩展（`StaticResource` 和 `DynamicResource`），和支持数据绑定的标记扩展 (`Binding`)。</span><span class="sxs-lookup"><span data-stu-id="d4754-138">The most common markup extensions used in WPF programming are those that support resource references (`StaticResource` and `DynamicResource`), and those that support data binding (`Binding`).</span></span>  
  
- <span data-ttu-id="d4754-139">`StaticResource` 通过替换已定义资源的值来为属性提供值。</span><span class="sxs-lookup"><span data-stu-id="d4754-139">`StaticResource` provides a value for a property by substituting the value of an already defined resource.</span></span> <span data-ttu-id="d4754-140">`StaticResource` 计算最终在 XAML 加载时进行，并且在运行时没有访问对象图的权限。</span><span class="sxs-lookup"><span data-stu-id="d4754-140">A `StaticResource` evaluation is ultimately made at XAML load time and does not have access to the object graph at run time.</span></span> <span data-ttu-id="d4754-141">有关详细信息，请访问 [StaticResource 标记扩展](staticresource-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="d4754-141">For details, see [StaticResource Markup Extension](staticresource-markup-extension.md).</span></span>  
  
- <span data-ttu-id="d4754-142">`DynamicResource` 通过将值推迟为对资源的运行时引用来为属性提供值。</span><span class="sxs-lookup"><span data-stu-id="d4754-142">`DynamicResource` provides a value for a property by deferring that value to be a run-time reference to a resource.</span></span> <span data-ttu-id="d4754-143">动态资源引用强制在每次访问此类资源时都进行新查找，且在运行时有权访问对象图。</span><span class="sxs-lookup"><span data-stu-id="d4754-143">A dynamic resource reference forces a new lookup each time that such a resource is accessed and has access to the object graph at run time.</span></span> <span data-ttu-id="d4754-144">为了获取此访问权限，WPF 属性系统中的依赖项属性和计算出的表达式支持 `DynamicResource` 概念。</span><span class="sxs-lookup"><span data-stu-id="d4754-144">In order to get this access, `DynamicResource` concept is supported by dependency properties in the WPF property system, and evaluated expressions.</span></span> <span data-ttu-id="d4754-145">因此，只能对依赖项属性目标使用 `DynamicResource`。</span><span class="sxs-lookup"><span data-stu-id="d4754-145">Therefore you can only use `DynamicResource` for a dependency property target.</span></span> <span data-ttu-id="d4754-146">有关详细信息，请参阅 [DynamicResource 标记扩展](dynamicresource-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="d4754-146">For details, see [DynamicResource Markup Extension](dynamicresource-markup-extension.md).</span></span>  
  
- <span data-ttu-id="d4754-147">`Binding` 使用在运行时应用于父对象的数据上下文来为属性提供数据绑定值。</span><span class="sxs-lookup"><span data-stu-id="d4754-147">`Binding` provides a data bound value for a property, using the data context that applies to the parent object at run time.</span></span> <span data-ttu-id="d4754-148">此标记扩展相对复杂，因为它会启用大量内联语法来指定数据绑定。</span><span class="sxs-lookup"><span data-stu-id="d4754-148">This markup extension is relatively complex, because it enables a substantial inline syntax for specifying a data binding.</span></span> <span data-ttu-id="d4754-149">有关详细信息，请参阅 [Binding 标记扩展](binding-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="d4754-149">For details, see [Binding Markup Extension](binding-markup-extension.md).</span></span>  
  
- <span data-ttu-id="d4754-150">`RelativeSource` 提供的源信息 <xref:System.Windows.Data.Binding> ，该信息可在运行时对象树中导航几个可能的关系。</span><span class="sxs-lookup"><span data-stu-id="d4754-150">`RelativeSource` provides source information for a <xref:System.Windows.Data.Binding> that can navigate several possible relationships in the run-time object tree.</span></span> <span data-ttu-id="d4754-151">对于在多用途模板中创建的绑定，或在未充分了解周围的对象树的情况下以代码创建的绑定，此标记扩展为其提供专用源。</span><span class="sxs-lookup"><span data-stu-id="d4754-151">This provides specialized sourcing for bindings that are created in multi-use templates or created in code without full knowledge of the surrounding object tree.</span></span> <span data-ttu-id="d4754-152">有关详细信息，请参阅 [RelativeSource 标记扩展](relativesource-markupextension.md)。</span><span class="sxs-lookup"><span data-stu-id="d4754-152">For details, see [RelativeSource MarkupExtension](relativesource-markupextension.md).</span></span>  
  
- <span data-ttu-id="d4754-153">`TemplateBinding` 使控件模板能够使用模板化属性的值，这些属性来自于将使用该模板的类的对象模型定义属性。</span><span class="sxs-lookup"><span data-stu-id="d4754-153">`TemplateBinding` enables a control template to use values for templated properties that come from object-model-defined properties of the class that will use the template.</span></span> <span data-ttu-id="d4754-154">换言之，模板定义中的属性可访问仅在应用了模板之后才存在的上下文。</span><span class="sxs-lookup"><span data-stu-id="d4754-154">In other words, the property within the template definition can access a context that only exists once the template is applied.</span></span> <span data-ttu-id="d4754-155">有关详细信息，请参阅 [TemplateBinding 标记扩展](templatebinding-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="d4754-155">For details, see [TemplateBinding Markup Extension](templatebinding-markup-extension.md).</span></span> <span data-ttu-id="d4754-156">有关 `TemplateBinding` 的实际使用的详细信息，请参阅[使用 ControlTemplates 设置样式示例](https://github.com/Microsoft/WPF-Samples/tree/master/Styles%20&%20Templates/IntroToStylingAndTemplating)。</span><span class="sxs-lookup"><span data-stu-id="d4754-156">For more information on the practical use of `TemplateBinding`, see [Styling with ControlTemplates Sample](https://github.com/Microsoft/WPF-Samples/tree/master/Styles%20&%20Templates/IntroToStylingAndTemplating).</span></span>  
  
- <span data-ttu-id="d4754-157">`ColorConvertedBitmap` 支持相对高级的映像方案。</span><span class="sxs-lookup"><span data-stu-id="d4754-157">`ColorConvertedBitmap` supports a relatively advanced imaging scenario.</span></span> <span data-ttu-id="d4754-158">有关详细信息，请参阅 [ColorConvertedBitmap 标记扩展](colorconvertedbitmap-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="d4754-158">For details, see [ColorConvertedBitmap Markup Extension](colorconvertedbitmap-markup-extension.md).</span></span>  
  
- <span data-ttu-id="d4754-159">`ComponentResourceKey` 和 `ThemeDictionary` 支持资源查找的各个方面，特别是支持查找与自定义控件一起打包的资源和主题。</span><span class="sxs-lookup"><span data-stu-id="d4754-159">`ComponentResourceKey` and `ThemeDictionary` support aspects of resource lookup, particularly for resources and themes that are packaged with custom controls.</span></span> <span data-ttu-id="d4754-160">有关详细信息，请参阅 [ComponentResourceKey 标记扩展](componentresourcekey-markup-extension.md)、[ThemeDictionary 标记扩展](themedictionary-markup-extension.md)或[控件创作概述](../controls/control-authoring-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="d4754-160">For more information, see [ComponentResourceKey Markup Extension](componentresourcekey-markup-extension.md), [ThemeDictionary Markup Extension](themedictionary-markup-extension.md), or [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>  
  
<a name="StarExtension"></a>
## <a name="extension-classes"></a><span data-ttu-id="d4754-161">\*扩展类</span><span class="sxs-lookup"><span data-stu-id="d4754-161">\*Extension Classes</span></span>  
 <span data-ttu-id="d4754-162">对于常规 XAML 语言和特定于 WPF 的标记扩展，每个标记扩展的行为通过派生自的类标识为 XAML 处理器 `*Extension` <xref:System.Windows.Markup.MarkupExtension> ，并提供方法的实现 <xref:System.Windows.Markup.StaticExtension.ProvideValue%2A> 。</span><span class="sxs-lookup"><span data-stu-id="d4754-162">For both the general XAML language and WPF-specific markup extensions, the behavior of each markup extension is identified to a XAML processor through a `*Extension` class that derives from <xref:System.Windows.Markup.MarkupExtension>, and provides an implementation of the <xref:System.Windows.Markup.StaticExtension.ProvideValue%2A> method.</span></span> <span data-ttu-id="d4754-163">每个扩展上的此方法都会提供在计算标记扩展时返回的对象。</span><span class="sxs-lookup"><span data-stu-id="d4754-163">This method on each extension provides the object that is returned when the markup extension is evaluated.</span></span> <span data-ttu-id="d4754-164">通常会基于传递给标记扩展的各个字符串标记来计算返回的对象。</span><span class="sxs-lookup"><span data-stu-id="d4754-164">The returned object is typically evaluated based on the various string tokens that are passed to the markup extension.</span></span>  
  
 <span data-ttu-id="d4754-165">例如， <xref:System.Windows.StaticResourceExtension> 类提供实际资源查找的表面实现，以便其 <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A> 实现返回所请求的对象，并将该特定实现的输入作为用于按其查找资源的字符串 `x:Key` 。</span><span class="sxs-lookup"><span data-stu-id="d4754-165">For example, the <xref:System.Windows.StaticResourceExtension> class provides the surface implementation of actual resource lookup so that its <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A> implementation returns the object that is requested, with the input of that particular implementation being a string that is used to look up the resource by its `x:Key`.</span></span> <span data-ttu-id="d4754-166">如果使用的是现有标记扩展，则其大部分实现详细信息都无关紧要。</span><span class="sxs-lookup"><span data-stu-id="d4754-166">Much of this implementation detail is unimportant if you are using an existing markup extension.</span></span>  
  
 <span data-ttu-id="d4754-167">有些标记扩展不使用字符串标记参数。</span><span class="sxs-lookup"><span data-stu-id="d4754-167">Some markup extensions do not use string token arguments.</span></span> <span data-ttu-id="d4754-168">这是因为它们返回静态值或一致的值，或者因为应返回何值的上下文可通过经 `serviceProvider` 参数传递的服务之一提供。</span><span class="sxs-lookup"><span data-stu-id="d4754-168">This is either because they return a static or consistent value, or because context for what value should be returned is available through one of the services passed through the `serviceProvider` parameter.</span></span>  
  
 <span data-ttu-id="d4754-169">`*Extension` 命名模式的目的是为了实现方便和一致。</span><span class="sxs-lookup"><span data-stu-id="d4754-169">The `*Extension` naming pattern is for convenience and consistency.</span></span> <span data-ttu-id="d4754-170">XAML 处理器不必将该类标识为支持标记扩展。</span><span class="sxs-lookup"><span data-stu-id="d4754-170">It is not necessary in order for a XAML processor to identify that class as support for a markup extension.</span></span> <span data-ttu-id="d4754-171">只要基本代码包含 system.exception 并使用 .NET Framework XAML 服务实现，所有需要识别为 XAML 标记扩展的都是从和派生， <xref:System.Windows.Markup.MarkupExtension> 以支持构造语法。</span><span class="sxs-lookup"><span data-stu-id="d4754-171">So long as your codebase includes System.Xaml and uses .NET Framework XAML Services implementations, all that is necessary to be recognized as a XAML markup extension is to derive from <xref:System.Windows.Markup.MarkupExtension> and to support a construction syntax.</span></span> <span data-ttu-id="d4754-172">WPF 定义了标记扩展-启用不遵循 `*Extension` 命名模式的类，例如 <xref:System.Windows.Data.Binding> 。</span><span class="sxs-lookup"><span data-stu-id="d4754-172">WPF defines markup extension-enabling classes that do not follow the `*Extension` naming pattern, for example <xref:System.Windows.Data.Binding>.</span></span> <span data-ttu-id="d4754-173">原因通常是该类支持纯标记扩展支持以外的方案。</span><span class="sxs-lookup"><span data-stu-id="d4754-173">Typically the reason for this is that the class supports scenarios beyond pure markup extension support.</span></span> <span data-ttu-id="d4754-174">对于 <xref:System.Windows.Data.Binding> ，对于与 XAML 无关的方案，该类支持对对象的方法和属性的运行时访问。</span><span class="sxs-lookup"><span data-stu-id="d4754-174">In the case of <xref:System.Windows.Data.Binding>, that class supports run-time access to methods and properties of the object for scenarios that have nothing to do with XAML.</span></span>  
  
### <a name="extension-class-interpretation-of-initialization-text"></a><span data-ttu-id="d4754-175">初始化文本的扩展类解释</span><span class="sxs-lookup"><span data-stu-id="d4754-175">Extension Class Interpretation of Initialization Text</span></span>  
 <span data-ttu-id="d4754-176">跟在标记扩展名称后且仍在括号内的字符串标记由 XAML 处理器通过以下方式之一进行解释：</span><span class="sxs-lookup"><span data-stu-id="d4754-176">The string tokens following the markup extension name and still within the braces are interpreted by a XAML processor in one of the following ways:</span></span>  
  
- <span data-ttu-id="d4754-177">逗号始终表示各个标记的分隔符。</span><span class="sxs-lookup"><span data-stu-id="d4754-177">A comma always represents the separator or delimiter of individual tokens.</span></span>  
  
- <span data-ttu-id="d4754-178">如果各个分隔的标记不包含任何等号，则每个标记都将被视为构造函数参数。</span><span class="sxs-lookup"><span data-stu-id="d4754-178">If the individual separated tokens do not contain any equals signs, each token is treated as a constructor argument.</span></span> <span data-ttu-id="d4754-179">必须按该签名所期望的类型和该签名所期望的适当顺序给出每个构造函数参数。</span><span class="sxs-lookup"><span data-stu-id="d4754-179">Each constructor parameter must be given as the type expected by that signature, and in the proper order expected by that signature.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="d4754-180">XAML 处理器必须调用与对的数量这一参数计数匹配的构造函数。</span><span class="sxs-lookup"><span data-stu-id="d4754-180">A XAML processor must call the constructor that matches the argument count of the number of pairs.</span></span> <span data-ttu-id="d4754-181">出于此原因，如果要实现自定义标记扩展，请不要提供具有相同参数计数的多个构造函数。</span><span class="sxs-lookup"><span data-stu-id="d4754-181">For this reason, if you are implementing a custom markup extension, do not provide multiple constructors with the same argument count.</span></span> <span data-ttu-id="d4754-182">如果多个标记扩展构造函数路径具有相同的参数计数，则不会定义 XAML 处理器的行为方式，但应预计到如果这种情况存在于标记扩展类型定义中，则会允许 XAML 处理器引发有关使用情况的异常。</span><span class="sxs-lookup"><span data-stu-id="d4754-182">The behavior for how a XAML processor behaves if more than one markup extension constructor path with the same parameter count exists is not defined, but you should anticipate that a XAML processor is permitted to throw an exception on usage if this situation exists in the markup extension type definitions.</span></span>  
  
- <span data-ttu-id="d4754-183">如果单个分隔标记包含等号，则 XAML 处理器首先调用标记扩展的无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="d4754-183">If the individual separated tokens contain equals signs, then a XAML processor first calls the parameterless constructor for the markup extension.</span></span> <span data-ttu-id="d4754-184">之后，每个“名称=值”对会解释为标记扩展上存在的属性名称以及赋给该属性的值。</span><span class="sxs-lookup"><span data-stu-id="d4754-184">Then, each name=value pair is interpreted as a property name that exists on the markup extension, and a value to assign to that property.</span></span>  
  
- <span data-ttu-id="d4754-185">如果标记扩展中的构造函数行为与属性设置行为之间存在并行结果，则使用哪个行为都无关紧要。</span><span class="sxs-lookup"><span data-stu-id="d4754-185">If there is a parallel result between the constructor behavior and the property setting behavior in a markup extension, it does not matter which behavior you use.</span></span> <span data-ttu-id="d4754-186"> `=` 对于包含多个可设置属性的标记扩展，使用属性 *值* 对更常见，只是因为它会使你的标记更有意，并且不太可能意外地转置构造函数参数。</span><span class="sxs-lookup"><span data-stu-id="d4754-186">It is more common usage to use the *property*`=`*value* pairs for markup extensions that have more than one settable property, if only because it makes your markup more intentional and you are less likely to accidentally transpose constructor parameters.</span></span> <span data-ttu-id="d4754-187"> (在指定属性 = 值对时，这些属性可以是任意顺序 ) 。也不能保证标记扩展提供构造函数参数来设置其每个可设置属性。</span><span class="sxs-lookup"><span data-stu-id="d4754-187">(When you specify property=value pairs, those properties may be in any order.) Also, there is no guarantee that a markup extension supplies a constructor parameter that sets every one of its settable properties.</span></span> <span data-ttu-id="d4754-188">例如， <xref:System.Windows.Data.Binding> 是一个标记扩展，其中的许多属性都可以通过 "*属性* 值" 窗体中的扩展进行设置 `=`  ，但 <xref:System.Windows.Data.Binding> 仅支持两个构造函数：一个无参数的构造函数和一个设置初始路径的构造函数。</span><span class="sxs-lookup"><span data-stu-id="d4754-188">For example, <xref:System.Windows.Data.Binding> is a markup extension, with many properties that are settable through the extension in *property*`=`*value* form, but <xref:System.Windows.Data.Binding> only supports two constructors: a parameterless constructor, and one that sets an initial path.</span></span>  
  
- <span data-ttu-id="d4754-189">文本逗号在未转义的情况下无法传递给标记扩展。</span><span class="sxs-lookup"><span data-stu-id="d4754-189">A literal comma cannot be passed to a markup extension without escapement.</span></span>  
  
<a name="EscapeSequences"></a>
## <a name="escape-sequences-and-markup-extensions"></a><span data-ttu-id="d4754-190">转义序列和标记扩展</span><span class="sxs-lookup"><span data-stu-id="d4754-190">Escape Sequences and Markup Extensions</span></span>  
 <span data-ttu-id="d4754-191">XAML 处理器中的特性处理使用大括号作为标记扩展序列的指示符。</span><span class="sxs-lookup"><span data-stu-id="d4754-191">Attribute handling in a XAML processor uses the curly braces as indicators of a markup extension sequence.</span></span> <span data-ttu-id="d4754-192">必要时，也可以使用后跟文本大括号的空大括号对输入转义序列，来生成文本大括号字符特性值。</span><span class="sxs-lookup"><span data-stu-id="d4754-192">It is also possible to produce a literal curly brace character attribute value if necessary, by entering an escape sequence using an empty curly brace pair followed by the literal curly brace.</span></span> <span data-ttu-id="d4754-193">请参阅[ {} 转义序列标记扩展](/dotnet/desktop-wpf/xaml-services/escape-sequence-markup-extension)。</span><span class="sxs-lookup"><span data-stu-id="d4754-193">See [{} Escape Sequence - Markup Extension](/dotnet/desktop-wpf/xaml-services/escape-sequence-markup-extension).</span></span>  
  
<a name="Nesting"></a>
## <a name="nesting-markup-extensions-in-xaml-usage"></a><span data-ttu-id="d4754-194">XAML 中的嵌套标记扩展用法</span><span class="sxs-lookup"><span data-stu-id="d4754-194">Nesting Markup Extensions in XAML Usage</span></span>  
 <span data-ttu-id="d4754-195">支持多个标记扩展的嵌套，并且将首先计算每个标记扩展的最里层。</span><span class="sxs-lookup"><span data-stu-id="d4754-195">Nesting of multiple markup extensions is supported, and each markup extension will be evaluated deepest first.</span></span> <span data-ttu-id="d4754-196">例如，考虑下面的用法：</span><span class="sxs-lookup"><span data-stu-id="d4754-196">For example, consider the following usage:</span></span>  
  
```xaml  
<Setter Property="Background"  
  Value="{DynamicResource {x:Static SystemColors.ControlBrushKey}}" />  
```  
  
 <span data-ttu-id="d4754-197">在此用法中，将首先计算 `x:Static` 语句并返回字符串。</span><span class="sxs-lookup"><span data-stu-id="d4754-197">In this usage, the `x:Static` statement is evaluated first and returns a string.</span></span> <span data-ttu-id="d4754-198">该字符串随后用作 `DynamicResource` 的参数。</span><span class="sxs-lookup"><span data-stu-id="d4754-198">That string is then used as the argument for `DynamicResource`.</span></span>  
  
## <a name="markup-extensions-and-property-element-syntax"></a><span data-ttu-id="d4754-199">标记扩展和属性元素语法</span><span class="sxs-lookup"><span data-stu-id="d4754-199">Markup Extensions and Property Element Syntax</span></span>  
 <span data-ttu-id="d4754-200">当用作填写属性元素值的对象元素时，标记扩展类在外观上与可用在 XAML 中的基于典型类型的对象元素没有区别。</span><span class="sxs-lookup"><span data-stu-id="d4754-200">When used as an object element that fills a property element value, a markup extension class is visually indistinguishable from a typical type-backed object element that can be used in XAML.</span></span> <span data-ttu-id="d4754-201">典型对象元素与标记扩展之间的实际差异是，标记扩展要么计算为类型化值，要么延迟为表达式。</span><span class="sxs-lookup"><span data-stu-id="d4754-201">The practical difference between a typical object element and a markup extension is that the markup extension is either evaluated to a typed value or deferred as an expression.</span></span> <span data-ttu-id="d4754-202">因此，标记扩展的属性值的任何可能类型错误的机制都将是不同的，这与在其他编程模型中处理后期绑定属性的方式类似。</span><span class="sxs-lookup"><span data-stu-id="d4754-202">Therefore the mechanisms for any possible type errors of property values for the markup extension will be different, similar to how a late-bound property is treated in other programming models.</span></span> <span data-ttu-id="d4754-203">普通对象元素将针对分析 XAML 时它设置的目标属性进行类型匹配计算。</span><span class="sxs-lookup"><span data-stu-id="d4754-203">An ordinary object element will be evaluated for type match against the target property it is setting when the XAML is parsed.</span></span>  
  
 <span data-ttu-id="d4754-204">当用在对象元素语法中以填充属性元素时，大多数标记扩展都不会包含任何内容或深层属性元素语法。</span><span class="sxs-lookup"><span data-stu-id="d4754-204">Most markup extensions, when used in object element syntax to fill a property element, would not have content or any further property element syntax within.</span></span> <span data-ttu-id="d4754-205">这样你便可以关闭对象元素标记，而不提供任何子元素。</span><span class="sxs-lookup"><span data-stu-id="d4754-205">Thus you would close the object element tag, and provide no child elements.</span></span> <span data-ttu-id="d4754-206">不论何时 XAML 处理器遇到任何对象元素，都会调用该类的构造函数来实例化从已分析元素创建的对象。</span><span class="sxs-lookup"><span data-stu-id="d4754-206">Whenever any object element is encountered by a XAML processor, the constructor for that class is called, which instantiates the object created from the parsed element.</span></span> <span data-ttu-id="d4754-207">标记扩展类没有区别：如果希望标记扩展可用于对象元素语法，则必须提供无参数的构造函数。</span><span class="sxs-lookup"><span data-stu-id="d4754-207">A markup extension class is no different: if you want your markup extension to be usable in object element syntax, you must provide a parameterless constructor.</span></span> <span data-ttu-id="d4754-208">有些现有标记扩展具有至少一个必需的属性值，必须指定该属性值才能使实例化生效。</span><span class="sxs-lookup"><span data-stu-id="d4754-208">Some existing markup extensions have at least one required property value that must be specified for effective initialization.</span></span> <span data-ttu-id="d4754-209">如果是这样，该属性值通常会作为对象元素上的属性特性而给出。</span><span class="sxs-lookup"><span data-stu-id="d4754-209">If so, that property value is typically given as a property attribute on the object element.</span></span> <span data-ttu-id="d4754-210">在 [XAML 命名空间 (x:) 语言功能](/dotnet/desktop-wpf/xaml-services/namespace-language-features)和 [WPF XAML 扩展](wpf-xaml-extensions.md)参考页中，会指出具有必需属性的标记扩展（以及必需属性的名称）。</span><span class="sxs-lookup"><span data-stu-id="d4754-210">In the [XAML Namespace (x:) Language Features](/dotnet/desktop-wpf/xaml-services/namespace-language-features) and [WPF XAML Extensions](wpf-xaml-extensions.md) reference pages, markup extensions that have required properties (and the names of required properties) will be noted.</span></span> <span data-ttu-id="d4754-211">参考页还将指出特定标记扩展是否禁止使用对象元素语法或特性语法。</span><span class="sxs-lookup"><span data-stu-id="d4754-211">Reference pages will also note if either object element syntax or attribute syntax is disallowed for particular markup extensions.</span></span> <span data-ttu-id="d4754-212">需要注意 [x:Array 标记扩展](/dotnet/desktop-wpf/xaml-services/xarray-markup-extension)，它无法支持特性语法，因为该数组的内容必须在标记内作为内容指定。</span><span class="sxs-lookup"><span data-stu-id="d4754-212">A notable case is [x:Array Markup Extension](/dotnet/desktop-wpf/xaml-services/xarray-markup-extension), which cannot support attribute syntax because the contents of that array must be specified within the tagging as content.</span></span> <span data-ttu-id="d4754-213">数组内容的处理方式与常规对象一样，因此特性可以没有默认的类型转换器。</span><span class="sxs-lookup"><span data-stu-id="d4754-213">The array contents are handled as general objects, therefore no default type converter for the attribute is feasible.</span></span> <span data-ttu-id="d4754-214">此外，[x:Array 标记扩展](/dotnet/desktop-wpf/xaml-services/xarray-markup-extension)需要 `type` 参数。</span><span class="sxs-lookup"><span data-stu-id="d4754-214">Also, [x:Array Markup Extension](/dotnet/desktop-wpf/xaml-services/xarray-markup-extension) requires a `type` parameter.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d4754-215">另请参阅</span><span class="sxs-lookup"><span data-stu-id="d4754-215">See also</span></span>

- [<span data-ttu-id="d4754-216">XAML 概述 (WPF)</span><span class="sxs-lookup"><span data-stu-id="d4754-216">XAML Overview (WPF)</span></span>](/dotnet/desktop-wpf/fundamentals/xaml)
- [<span data-ttu-id="d4754-217">XAML 命名空间 (x:)语言功能</span><span class="sxs-lookup"><span data-stu-id="d4754-217">XAML Namespace (x:) Language Features</span></span>](/dotnet/desktop-wpf/xaml-services/namespace-language-features)
- [<span data-ttu-id="d4754-218">WPF XAML 扩展</span><span class="sxs-lookup"><span data-stu-id="d4754-218">WPF XAML Extensions</span></span>](wpf-xaml-extensions.md)
- [<span data-ttu-id="d4754-219">StaticResource 标记扩展</span><span class="sxs-lookup"><span data-stu-id="d4754-219">StaticResource Markup Extension</span></span>](staticresource-markup-extension.md)
- [<span data-ttu-id="d4754-220">绑定标记扩展</span><span class="sxs-lookup"><span data-stu-id="d4754-220">Binding Markup Extension</span></span>](binding-markup-extension.md)
- [<span data-ttu-id="d4754-221">DynamicResource 标记扩展</span><span class="sxs-lookup"><span data-stu-id="d4754-221">DynamicResource Markup Extension</span></span>](dynamicresource-markup-extension.md)
- [<span data-ttu-id="d4754-222">x:Type 标记扩展</span><span class="sxs-lookup"><span data-stu-id="d4754-222">x:Type Markup Extension</span></span>](/dotnet/desktop-wpf/xaml-services/xtype-markup-extension)
