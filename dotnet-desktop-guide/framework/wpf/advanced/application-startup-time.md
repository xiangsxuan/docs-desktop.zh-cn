---
title: 应用程序启动时间
ms.date: 03/30/2017
helpviewer_keywords:
- splash screen [WPF], startup time
- WPF [WPF], startup time
- startup time [WPF]
- application startup [WPF]
- performance [WPF], startup time
ms.assetid: f0ec58d8-626f-4d8a-9873-c20f95e08b96
ms.openlocfilehash: effcc40800ed12e26c2594a11c210cc926743778
ms.sourcegitcommit: 9f6df084c53a3da0ea657ed0d708a72213683084
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/09/2020
ms.locfileid: "96973154"
---
# <a name="application-startup-time"></a><span data-ttu-id="0dbc5-102">应用程序启动时间</span><span class="sxs-lookup"><span data-stu-id="0dbc5-102">Application Startup Time</span></span>
<span data-ttu-id="0dbc5-103">启动 WPF 应用程序所需的时间可能存在极大差异。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-103">The amount of time that is required for a WPF application to start can vary greatly.</span></span> <span data-ttu-id="0dbc5-104">本主题介绍用于减少 Windows Presentation Foundation (WPF) 应用程序假设启动时间和实际启动时间的各种技巧。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-104">This topic describes various techniques for reducing the perceived and actual startup time for a Windows Presentation Foundation (WPF) application.</span></span>  
  
## <a name="understanding-cold-startup-and-warm-startup"></a><span data-ttu-id="0dbc5-105">了解冷启动和热启动</span><span class="sxs-lookup"><span data-stu-id="0dbc5-105">Understanding Cold Startup and Warm Startup</span></span>  
 <span data-ttu-id="0dbc5-106">冷启动发生在系统重启后第一次启动应用程序时，或启动应用程序、将其关闭，然后在很长一段时间后再次启动应用程序时。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-106">Cold startup occurs when your application starts for the first time after a system reboot, or when you start your application, close it, and then start it again after a long period of time.</span></span> <span data-ttu-id="0dbc5-107">应用程序启动时，如果所需的页面（代码、静态数据、注册表等）不在 Windows 内存管理器的待机列表中，会发生页面错误。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-107">When an application starts, if the required pages (code, static data, registry, etc) are not present in the Windows memory manager's standby list, page faults occur.</span></span> <span data-ttu-id="0dbc5-108">需要磁盘访问权限，以便将这些页面加载到内存中。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-108">Disk access is required to bring the pages into memory.</span></span>  
  
 <span data-ttu-id="0dbc5-109">当已将主要公共语言运行时 (CLR) 组件的大多数页面加载到内存中时，则发生热启动，这样可节省宝贵的磁盘访问时间。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-109">Warm startup occurs when most of the pages for the main common language runtime (CLR) components are already loaded in memory, which saves expensive disk access time.</span></span> <span data-ttu-id="0dbc5-110">这就是为什么再次运行托管的应用程序时，该程序的启动速度更快的原因。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-110">That is why a managed application starts faster when it runs a second time.</span></span>  
  
## <a name="implement-a-splash-screen"></a><span data-ttu-id="0dbc5-111">实现初始屏幕</span><span class="sxs-lookup"><span data-stu-id="0dbc5-111">Implement a Splash Screen</span></span>  
 <span data-ttu-id="0dbc5-112">为应对在启动应用程序后到显示第一个 UI 期间出现重大的、不可避免的延迟的情况，请使用“初始屏幕”优化假设的启动时间。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-112">In cases where there is a significant, unavoidable delay between starting an application and displaying the first UI, optimize the perceived startup time by using a *splash screen*.</span></span> <span data-ttu-id="0dbc5-113">通过此方法，在用户启动应用程序后，几乎可以立即显示图像。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-113">This approach displays an image almost immediately after the user starts the application.</span></span> <span data-ttu-id="0dbc5-114">当应用程序准备好显示其第一个 UI 时，初始屏幕将淡化。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-114">When the application is ready to display its first UI, the splash screen fades.</span></span> <span data-ttu-id="0dbc5-115">从 .NET Framework 3.5 SP1 开始，可以使用 <xref:System.Windows.SplashScreen> 类实现初始屏幕。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-115">Starting in the .NET Framework 3.5 SP1, you can use the <xref:System.Windows.SplashScreen> class to implement a splash screen.</span></span> <span data-ttu-id="0dbc5-116">有关详细信息，请参阅[将初始屏幕添加到 WPF 应用程序](../app-development/how-to-add-a-splash-screen-to-a-wpf-application.md)。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-116">For more information, see [Add a Splash Screen to a WPF Application](../app-development/how-to-add-a-splash-screen-to-a-wpf-application.md).</span></span>  
  
 <span data-ttu-id="0dbc5-117">还可以通过使用本机 Win32 图形来实现自己的初始屏幕。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-117">You can also implement your own splash screen by using native Win32 graphics.</span></span> <span data-ttu-id="0dbc5-118">在调用方法之前显示你的实现 <xref:System.Windows.Application.Run%2A> 。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-118">Display your implementation before the <xref:System.Windows.Application.Run%2A> method is called.</span></span>  
  
## <a name="analyze-the-startup-code"></a><span data-ttu-id="0dbc5-119">分析启动代码</span><span class="sxs-lookup"><span data-stu-id="0dbc5-119">Analyze the Startup Code</span></span>  
 <span data-ttu-id="0dbc5-120">确定冷启动慢的原因。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-120">Determine the reason for a slow cold startup.</span></span> <span data-ttu-id="0dbc5-121">可能与磁盘 I/O 有关，但这并非唯一的原因。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-121">Disk I/O may be responsible, but this is not always the case.</span></span> <span data-ttu-id="0dbc5-122">一般情况下，应将外部资源（例如网络、Web 服务或磁盘）的使用率最小化。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-122">In general, you should minimize the use of external resources, such as network, Web services, or disk.</span></span>  
  
 <span data-ttu-id="0dbc5-123">在测试之前，验证没有其他正在运行的应用程序或服务会使用托管代码或 WPF 代码。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-123">Before you test, verify that no other running applications or services use managed code or WPF code.</span></span>  
  
 <span data-ttu-id="0dbc5-124">重新启动后，立即启动 WPF 应用程序，并决定用于显示的时间。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-124">Start your WPF application immediately after a reboot, and determine how long it takes to display.</span></span> <span data-ttu-id="0dbc5-125">如果应用程序的所有后续启动（热启动）相较之下快很多，则冷启动问题很可能是 I/O 所致。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-125">If all subsequent launches of your application (warm startup) are much faster, your cold startup issue is most likely caused by I/O.</span></span>  
  
 <span data-ttu-id="0dbc5-126">如果应用程序的冷启动问题与 I/O 无关，则冷启动慢的原因很可能是应用程序在启动时会执行一些耗时较长的初始化进程或计算、等待某些事件完成或需要大量的 JIT 编译。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-126">If your application's cold startup issue is not related to I/O, it is likely that your application performs some lengthy initialization or computation, waits for some event to complete, or requires a lot of JIT compilation at startup.</span></span> <span data-ttu-id="0dbc5-127">以下章节对其中某些情况进行了详细介绍。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-127">The following sections describe some of these situations in more detail.</span></span>  
  
## <a name="optimize-module-loading"></a><span data-ttu-id="0dbc5-128">优化模块加载</span><span class="sxs-lookup"><span data-stu-id="0dbc5-128">Optimize Module Loading</span></span>  
 <span data-ttu-id="0dbc5-129">使用工具（例如进程资源管理器 (Procexp.exe) 和 Tlist.exe）来确定应用程序加载的模块。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-129">Use tools such as Process Explorer (Procexp.exe) and Tlist.exe to determine which modules your application loads.</span></span> <span data-ttu-id="0dbc5-130">命令 `Tlist <pid>` 显示由某一进程加载的所有模块。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-130">The command `Tlist <pid>` shows all the modules that are loaded by a process.</span></span>  
  
 <span data-ttu-id="0dbc5-131">例如，如果没有连接到 Web，并且发现已加载 System.Web.dll，则应用程序中存在引用此程序集的模块。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-131">For example, if you are not connecting to the Web and you see that System.Web.dll is loaded, then there is a module in your application that references this assembly.</span></span> <span data-ttu-id="0dbc5-132">检查以确定该引用是必要的。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-132">Check to make sure that the reference is necessary.</span></span>  
  
 <span data-ttu-id="0dbc5-133">如果应用程序具有多个模块，则请将其合并为单个模块。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-133">If your application has multiple modules, merge them into a single module.</span></span> <span data-ttu-id="0dbc5-134">此方法要求较少的 CLR 程序集加载开销。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-134">This approach requires less CLR assembly-loading overhead.</span></span> <span data-ttu-id="0dbc5-135">较少的程序集还意味着 CLR 维护较少的状态。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-135">Fewer assemblies also mean that the CLR maintains less state.</span></span>  
  
## <a name="defer-initialization-operations"></a><span data-ttu-id="0dbc5-136">延迟初始化操作</span><span class="sxs-lookup"><span data-stu-id="0dbc5-136">Defer Initialization Operations</span></span>  
 <span data-ttu-id="0dbc5-137">请考虑将初始化代码延迟至主应用程序窗口呈现之后。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-137">Consider postponing initialization code until after the main application window is rendered.</span></span>  
  
 <span data-ttu-id="0dbc5-138">请注意，可能会在类构造函数内执行初始化，如果初始化代码引用其他类，则可能会导致级联效应（执行许多类构造函数）。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-138">Be aware that initialization may be performed inside a class constructor, and if the initialization code references other classes, it can cause a cascading effect in which many class constructors are executed.</span></span>  
  
## <a name="avoid-application-configuration"></a><span data-ttu-id="0dbc5-139">避免应用程序配置</span><span class="sxs-lookup"><span data-stu-id="0dbc5-139">Avoid Application Configuration</span></span>  
 <span data-ttu-id="0dbc5-140">请考虑避免应用程序配置。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-140">Consider avoiding application configuration.</span></span> <span data-ttu-id="0dbc5-141">例如，如果某一应用程序具有简单的配置要求，并且具有严格的启动时间目标，则注册表项或简单的 INI 文件可能是更快的启动替代方法。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-141">For example, if an application has simple configuration requirements and has strict startup time goals, registry entries or a simple INI file may be a faster startup alternative.</span></span>  
  
## <a name="utilize-the-gac"></a><span data-ttu-id="0dbc5-142">利用 GAC</span><span class="sxs-lookup"><span data-stu-id="0dbc5-142">Utilize the GAC</span></span>  
 <span data-ttu-id="0dbc5-143">如果未在全局程序集缓存 (GAC) 中安装程序集，则将出现由强命名程序集的哈希验证和 Ngen 映像验证（如果计算机上该程序集的本机映像可用）导致的延迟。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-143">If an assembly is not installed in the Global Assembly Cache (GAC), there are delays caused by hash verification of strong-named assemblies and by Ngen image validation if a native image for that assembly is available on the computer.</span></span> <span data-ttu-id="0dbc5-144">对于安装到 GAC 中的所有程序集，会跳过强命名验证。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-144">Strong-name verification is skipped for all assemblies installed in the GAC.</span></span> <span data-ttu-id="0dbc5-145">有关详细信息，请参阅 [Gacutil.exe（全局程序集缓存工具）](/dotnet/framework/tools/gacutil-exe-gac-tool)。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-145">For more information, see [Gacutil.exe (Global Assembly Cache Tool)](/dotnet/framework/tools/gacutil-exe-gac-tool).</span></span>  
  
## <a name="use-ngenexe"></a><span data-ttu-id="0dbc5-146">使用 Ngen.exe</span><span class="sxs-lookup"><span data-stu-id="0dbc5-146">Use Ngen.exe</span></span>  
 <span data-ttu-id="0dbc5-147">请考虑在应用程序上使用本机映像生成器 (Ngen.exe)。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-147">Consider using the Native Image Generator (Ngen.exe) on your application.</span></span> <span data-ttu-id="0dbc5-148">使用 Ngen.exe 意味着通过减少 CPU 消耗来实现更多的磁盘访问，因为由 Ngen.exe 生成的本机映像可能会比 MSIL 映像要大。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-148">Using Ngen.exe means trading CPU consumption for more disk access because the native image generated by Ngen.exe is likely to be larger than the MSIL image.</span></span>  
  
 <span data-ttu-id="0dbc5-149">若要减少热启动时间，则应在应用程序上始终使用 Ngen.exe，因为这可以避免应用程序代码的 JIT 编译的 CPU 成本。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-149">To improve the warm startup time, you should always use Ngen.exe on your application, because this avoids the CPU cost of JIT compilation of the application code.</span></span>  
  
 <span data-ttu-id="0dbc5-150">在某些冷启动方案中，使用 Ngen.exe 也会有所帮助。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-150">In some cold startup scenarios, using Ngen.exe can also be helpful.</span></span> <span data-ttu-id="0dbc5-151">这是因为不需要加载 JIT 编译器 (mscorjit.dll)。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-151">This is because the JIT compiler (mscorjit.dll) does not have to be loaded.</span></span>  
  
 <span data-ttu-id="0dbc5-152">同时具有 Ngen 和 JIT 模块可能会导致最差的效果。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-152">Having both Ngen and JIT modules can have the worst effect.</span></span> <span data-ttu-id="0dbc5-153">这是因为必须加载 mscorjit.dll，且当 JIT 编译器处理代码时，当编译器读取程序集的元数据时，必须访问 Ngen 映像中的许多页面。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-153">This is because mscorjit.dll must be loaded, and when the JIT compiler works on your code, many pages in the Ngen images must be accessed when the JIT compiler reads the assemblies' metadata.</span></span>  
  
### <a name="ngen-and-clickonce"></a><span data-ttu-id="0dbc5-154">Ngen 和 ClickOnce</span><span class="sxs-lookup"><span data-stu-id="0dbc5-154">Ngen and ClickOnce</span></span>  
 <span data-ttu-id="0dbc5-155">计划用于部署应用程序的方法在加载期间也会造成影响。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-155">The way you plan to deploy your application can also make a difference in load time.</span></span> <span data-ttu-id="0dbc5-156">ClickOnce 应用程序部署不支持 Ngen。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-156">ClickOnce application deployment does not support Ngen.</span></span> <span data-ttu-id="0dbc5-157">如果决定对应用程序使用 Ngen.exe，则需要使用其他部署机制，如 Windows Installer。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-157">If you decide to use Ngen.exe for your application, you will have to use another deployment mechanism, such as Windows Installer.</span></span>  
  
 <span data-ttu-id="0dbc5-158">有关详细信息，请参阅 [Ngen.exe（本机映像生成器）](/dotnet/framework/tools/ngen-exe-native-image-generator)。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-158">For more information, see [Ngen.exe (Native Image Generator)](/dotnet/framework/tools/ngen-exe-native-image-generator).</span></span>  
  
### <a name="rebasing-and-dll-address-collisions"></a><span data-ttu-id="0dbc5-159">基址重置和 DLL 地址冲突</span><span class="sxs-lookup"><span data-stu-id="0dbc5-159">Rebasing and DLL Address Collisions</span></span>  
 <span data-ttu-id="0dbc5-160">如果使用 Ngen.exe，请注意，本机映像加载到内存中时可能会发生基址重置。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-160">If you use Ngen.exe, be aware that rebasing can occur when the native images are loaded in memory.</span></span> <span data-ttu-id="0dbc5-161">如果未在 DLL 首选基址加载该 DLL（由于已分配该地址范围），则 Windows 加载程序将在另一地址加载该 DLL，这可能是一个耗时的操作。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-161">If a DLL is not loaded at its preferred base address because that address range is already allocated, the Windows loader will load it at another address, which can be a time-consuming operation.</span></span>  
  
 <span data-ttu-id="0dbc5-162">可以使用虚拟地址转储 (Vadump.exe) 工具来检查是否存在其中所有页面都为私有的模块。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-162">You can use the Virtual Address Dump (Vadump.exe) tool to check if there are modules in which all the pages are private.</span></span> <span data-ttu-id="0dbc5-163">如果是这种情况，则可能已将该模块的基址重置到另一地址。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-163">If this is the case, the module may have been rebased to a different address.</span></span> <span data-ttu-id="0dbc5-164">因此，不能共享其页面。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-164">Therefore, its pages cannot be shared.</span></span>  
  
 <span data-ttu-id="0dbc5-165">有关如何设置基址的详细信息，请参阅 [Ngen.exe（本机映像生成器）](/dotnet/framework/tools/ngen-exe-native-image-generator)。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-165">For more information about how to set the base address, see [Ngen.exe (Native Image Generator)](/dotnet/framework/tools/ngen-exe-native-image-generator).</span></span>  
  
## <a name="optimize-authenticode"></a><span data-ttu-id="0dbc5-166">优化验证码</span><span class="sxs-lookup"><span data-stu-id="0dbc5-166">Optimize Authenticode</span></span>  
 <span data-ttu-id="0dbc5-167">验证码验证会增加启动时间。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-167">Authenticode verification adds to the startup time.</span></span> <span data-ttu-id="0dbc5-168">验证码签名的程序集必须通过证书颁发机构 (CA) 验证。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-168">Authenticode-signed assemblies have to be verified with the certification authority (CA).</span></span> <span data-ttu-id="0dbc5-169">此验证可能需要较长时间，因为它可能会要求多次连接到网络，以便下载当前证书吊销列表。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-169">This verification can be time consuming, because it can require connecting to the network several times to download current certificate revocation lists.</span></span> <span data-ttu-id="0dbc5-170">它还确保受信任的根路径上存在完整的有效证书链。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-170">It also makes sure that there is a full chain of valid certificates on the path to a trusted root.</span></span> <span data-ttu-id="0dbc5-171">在加载程序集时，这可能会导致几秒钟的延迟。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-171">This can translate to several seconds of delay while the assembly is being loaded.</span></span>  
  
 <span data-ttu-id="0dbc5-172">请考虑在客户端计算机上安装 CA 证书，或尽可能避免使用验证码。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-172">Consider installing the CA certificate on the client computer, or avoid using Authenticode when it is possible.</span></span> <span data-ttu-id="0dbc5-173">如果知道应用程序不需要发布服务器证据，则无需支付签名验证的费用。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-173">If you know that your application does not need the publisher evidence, you do not have to pay the cost of signature verification.</span></span>  
  
 <span data-ttu-id="0dbc5-174">从 .NET Framework 3.5 开始，有一个配置选项允许绕过 Authenticode 验证。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-174">Starting in .NET Framework 3.5, there is a configuration option that allows the Authenticode verification to be bypassed.</span></span> <span data-ttu-id="0dbc5-175">为执行此操作，将以下设置添加到 app.exe.config 文件：</span><span class="sxs-lookup"><span data-stu-id="0dbc5-175">To do this, add the following setting to the app.exe.config file:</span></span>  
  
```xml  
<configuration>  
    <runtime>  
        <generatePublisherEvidence enabled="false"/>
    </runtime>  
</configuration>  
```  
  
 <span data-ttu-id="0dbc5-176">有关详细信息，请参阅 [\<generatePublisherEvidence> 元素](/dotnet/framework/configure-apps/file-schema/runtime/generatepublisherevidence-element)。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-176">For more information, see [\<generatePublisherEvidence> Element](/dotnet/framework/configure-apps/file-schema/runtime/generatepublisherevidence-element).</span></span>  
  
## <a name="compare-performance-on-windows-vista"></a><span data-ttu-id="0dbc5-177">在 Windows Vista 上比较性能</span><span class="sxs-lookup"><span data-stu-id="0dbc5-177">Compare Performance on Windows Vista</span></span>  
 <span data-ttu-id="0dbc5-178">Windows Vista 中的内存管理器具有一种名为 SuperFetch 的技术。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-178">The memory manager in Windows Vista has a technology called SuperFetch.</span></span> <span data-ttu-id="0dbc5-179">SuperFetch 可随时间推移分析内存使用情况模式，从而确定特定用户的最优内存内容。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-179">SuperFetch analyzes memory usage patterns over time to determine the optimal memory content for a specific user.</span></span> <span data-ttu-id="0dbc5-180">它会持续工作，不间断地维护此内容。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-180">It works continuously to maintain that content at all times.</span></span>  
  
 <span data-ttu-id="0dbc5-181">这种方法不同于 Windows XP 中使用的预提取技术，后者将数据预先加载到内存，而不分析使用情况模式。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-181">This approach differs from the pre-fetch technique used in Windows XP, which preloads data into memory without analyzing usage patterns.</span></span> <span data-ttu-id="0dbc5-182">随着时间的推移，如果用户在 Windows Vista 上频繁使用 WPF 应用程序，则可能改善应用程序的冷启动时间。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-182">Over time, if the user uses your WPF application frequently on Windows Vista, the cold startup time of your application may improve.</span></span>  
  
## <a name="use-appdomains-efficiently"></a><span data-ttu-id="0dbc5-183">有效使用 AppDomains</span><span class="sxs-lookup"><span data-stu-id="0dbc5-183">Use AppDomains Efficiently</span></span>  
 <span data-ttu-id="0dbc5-184">如果可能，将程序集加载到非特定于域的代码区域，以确保本机映像（如果存在）会在应用程序中创建的所有 AppDomain 中使用。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-184">If possible, load assemblies into a domain-neutral code area to make sure that the native image, if one exists, is used in all AppDomains created in the application.</span></span>  
  
 <span data-ttu-id="0dbc5-185">为获得最佳性能，通过减少跨域调用强制实施高效跨域通信。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-185">For the best performance, enforce efficient cross-domain communication by reducing cross-domain calls.</span></span> <span data-ttu-id="0dbc5-186">如果可能，请使用不带参数或具有基元类型参数的调用。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-186">When possible, use calls without arguments or with primitive type arguments.</span></span>  
  
## <a name="use-the-neutralresourceslanguage-attribute"></a><span data-ttu-id="0dbc5-187">使用 NeutralResourcesLanguage 特性</span><span class="sxs-lookup"><span data-stu-id="0dbc5-187">Use the NeutralResourcesLanguage Attribute</span></span>  
 <span data-ttu-id="0dbc5-188">使用 <xref:System.Resources.NeutralResourcesLanguageAttribute> 指定的非特定区域性 <xref:System.Resources.ResourceManager> 。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-188">Use the <xref:System.Resources.NeutralResourcesLanguageAttribute> to specify the neutral culture for the <xref:System.Resources.ResourceManager>.</span></span> <span data-ttu-id="0dbc5-189">此方法可避免程序集查找失败。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-189">This approach avoids unsuccessful assembly lookups.</span></span>  
  
## <a name="use-the-binaryformatter-class-for-serialization"></a><span data-ttu-id="0dbc5-190">将 BinaryFormatter 类用于序列化</span><span class="sxs-lookup"><span data-stu-id="0dbc5-190">Use the BinaryFormatter Class for Serialization</span></span>  
 <span data-ttu-id="0dbc5-191">如果必须使用序列化，请使用 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 类，而不是 <xref:System.Xml.Serialization.XmlSerializer> 类。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-191">If you must use serialization, use the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> class instead of the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="0dbc5-192">在 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 基类库中实现类 (mscorlib.dll 程序集中的 BCL) 。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-192">The <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> class is implemented in the Base Class Library (BCL) in the mscorlib.dll assembly.</span></span> <span data-ttu-id="0dbc5-193"><xref:System.Xml.Serialization.XmlSerializer>是在 System.Xml.dll 程序集中实现的，该程序集可能是要加载的其他 DLL。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-193">The <xref:System.Xml.Serialization.XmlSerializer> is implemented in the System.Xml.dll assembly, which might be an additional DLL to load.</span></span>  
  
 <span data-ttu-id="0dbc5-194">如果你必须使用 <xref:System.Xml.Serialization.XmlSerializer> 类，则在预生成序列化程序集时，可以获得更好的性能。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-194">If you must use the <xref:System.Xml.Serialization.XmlSerializer> class, you can achieve better performance if you pre-generate the serialization assembly.</span></span>  
  
## <a name="configure-clickonce-to-check-for-updates-after-startup"></a><span data-ttu-id="0dbc5-195">将 ClickOnce 配置为在启动后检查更新</span><span class="sxs-lookup"><span data-stu-id="0dbc5-195">Configure ClickOnce to Check for Updates After Startup</span></span>  
 <span data-ttu-id="0dbc5-196">如果你的应用程序使用 ClickOnce，请在启动时配置 ClickOnce 以检查部署站点是否有更新，以避免在启动时进行网络访问。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-196">If your application uses ClickOnce, avoid network access on startup by configuring ClickOnce to check the deployment site for updates after the application starts.</span></span>  
  
 <span data-ttu-id="0dbc5-197">如果使用 XAML 浏览器应用程序 (XBAP) 模型，请记住，即使 XBAP 已在 ClickOnce 缓存中，ClickOnce 也会检查部署站点是否有更新。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-197">If you use the XAML browser application (XBAP) model, keep in mind that ClickOnce checks the deployment site for updates even if the XBAP is already in the ClickOnce cache.</span></span> <span data-ttu-id="0dbc5-198">有关详细信息，请参阅 [ClickOnce Security and Deployment](/visualstudio/deployment/clickonce-security-and-deployment)。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-198">For more information, see [ClickOnce Security and Deployment](/visualstudio/deployment/clickonce-security-and-deployment).</span></span>  
  
## <a name="configure-the-presentationfontcache-service-to-start-automatically"></a><span data-ttu-id="0dbc5-199">将 PresentationFontCache 服务配置为自动启动</span><span class="sxs-lookup"><span data-stu-id="0dbc5-199">Configure the PresentationFontCache Service to Start Automatically</span></span>  
 <span data-ttu-id="0dbc5-200">在重新启动后，要运行的第一个 WPF 应用程序是 PresentationFontCache 服务。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-200">The first WPF application to run after a reboot is the PresentationFontCache service.</span></span> <span data-ttu-id="0dbc5-201">该服务会缓存系统字体、改进字体访问，并提高整体性能。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-201">The service caches the system fonts, improves font access, and improves overall performance.</span></span> <span data-ttu-id="0dbc5-202">在启动服务时会产生开销，某些受控环境中也存在开销，请考虑将服务配置为在系统重启时自动启动。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-202">There is an overhead in starting the service, and in some controlled environments, consider configuring the service to start automatically when the system reboots.</span></span>  
  
## <a name="set-data-binding-programmatically"></a><span data-ttu-id="0dbc5-203">以编程方式设置数据绑定</span><span class="sxs-lookup"><span data-stu-id="0dbc5-203">Set Data Binding Programmatically</span></span>  
 <span data-ttu-id="0dbc5-204"><xref:System.Windows.FrameworkElement.DataContext%2A>请考虑在方法中以编程方式设置主窗口，而不是使用 XAML 以声明方式设置 <xref:System.Windows.Application.OnActivated%2A> 。</span><span class="sxs-lookup"><span data-stu-id="0dbc5-204">Instead of using XAML to set the <xref:System.Windows.FrameworkElement.DataContext%2A> declaratively for the main window, consider setting it programmatically in the <xref:System.Windows.Application.OnActivated%2A> method.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="0dbc5-205">另请参阅</span><span class="sxs-lookup"><span data-stu-id="0dbc5-205">See also</span></span>

- <xref:System.Windows.SplashScreen>
- <xref:System.AppDomain>
- <xref:System.Resources.NeutralResourcesLanguageAttribute>
- <xref:System.Resources.ResourceManager>
- [<span data-ttu-id="0dbc5-206">向 WPF 应用程序添加初始屏幕</span><span class="sxs-lookup"><span data-stu-id="0dbc5-206">Add a Splash Screen to a WPF Application</span></span>](../app-development/how-to-add-a-splash-screen-to-a-wpf-application.md)
- [<span data-ttu-id="0dbc5-207">Ngen.exe（本机映像生成器）</span><span class="sxs-lookup"><span data-stu-id="0dbc5-207">Ngen.exe (Native Image Generator)</span></span>](/dotnet/framework/tools/ngen-exe-native-image-generator)
- [<span data-ttu-id="0dbc5-208">\<generatePublisherEvidence> 元素</span><span class="sxs-lookup"><span data-stu-id="0dbc5-208">\<generatePublisherEvidence> Element</span></span>](/dotnet/framework/configure-apps/file-schema/runtime/generatepublisherevidence-element)
