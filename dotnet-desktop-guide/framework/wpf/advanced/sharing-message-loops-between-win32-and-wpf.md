---
title: 在 Win32 和 WPF 之间共享消息循环
titleSuffix: ''
ms.date: 03/30/2017
helpviewer_keywords:
- Win32 code [WPF], sharing message loops
- message loops [WPF]
- sharing message loops [WPF]
- interoperability [WPF], Win32
ms.assetid: 39ee888c-e5ec-41c8-b11f-7b851a554442
ms.openlocfilehash: 029cab8971ae1a57afacb9123ce83fa182d7b083
ms.sourcegitcommit: 069786bcadbf9cd931d7dc3d892262cd852d2ffb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/19/2021
ms.locfileid: "104664920"
---
# <a name="sharing-message-loops-between-win32-and-wpf"></a><span data-ttu-id="da2f2-102">在 Win32 和 WPF 之间共享消息循环</span><span class="sxs-lookup"><span data-stu-id="da2f2-102">Sharing Message Loops Between Win32 and WPF</span></span>
<span data-ttu-id="da2f2-103">本主题介绍如何通过 [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] 使用中的现有消息循环公开 <xref:System.Windows.Threading.Dispatcher> 或通过在互操作代码的 Win32 端创建单独的消息循环来实现与互操作的消息循环。</span><span class="sxs-lookup"><span data-stu-id="da2f2-103">This topic describes how to implement a message loop for interoperation with [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)], either by using existing message loop exposure in <xref:System.Windows.Threading.Dispatcher> or by creating a separate message loop on the Win32 side of your interoperation code.</span></span>  
  
## <a name="componentdispatcher-and-the-message-loop"></a><span data-ttu-id="da2f2-104">ComponentDispatcher 和消息循环</span><span class="sxs-lookup"><span data-stu-id="da2f2-104">ComponentDispatcher and the Message Loop</span></span>  
 <span data-ttu-id="da2f2-105">互操作性和键盘事件支持的普通方案是实现 <xref:System.Windows.Interop.IKeyboardInputSink> ，或从已实现的类（ <xref:System.Windows.Interop.IKeyboardInputSink> 如或）中对子类进行子类化 <xref:System.Windows.Interop.HwndSource> <xref:System.Windows.Interop.HwndHost> 。</span><span class="sxs-lookup"><span data-stu-id="da2f2-105">A normal scenario for interoperation and keyboard event support is to implement <xref:System.Windows.Interop.IKeyboardInputSink>, or to subclass from classes that already implement <xref:System.Windows.Interop.IKeyboardInputSink>, such as <xref:System.Windows.Interop.HwndSource> or <xref:System.Windows.Interop.HwndHost>.</span></span> <span data-ttu-id="da2f2-106">但是，键盘接收器支持并不能解决通过互操作边界发送和接收消息时可能会遇到的所有可能的消息循环需求。</span><span class="sxs-lookup"><span data-stu-id="da2f2-106">However, keyboard sink support does not address all possible message loop needs you might have when sending and receiving messages across your interoperation boundaries.</span></span> <span data-ttu-id="da2f2-107">为了帮助实现应用程序消息循环体系结构的形式， [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] 提供了 <xref:System.Windows.Interop.ComponentDispatcher> 类，该类定义用于消息循环的简单协议。</span><span class="sxs-lookup"><span data-stu-id="da2f2-107">To help formalize an application message loop architecture, [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] provides the <xref:System.Windows.Interop.ComponentDispatcher> class, which defines a simple protocol for a message loop to follow.</span></span>  
  
 <span data-ttu-id="da2f2-108"><xref:System.Windows.Interop.ComponentDispatcher> 是公开多个成员的静态类。</span><span class="sxs-lookup"><span data-stu-id="da2f2-108"><xref:System.Windows.Interop.ComponentDispatcher> is a static class that exposes several members.</span></span> <span data-ttu-id="da2f2-109">每个方法的范围都隐式绑定到调用线程。</span><span class="sxs-lookup"><span data-stu-id="da2f2-109">The scope of each method is implicitly tied to the calling thread.</span></span> <span data-ttu-id="da2f2-110">消息循环必须在关键时间调用其中的某些 Api (如下一节) 所定义。</span><span class="sxs-lookup"><span data-stu-id="da2f2-110">A message loop must call some of those APIs at critical times (as defined in the next section).</span></span>  
  
 <span data-ttu-id="da2f2-111"><xref:System.Windows.Interop.ComponentDispatcher> 提供其他组件 (如) 可以侦听的其他组件的事件。</span><span class="sxs-lookup"><span data-stu-id="da2f2-111"><xref:System.Windows.Interop.ComponentDispatcher> provides events that other components (such as the keyboard sink) can listen for.</span></span> <span data-ttu-id="da2f2-112"><xref:System.Windows.Threading.Dispatcher>类以适当的顺序调用所有适当的 <xref:System.Windows.Interop.ComponentDispatcher> 方法。</span><span class="sxs-lookup"><span data-stu-id="da2f2-112">The <xref:System.Windows.Threading.Dispatcher> class calls all the appropriate <xref:System.Windows.Interop.ComponentDispatcher> methods in an appropriate sequence.</span></span> <span data-ttu-id="da2f2-113">如果要实现自己的消息循环，你的代码将负责 <xref:System.Windows.Interop.ComponentDispatcher> 以类似方式调用方法。</span><span class="sxs-lookup"><span data-stu-id="da2f2-113">If you are implementing your own message loop, your code is responsible for calling <xref:System.Windows.Interop.ComponentDispatcher> methods in a similar fashion.</span></span>  
  
 <span data-ttu-id="da2f2-114"><xref:System.Windows.Interop.ComponentDispatcher>对线程调用方法只会调用在该线程上注册的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="da2f2-114">Calling <xref:System.Windows.Interop.ComponentDispatcher> methods on a thread will only invoke event handlers that were registered on that thread.</span></span>  
  
## <a name="writing-message-loops"></a><span data-ttu-id="da2f2-115">写入消息循环</span><span class="sxs-lookup"><span data-stu-id="da2f2-115">Writing Message Loops</span></span>  
 <span data-ttu-id="da2f2-116">下面是你 <xref:System.Windows.Interop.ComponentDispatcher> 编写自己的消息循环时将使用的成员的清单：</span><span class="sxs-lookup"><span data-stu-id="da2f2-116">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you write your own message loop:</span></span>  
  
- <span data-ttu-id="da2f2-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>：消息循环应调用此来指示线程是模式的。</span><span class="sxs-lookup"><span data-stu-id="da2f2-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: your message loop should call this to indicate that the thread is modal.</span></span>  
  
- <span data-ttu-id="da2f2-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>：消息循环应调用此来指示线程已恢复到变成。</span><span class="sxs-lookup"><span data-stu-id="da2f2-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>:your message loop should call this to indicate that the thread has reverted to nonmodal.</span></span>  
  
- <span data-ttu-id="da2f2-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>：消息循环应调用此来指示 <xref:System.Windows.Interop.ComponentDispatcher> 应引发 <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> 事件。</span><span class="sxs-lookup"><span data-stu-id="da2f2-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: your message loop should call this to indicate that <xref:System.Windows.Interop.ComponentDispatcher> should raise the <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> event.</span></span> <span data-ttu-id="da2f2-120"><xref:System.Windows.Interop.ComponentDispatcher> 如果为，则不会引发 <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> `true` ，但消息循环可能会选择调用， <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> 即使 <xref:System.Windows.Interop.ComponentDispatcher> 在处于模式状态时无法对其作出响应。</span><span class="sxs-lookup"><span data-stu-id="da2f2-120"><xref:System.Windows.Interop.ComponentDispatcher> will not raise <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> if <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> is `true`, but message loops may choose to call <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> even if <xref:System.Windows.Interop.ComponentDispatcher> cannot respond to it while in modal state.</span></span>  
  
- <span data-ttu-id="da2f2-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>：消息循环应调用此来指示新消息可用。</span><span class="sxs-lookup"><span data-stu-id="da2f2-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: your message loop should call this to indicate that a new message is available.</span></span> <span data-ttu-id="da2f2-122">返回值指示事件侦听器是否 <xref:System.Windows.Interop.ComponentDispatcher> 处理了该消息。</span><span class="sxs-lookup"><span data-stu-id="da2f2-122">The return value indicates whether a listener to a <xref:System.Windows.Interop.ComponentDispatcher> event handled the message.</span></span> <span data-ttu-id="da2f2-123">如果 <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> `true`)  (处理返回，则调度程序不应对消息进行任何进一步的处理。</span><span class="sxs-lookup"><span data-stu-id="da2f2-123">If <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> returns `true` (handled), the dispatcher should do nothing further with the message.</span></span> <span data-ttu-id="da2f2-124">如果返回值为 `false` ，则调度程序应调用 Win32 函数 `TranslateMessage` ，然后调用 `DispatchMessage` 。</span><span class="sxs-lookup"><span data-stu-id="da2f2-124">If the return value is `false`, the dispatcher is expected to call the Win32 function `TranslateMessage`, then call `DispatchMessage`.</span></span>  
  
## <a name="using-componentdispatcher-and-existing-message-handling"></a><span data-ttu-id="da2f2-125">使用 ComponentDispatcher 和现有消息处理</span><span class="sxs-lookup"><span data-stu-id="da2f2-125">Using ComponentDispatcher and Existing Message Handling</span></span>  
 <span data-ttu-id="da2f2-126">下面是 <xref:System.Windows.Interop.ComponentDispatcher> 依赖于固有消息循环时要使用的成员清单 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="da2f2-126">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you rely on the inherent [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] message loop.</span></span>  
  
- <span data-ttu-id="da2f2-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>：返回应用程序是否已进入模式 (例如，已将模式消息循环推送) 。</span><span class="sxs-lookup"><span data-stu-id="da2f2-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: returns whether the application has gone modal (e.g., a modal message loop has been pushed).</span></span> <span data-ttu-id="da2f2-128"><xref:System.Windows.Interop.ComponentDispatcher> 可以跟踪此状态，因为类维护 <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> 消息循环的计数和 <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> 调用。</span><span class="sxs-lookup"><span data-stu-id="da2f2-128"><xref:System.Windows.Interop.ComponentDispatcher> can track this state because the class maintains a count of <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> and <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> calls from the message loop.</span></span>  
  
- <span data-ttu-id="da2f2-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> 和 <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> 事件遵循委托调用的标准规则。</span><span class="sxs-lookup"><span data-stu-id="da2f2-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> and <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> events follow the standard rules for delegate invocations.</span></span> <span data-ttu-id="da2f2-130">委托按未指定的顺序进行调用，即使第一个委托将消息标记为已处理，也会调用所有委托。</span><span class="sxs-lookup"><span data-stu-id="da2f2-130">Delegates are invoked in an unspecified order, and all delegates are invoked even if the first one marks the message as handled.</span></span>  
  
- <span data-ttu-id="da2f2-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>：指示执行空闲处理的适当且有效的时间 () 没有其他线程的挂起消息。</span><span class="sxs-lookup"><span data-stu-id="da2f2-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: indicates an appropriate and efficient time to do idle processing (there are no other pending messages for the thread).</span></span> <span data-ttu-id="da2f2-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> 如果线程是模式的，则不会引发。</span><span class="sxs-lookup"><span data-stu-id="da2f2-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> will not be raised if the thread is modal.</span></span>  
  
- <span data-ttu-id="da2f2-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>：为消息泵处理的所有消息引发。</span><span class="sxs-lookup"><span data-stu-id="da2f2-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: raised for all messages that the message pump processes.</span></span>  
  
- <span data-ttu-id="da2f2-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>：为在期间未处理的所有消息引发 <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> 。</span><span class="sxs-lookup"><span data-stu-id="da2f2-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: raised for all messages that were not handled during <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span></span>  
  
 <span data-ttu-id="da2f2-135">如果在 <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> 事件或 <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> 事件之后， `handled` 按事件数据中的引用传递的参数为，则将消息视为已处理 `true` 。</span><span class="sxs-lookup"><span data-stu-id="da2f2-135">A message is considered handled if after the <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> event or <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> event, the `handled` parameter passed by reference in event data is `true`.</span></span> <span data-ttu-id="da2f2-136">如果为，事件处理程序应忽略该消息 `handled` `true` ，因为这意味着不同处理程序首先处理该消息。</span><span class="sxs-lookup"><span data-stu-id="da2f2-136">Event handlers should ignore the message if `handled` is `true`, because that means the different handler handled the message first.</span></span> <span data-ttu-id="da2f2-137">这两个事件的事件处理程序可能会修改消息。</span><span class="sxs-lookup"><span data-stu-id="da2f2-137">Event handlers to both events may modify the message.</span></span> <span data-ttu-id="da2f2-138">调度程序应调度已修改的消息，而不是原始的未更改消息。</span><span class="sxs-lookup"><span data-stu-id="da2f2-138">The dispatcher should dispatch the modified message and not the original unchanged message.</span></span> <span data-ttu-id="da2f2-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> 传递给所有侦听器，但体系结构目的在于，只有包含目标的 HWND 的顶级窗口才能调用代码来响应消息。</span><span class="sxs-lookup"><span data-stu-id="da2f2-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is delivered to all listeners, but the architectural intention is that only the top-level window containing the HWND at which the messages targeted should invoke code in response to the message.</span></span>  
  
## <a name="how-hwndsource-treats-componentdispatcher-events"></a><span data-ttu-id="da2f2-140">HwndSource 如何处理 ComponentDispatcher 事件</span><span class="sxs-lookup"><span data-stu-id="da2f2-140">How HwndSource Treats ComponentDispatcher Events</span></span>  
 <span data-ttu-id="da2f2-141">如果 <xref:System.Windows.Interop.HwndSource> 是顶级窗口 (没有父 HWND) ，则它将注册到 <xref:System.Windows.Interop.ComponentDispatcher> 。</span><span class="sxs-lookup"><span data-stu-id="da2f2-141">If the <xref:System.Windows.Interop.HwndSource> is a top-level window (no parent HWND), it will register with <xref:System.Windows.Interop.ComponentDispatcher>.</span></span> <span data-ttu-id="da2f2-142">如果 <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> 引发，并且消息是针对 <xref:System.Windows.Interop.HwndSource> 或子窗口的，则 <xref:System.Windows.Interop.HwndSource> 调用其 <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A> 、 <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A> 和 <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> 键盘接收器序列。</span><span class="sxs-lookup"><span data-stu-id="da2f2-142">If <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is raised, and if the message is intended for the <xref:System.Windows.Interop.HwndSource> or child windows, <xref:System.Windows.Interop.HwndSource> calls its <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> keyboard sink sequence.</span></span>  
  
 <span data-ttu-id="da2f2-143">如果不是 <xref:System.Windows.Interop.HwndSource> (具有父 HWND) 的顶级窗口，则将不会进行任何处理。</span><span class="sxs-lookup"><span data-stu-id="da2f2-143">If the <xref:System.Windows.Interop.HwndSource> is not a top-level window (has a parent HWND), there will be no handling.</span></span> <span data-ttu-id="da2f2-144">仅顶级窗口应进行处理，并且在任何互操作方案中，都应有一个包含键盘接收器支持的顶级窗口。</span><span class="sxs-lookup"><span data-stu-id="da2f2-144">Only the top level window is expected to do the handling, and there is expected to be a top level window with keyboard sink support as part of any interoperation scenario.</span></span>  
  
 <span data-ttu-id="da2f2-145">如果 <xref:System.Windows.Interop.HwndHost.WndProc%2A> 在 <xref:System.Windows.Interop.HwndSource> 调用时未首先调用适当的键盘接收器方法，应用程序将接收更高级别的键盘事件，例如 <xref:System.Windows.UIElement.KeyDown> 。</span><span class="sxs-lookup"><span data-stu-id="da2f2-145">If <xref:System.Windows.Interop.HwndHost.WndProc%2A> on an <xref:System.Windows.Interop.HwndSource> is called without an appropriate keyboard sink method being called first, your application will receive the higher level keyboard events such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="da2f2-146">但是，将不会调用键盘接收器方法，这会绕过所需的键盘输入模型功能，如访问密钥支持。</span><span class="sxs-lookup"><span data-stu-id="da2f2-146">However, no keyboard sink methods will be called, which circumvents desirable keyboard input model features such as access key support.</span></span> <span data-ttu-id="da2f2-147">出现这种情况的原因可能是消息循环未正确地通知上的相关线程 <xref:System.Windows.Interop.ComponentDispatcher> ，或父 HWND 未调用正确的键盘接收器响应。</span><span class="sxs-lookup"><span data-stu-id="da2f2-147">This might happen because the message loop did not properly notify the relevant thread on the <xref:System.Windows.Interop.ComponentDispatcher>, or because the parent HWND did not invoke the proper keyboard sink responses.</span></span>  
  
 <span data-ttu-id="da2f2-148">如果使用方法为消息添加了挂钩，则发送到键盘接收器的消息可能不会发送到 HWND <xref:System.Windows.Interop.HwndSource.AddHook%2A> 。</span><span class="sxs-lookup"><span data-stu-id="da2f2-148">A message that goes to the keyboard sink might not be sent to the HWND if you added hooks for that message by using the <xref:System.Windows.Interop.HwndSource.AddHook%2A> method.</span></span> <span data-ttu-id="da2f2-149">消息可能已在消息泵级别直接处理，未提交给 `DispatchMessage` 函数。</span><span class="sxs-lookup"><span data-stu-id="da2f2-149">The message might have been handled at the message pump level directly and not submitted to the `DispatchMessage` function.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="da2f2-150">请参阅</span><span class="sxs-lookup"><span data-stu-id="da2f2-150">See also</span></span>

- <xref:System.Windows.Interop.ComponentDispatcher>
- <xref:System.Windows.Interop.IKeyboardInputSink>
- [<span data-ttu-id="da2f2-151">WPF 和 Win32 互操作</span><span class="sxs-lookup"><span data-stu-id="da2f2-151">WPF and Win32 Interoperation</span></span>](wpf-and-win32-interoperation.md)
- [<span data-ttu-id="da2f2-152">线程模型</span><span class="sxs-lookup"><span data-stu-id="da2f2-152">Threading Model</span></span>](threading-model.md)
- [<span data-ttu-id="da2f2-153">输入概述</span><span class="sxs-lookup"><span data-stu-id="da2f2-153">Input Overview</span></span>](input-overview.md)
