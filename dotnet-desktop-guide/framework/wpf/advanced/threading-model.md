---
title: 线程处理模型
description: 了解 Windows Presentation Foundation 应用程序中可能需要多个线程的情况。 首选单线程解决方案。
ms.date: 03/30/2017
ms.topic: overview
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
ms.openlocfilehash: e984e7b887d86b6426a97285d00619a12974385d
ms.sourcegitcommit: bf5dd80f4d7b202afa90e90d1148402c5474d826
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/30/2021
ms.locfileid: "100101853"
---
# <a name="threading-model"></a><span data-ttu-id="b699c-104">线程处理模型</span><span class="sxs-lookup"><span data-stu-id="b699c-104">Threading Model</span></span>
[!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] <span data-ttu-id="b699c-105">旨在帮助开发人员处理复杂的线程处理问题。</span><span class="sxs-lookup"><span data-stu-id="b699c-105">is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="b699c-106">因此，大多数 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 开发人员无需编写使用多个线程的接口。</span><span class="sxs-lookup"><span data-stu-id="b699c-106">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="b699c-107">由于多线程程序既复杂又难以调试，因此当存在单线程解决方案时，应避免使用多线程程序。</span><span class="sxs-lookup"><span data-stu-id="b699c-107">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>

 <span data-ttu-id="b699c-108">当然，无论架构的设计方式如何， [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 框架都无法为每种类型的问题提供单线程解决方案。</span><span class="sxs-lookup"><span data-stu-id="b699c-108">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="b699c-109">接近，但在某些情况下，多个线程会提高 [!INCLUDE[TLA#tla_ui](../../../includes/tlasharptla-ui-md.md)] 响应能力或应用程序性能。</span><span class="sxs-lookup"><span data-stu-id="b699c-109">comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="b699c-110">基于上文所述的背景材料，本文对上述情况进行探讨，然后通过对一些低级别的细节进行讨论作出总结。</span><span class="sxs-lookup"><span data-stu-id="b699c-110">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>

> [!NOTE]
> <span data-ttu-id="b699c-111">本主题介绍了如何使用 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 异步调用方法进行线程处理。</span><span class="sxs-lookup"><span data-stu-id="b699c-111">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="b699c-112">还可以通过调用 <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> 方法（采用 <xref:System.Action> 或作为参数）进行异步调用 <xref:System.Func%601> 。</span><span class="sxs-lookup"><span data-stu-id="b699c-112">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="b699c-113"><xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A>方法返回 <xref:System.Windows.Threading.DispatcherOperation> 或 <xref:System.Windows.Threading.DispatcherOperation%601> ，它具有 <xref:System.Windows.Threading.DispatcherOperation.Task%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="b699c-113">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="b699c-114">可以将 `await` 关键字与或关联的结合使用 <xref:System.Windows.Threading.DispatcherOperation> <xref:System.Threading.Tasks.Task> 。</span><span class="sxs-lookup"><span data-stu-id="b699c-114">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="b699c-115">如果需要为 <xref:System.Threading.Tasks.Task> 或返回的返回同步 <xref:System.Windows.Threading.DispatcherOperation> <xref:System.Windows.Threading.DispatcherOperation%601> ，请调用 <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> 扩展方法。</span><span class="sxs-lookup"><span data-stu-id="b699c-115">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="b699c-116">调用 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 将导致死锁。</span><span class="sxs-lookup"><span data-stu-id="b699c-116">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="b699c-117">有关使用 <xref:System.Threading.Tasks.Task> 执行异步操作的详细信息，请参阅 [基于任务的异步编程](/dotnet/standard/parallel-programming/task-based-asynchronous-programming)。</span><span class="sxs-lookup"><span data-stu-id="b699c-117">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see [Task-based asynchronous programming](/dotnet/standard/parallel-programming/task-based-asynchronous-programming).</span></span>  <span data-ttu-id="b699c-118"><xref:System.Windows.Threading.Dispatcher.Invoke%2A>方法还具有采用 <xref:System.Action> 或作为参数的重载 <xref:System.Func%601> 。</span><span class="sxs-lookup"><span data-stu-id="b699c-118">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="b699c-119">可以 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 通过传入委托或，使用方法进行同步调用 <xref:System.Action> <xref:System.Func%601> 。</span><span class="sxs-lookup"><span data-stu-id="b699c-119">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>

<a name="threading_overview"></a>
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="b699c-120">概述和调度程序</span><span class="sxs-lookup"><span data-stu-id="b699c-120">Overview and the Dispatcher</span></span>
 <span data-ttu-id="b699c-121">通常， [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 应用程序从两个线程开始：一个用于处理渲染，另一个用于管理 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="b699c-121">Typically, [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="b699c-122">当 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 线程接收输入、处理事件、绘制屏幕和运行应用程序代码时，呈现线程在后台有效地运行。</span><span class="sxs-lookup"><span data-stu-id="b699c-122">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="b699c-123">大多数应用程序使用单个 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 线程，尽管在某些情况下，最好使用多个线程。</span><span class="sxs-lookup"><span data-stu-id="b699c-123">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="b699c-124">我们将稍后通过示例对此进行讨论。</span><span class="sxs-lookup"><span data-stu-id="b699c-124">We’ll discuss this with an example later.</span></span>

 <span data-ttu-id="b699c-125">[!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)]线程在名为的对象内对工作项进行排队 <xref:System.Windows.Threading.Dispatcher> 。</span><span class="sxs-lookup"><span data-stu-id="b699c-125">The [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="b699c-126"><xref:System.Windows.Threading.Dispatcher> 基于优先级选择工作项，并运行每一个工作项直到完成。</span><span class="sxs-lookup"><span data-stu-id="b699c-126">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="b699c-127">每个 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 线程都必须至少有一个线程 <xref:System.Windows.Threading.Dispatcher> ，并且每个线程 <xref:System.Windows.Threading.Dispatcher> 只能在一个线程中执行工作项。</span><span class="sxs-lookup"><span data-stu-id="b699c-127">Every [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>

 <span data-ttu-id="b699c-128">构建响应能力强的用户应用程序的技巧是通过使工作项更小来最大限度地提高 <xref:System.Windows.Threading.Dispatcher> 吞吐量。</span><span class="sxs-lookup"><span data-stu-id="b699c-128">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="b699c-129">这样一来，在队列中等待处理的项永远不会过时 <xref:System.Windows.Threading.Dispatcher> 。</span><span class="sxs-lookup"><span data-stu-id="b699c-129">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="b699c-130">输入和响应间任何可察觉的延迟都会让用户不满。</span><span class="sxs-lookup"><span data-stu-id="b699c-130">Any perceivable delay between input and response can frustrate a user.</span></span>

 <span data-ttu-id="b699c-131">[!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)]应用程序应该如何处理大操作？</span><span class="sxs-lookup"><span data-stu-id="b699c-131">How then are [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="b699c-132">如果代码涉及大型计算，或需要查询某些远程服务器上的数据库，应该怎么办？</span><span class="sxs-lookup"><span data-stu-id="b699c-132">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="b699c-133">通常情况下，答案是在单独的线程中处理大操作，使线程可自由地用于 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 队列中的项 <xref:System.Windows.Threading.Dispatcher> 。</span><span class="sxs-lookup"><span data-stu-id="b699c-133">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="b699c-134">当大操作完成时，它可以将其结果报告回 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 线程以便显示。</span><span class="sxs-lookup"><span data-stu-id="b699c-134">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>

 <span data-ttu-id="b699c-135">以前，Windows [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 只允许通过创建元素的线程访问元素。</span><span class="sxs-lookup"><span data-stu-id="b699c-135">Historically, Windows allows [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="b699c-136">这意味着，负责长时间运行任务的后台线程无法在任务完成时更新文本框。</span><span class="sxs-lookup"><span data-stu-id="b699c-136">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> <span data-ttu-id="b699c-137">Windows 这样做是为了确保组件的完整性 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="b699c-137">Windows does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="b699c-138">如果在绘制过程中后台线程更新了列表框的内容，则此列表框看起来可能会很奇怪。</span><span class="sxs-lookup"><span data-stu-id="b699c-138">A list box could look strange if its contents were updated by a background thread during painting.</span></span>

 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="b699c-139">具有内置互相排斥机制，此机制能强制执行这种协调。</span><span class="sxs-lookup"><span data-stu-id="b699c-139">has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="b699c-140">中的大多数类都是 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 从派生的 <xref:System.Windows.Threading.DispatcherObject> 。</span><span class="sxs-lookup"><span data-stu-id="b699c-140">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="b699c-141">构造时，将对 <xref:System.Windows.Threading.DispatcherObject> 链接的引用存储到 <xref:System.Windows.Threading.Dispatcher> 当前正在运行的线程。</span><span class="sxs-lookup"><span data-stu-id="b699c-141">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="b699c-142">实际上， <xref:System.Windows.Threading.DispatcherObject> 与创建它的线程关联。</span><span class="sxs-lookup"><span data-stu-id="b699c-142">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="b699c-143">在程序执行期间， <xref:System.Windows.Threading.DispatcherObject> 可以调用其公共 <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b699c-143">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <span data-ttu-id="b699c-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> 检查 <xref:System.Windows.Threading.Dispatcher> 与当前线程关联的，并将其与在 <xref:System.Windows.Threading.Dispatcher> 构造过程中存储的引用进行比较。</span><span class="sxs-lookup"><span data-stu-id="b699c-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="b699c-145">如果二者不匹配， <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> 将引发异常。</span><span class="sxs-lookup"><span data-stu-id="b699c-145">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <span data-ttu-id="b699c-146"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> 用于在属于的每个方法的开头调用 <xref:System.Windows.Threading.DispatcherObject> 。</span><span class="sxs-lookup"><span data-stu-id="b699c-146"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>

 <span data-ttu-id="b699c-147">如果只有一个线程可以修改 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] ，则后台线程如何与用户交互？</span><span class="sxs-lookup"><span data-stu-id="b699c-147">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="b699c-148">后台线程可以要求 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 线程代表其执行操作。</span><span class="sxs-lookup"><span data-stu-id="b699c-148">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="b699c-149">它通过将工作项注册到线程的来实现此目的 <xref:System.Windows.Threading.Dispatcher> [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="b699c-149">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="b699c-150"><xref:System.Windows.Threading.Dispatcher>类提供两种方法来注册工作项： <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 和 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b699c-150">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="b699c-151">这两种方法都计划一个用于执行的委托。</span><span class="sxs-lookup"><span data-stu-id="b699c-151">Both methods schedule a delegate for execution.</span></span> <span data-ttu-id="b699c-152"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是一个同步调用-即，它不会返回，直到 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 线程实际完成执行委托。</span><span class="sxs-lookup"><span data-stu-id="b699c-152"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <span data-ttu-id="b699c-153"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 是异步的，并且会立即返回。</span><span class="sxs-lookup"><span data-stu-id="b699c-153"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.</span></span>

 <span data-ttu-id="b699c-154"><xref:System.Windows.Threading.Dispatcher>按优先级对其队列中的元素进行排序。</span><span class="sxs-lookup"><span data-stu-id="b699c-154">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="b699c-155">向队列中添加元素时，可以指定10个级别 <xref:System.Windows.Threading.Dispatcher> 。</span><span class="sxs-lookup"><span data-stu-id="b699c-155">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="b699c-156">这些优先级在枚举中维护 <xref:System.Windows.Threading.DispatcherPriority> 。</span><span class="sxs-lookup"><span data-stu-id="b699c-156">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="b699c-157"><xref:System.Windows.Threading.DispatcherPriority>在 Windows SDK 文档中可以找到有关级别的详细信息。</span><span class="sxs-lookup"><span data-stu-id="b699c-157">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the Windows SDK documentation.</span></span>

<a name="samples"></a>
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="b699c-158">实际线程：示例</span><span class="sxs-lookup"><span data-stu-id="b699c-158">Threads in Action: The Samples</span></span>

<a name="prime_number"></a>
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="b699c-159">具有长时间运行计算的单线程应用程序</span><span class="sxs-lookup"><span data-stu-id="b699c-159">A Single-Threaded Application with a Long-Running Calculation</span></span>
 <span data-ttu-id="b699c-160">大多数图形用户界面 (Gui) 在等待为响应用户交互而生成的事件时，花费大量时间空闲。</span><span class="sxs-lookup"><span data-stu-id="b699c-160">Most graphical user interfaces (GUIs) spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="b699c-161">对此空闲时间进行仔细编程时，可以建设性地使用，而不会影响的响应能力 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="b699c-161">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="b699c-162">[!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)]线程模型不允许输入中断线程中发生的操作 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="b699c-162">The [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="b699c-163">这意味着，你必须确保定期返回以 <xref:System.Windows.Threading.Dispatcher> 处理挂起输入事件，然后才能使其过时。</span><span class="sxs-lookup"><span data-stu-id="b699c-163">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>

 <span data-ttu-id="b699c-164">请看下面的示例：</span><span class="sxs-lookup"><span data-stu-id="b699c-164">Consider the following example:</span></span>

 ![显示质数线程的屏幕截图。](./media/threading-model/threading-prime-numbers.png)

 <span data-ttu-id="b699c-166">这个简单的应用程序从 3 开始向上计数以搜索质数。</span><span class="sxs-lookup"><span data-stu-id="b699c-166">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="b699c-167">当用户单击 " **开始** " 按钮时，将开始搜索。</span><span class="sxs-lookup"><span data-stu-id="b699c-167">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="b699c-168">当程序查找到一个质数时，它将根据其发现内容更新用户界面。</span><span class="sxs-lookup"><span data-stu-id="b699c-168">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="b699c-169">用户可随时停止搜索。</span><span class="sxs-lookup"><span data-stu-id="b699c-169">At any point, the user can stop the search.</span></span>

 <span data-ttu-id="b699c-170">尽管十分简单，但对质数的搜索可以永远持续下去，这会带来一些问题。</span><span class="sxs-lookup"><span data-stu-id="b699c-170">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="b699c-171">如果在按钮的 click 事件处理程序中处理了整个搜索，则永远不会为线程分配 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 处理其他事件的机会。</span><span class="sxs-lookup"><span data-stu-id="b699c-171">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="b699c-172">将 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 无法响应输入或处理消息。</span><span class="sxs-lookup"><span data-stu-id="b699c-172">The [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="b699c-173">它将永远不会重绘，也永远不会响应按钮单击。</span><span class="sxs-lookup"><span data-stu-id="b699c-173">It would never repaint and never respond to button clicks.</span></span>

 <span data-ttu-id="b699c-174">可以在单独的线程中搜索质数，但这样的话，我们需要处理一些同步问题。</span><span class="sxs-lookup"><span data-stu-id="b699c-174">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="b699c-175">通过单线程方法，可以直接更新列出所找到的最大质数的标签。</span><span class="sxs-lookup"><span data-stu-id="b699c-175">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>

 <span data-ttu-id="b699c-176">如果我们将计算任务分解为可管理的块，我们可以定期返回到 <xref:System.Windows.Threading.Dispatcher> 并处理事件。</span><span class="sxs-lookup"><span data-stu-id="b699c-176">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="b699c-177">我们可以给出重 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 绘和处理输入的机会。</span><span class="sxs-lookup"><span data-stu-id="b699c-177">We can give [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>

 <span data-ttu-id="b699c-178">在计算与事件处理之间拆分处理时间的最佳方式是从管理计算 <xref:System.Windows.Threading.Dispatcher> 。</span><span class="sxs-lookup"><span data-stu-id="b699c-178">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="b699c-179">通过使用 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 方法，可以在从其绘制事件的同一队列中计划质数检查 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="b699c-179">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="b699c-180">在我们的示例中，一次仅计划一个质数检查。</span><span class="sxs-lookup"><span data-stu-id="b699c-180">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="b699c-181">完成质数检查后，立即计划下一个检查。</span><span class="sxs-lookup"><span data-stu-id="b699c-181">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="b699c-182">只有处理挂起事件之后，才会执行此检查 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="b699c-182">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>

 ![显示调度程序队列的屏幕截图。](./media/threading-model/threading-dispatcher-queue.png)

 <span data-ttu-id="b699c-184">Microsoft Word 使用此机制完成拼写检查。</span><span class="sxs-lookup"><span data-stu-id="b699c-184">Microsoft Word accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="b699c-185">使用线程的空闲时间在后台完成拼写检查 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="b699c-185">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="b699c-186">我们来看一看代码。</span><span class="sxs-lookup"><span data-stu-id="b699c-186">Let's take a look at the code.</span></span>

 <span data-ttu-id="b699c-187">下列示例显示了创建用户界面的 XAML。</span><span class="sxs-lookup"><span data-stu-id="b699c-187">The following example shows the XAML that creates the user interface.</span></span>

 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]

 <span data-ttu-id="b699c-188">以下示例显示了代码隐藏。</span><span class="sxs-lookup"><span data-stu-id="b699c-188">The following example shows the code-behind.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]

 <span data-ttu-id="b699c-189">下面的示例演示的事件处理程序 <xref:System.Windows.Controls.Button> 。</span><span class="sxs-lookup"><span data-stu-id="b699c-189">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]

 <span data-ttu-id="b699c-190">除了更新上的文本 <xref:System.Windows.Controls.Button> ，此处理程序负责通过将委托添加到队列来计划第一个质数检查 <xref:System.Windows.Threading.Dispatcher> 。</span><span class="sxs-lookup"><span data-stu-id="b699c-190">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="b699c-191">在此事件处理程序完成其工作后的某个时间， <xref:System.Windows.Threading.Dispatcher> 将选择此委托以便执行。</span><span class="sxs-lookup"><span data-stu-id="b699c-191">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>

 <span data-ttu-id="b699c-192">如前文所述， <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 是 <xref:System.Windows.Threading.Dispatcher> 用于计划委托执行的成员。</span><span class="sxs-lookup"><span data-stu-id="b699c-192">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="b699c-193">在此示例中，我们选择 <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> 优先级。</span><span class="sxs-lookup"><span data-stu-id="b699c-193">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="b699c-194"><xref:System.Windows.Threading.Dispatcher>仅当没有要处理的重要事件时，才会执行此委托。</span><span class="sxs-lookup"><span data-stu-id="b699c-194">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] <span data-ttu-id="b699c-195">响应能力比数字检查更重要。</span><span class="sxs-lookup"><span data-stu-id="b699c-195">responsiveness is more important than number checking.</span></span> <span data-ttu-id="b699c-196">我们还传递了一个表示数字检查例程的新委托。</span><span class="sxs-lookup"><span data-stu-id="b699c-196">We also pass a new delegate representing the number-checking routine.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]

 <span data-ttu-id="b699c-197">此方法检查下一个奇数是否是质数。</span><span class="sxs-lookup"><span data-stu-id="b699c-197">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="b699c-198">如果它是质数，则方法会直接更新 `bigPrime` <xref:System.Windows.Controls.TextBlock> 以反映它的发现。</span><span class="sxs-lookup"><span data-stu-id="b699c-198">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="b699c-199">可以如此操作的原因是，该计算发生在用于创建组件的相同线程中。</span><span class="sxs-lookup"><span data-stu-id="b699c-199">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="b699c-200">如果我们选择使用单独的线程进行计算，则必须使用更复杂的同步机制，并在线程中执行更新 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="b699c-200">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="b699c-201">我们将在下一步中演示这种情况。</span><span class="sxs-lookup"><span data-stu-id="b699c-201">We’ll demonstrate this situation next.</span></span>

 <span data-ttu-id="b699c-202">有关此示例的完整源代码，请参阅 [具有 Long-Running 计算的单线程应用程序示例](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication)</span><span class="sxs-lookup"><span data-stu-id="b699c-202">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication)</span></span>

<a name="weather_sim"></a>
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="b699c-203">使用后台线程处理阻塞操作</span><span class="sxs-lookup"><span data-stu-id="b699c-203">Handling a Blocking Operation with a Background Thread</span></span>
 <span data-ttu-id="b699c-204">在图形应用程序中处理阻塞操作可能很困难。</span><span class="sxs-lookup"><span data-stu-id="b699c-204">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="b699c-205">我们不希望从事件处理程序调用阻塞方法，因为应用程序可能看上去冻结。</span><span class="sxs-lookup"><span data-stu-id="b699c-205">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="b699c-206">我们可以使用单独的线程来处理这些操作，但完成此操作后，必须与线程同步， [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 因为我们无法从我们的工作线程直接修改 GUI。</span><span class="sxs-lookup"><span data-stu-id="b699c-206">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the GUI from our worker thread.</span></span> <span data-ttu-id="b699c-207">我们可以使用 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 或 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 将委托插入到 <xref:System.Windows.Threading.Dispatcher> 线程的中 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="b699c-207">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="b699c-208">最终，将执行这些委托并带有修改元素的权限 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="b699c-208">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>

 <span data-ttu-id="b699c-209">在本例中，我们模拟了一个检索天气预报的远程过程调用。</span><span class="sxs-lookup"><span data-stu-id="b699c-209">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="b699c-210">我们使用单独的工作线程执行此调用，并在完成时在线程的中计划更新方法 <xref:System.Windows.Threading.Dispatcher> [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="b699c-210">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>

 ![显示天气 UI 的屏幕截图。](./media/threading-model/threading-weather-ui.png)

 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]

 <span data-ttu-id="b699c-212">以下是一些需要注意的详细信息。</span><span class="sxs-lookup"><span data-stu-id="b699c-212">The following are some of the details to be noted.</span></span>

- <span data-ttu-id="b699c-213">创建按钮处理程序</span><span class="sxs-lookup"><span data-stu-id="b699c-213">Creating the Button Handler</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]

 <span data-ttu-id="b699c-214">单击按钮时，会显示时钟绘图并开始对其进行动画处理。</span><span class="sxs-lookup"><span data-stu-id="b699c-214">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="b699c-215">禁用该按钮。</span><span class="sxs-lookup"><span data-stu-id="b699c-215">We disable the button.</span></span> <span data-ttu-id="b699c-216">我们 `FetchWeatherFromServer` 在新线程中调用方法，然后返回，允许在 <xref:System.Windows.Threading.Dispatcher> 我们等待收集天气预报时处理事件。</span><span class="sxs-lookup"><span data-stu-id="b699c-216">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>

- <span data-ttu-id="b699c-217">获取天气</span><span class="sxs-lookup"><span data-stu-id="b699c-217">Fetching the Weather</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]

 <span data-ttu-id="b699c-218">为简便起见，本例中没有任何网络代码。</span><span class="sxs-lookup"><span data-stu-id="b699c-218">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="b699c-219">通过使新线程进入休眠状态四秒钟，模拟网络访问的延迟。</span><span class="sxs-lookup"><span data-stu-id="b699c-219">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="b699c-220">此时，原始 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 线程仍在运行并响应事件。</span><span class="sxs-lookup"><span data-stu-id="b699c-220">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="b699c-221">为了对此进行演示，我们让动画保持运行状态，最小化和最大化按钮也继续工作。</span><span class="sxs-lookup"><span data-stu-id="b699c-221">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>

 <span data-ttu-id="b699c-222">当延迟结束，并且我们随机选择了天气预报后，就可以向下报告回来了 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="b699c-222">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="b699c-223">为此，我们需要 `UpdateUserInterface` 使用线程的在线程中计划对的调用 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] <xref:System.Windows.Threading.Dispatcher> 。</span><span class="sxs-lookup"><span data-stu-id="b699c-223">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="b699c-224">将描述天气的字符串传递给此计划方法调用。</span><span class="sxs-lookup"><span data-stu-id="b699c-224">We pass a string describing the weather to this scheduled method call.</span></span>

- <span data-ttu-id="b699c-225">更新 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)]</span><span class="sxs-lookup"><span data-stu-id="b699c-225">Updating the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)]</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]

 <span data-ttu-id="b699c-226">当 <xref:System.Windows.Threading.Dispatcher> 线程中的 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 具有时间时，它将执行对的计划调用 `UpdateUserInterface` 。</span><span class="sxs-lookup"><span data-stu-id="b699c-226">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="b699c-227">此方法停止时钟动画，并选择一张映像用于描述天气。</span><span class="sxs-lookup"><span data-stu-id="b699c-227">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="b699c-228">它将显示此映像，并还原“获取预报”按钮。</span><span class="sxs-lookup"><span data-stu-id="b699c-228">It displays this image and restores the "fetch forecast" button.</span></span>

<a name="multi_browser"></a>
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="b699c-229">多窗口、多线程</span><span class="sxs-lookup"><span data-stu-id="b699c-229">Multiple Windows, Multiple Threads</span></span>
 <span data-ttu-id="b699c-230">某些 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 应用程序需要多个顶级窗口。</span><span class="sxs-lookup"><span data-stu-id="b699c-230">Some [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="b699c-231">一个线程/ <xref:System.Windows.Threading.Dispatcher> 组合可用于管理多个窗口是完全可接受的，但有时多个线程会执行更好的作业。</span><span class="sxs-lookup"><span data-stu-id="b699c-231">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="b699c-232">尤其当这些窗口中的某一个将有可能要独占线程时，更是如此。</span><span class="sxs-lookup"><span data-stu-id="b699c-232">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>

 <span data-ttu-id="b699c-233">Windows 资源管理器以这种方式工作。</span><span class="sxs-lookup"><span data-stu-id="b699c-233">Windows Explorer works in this fashion.</span></span> <span data-ttu-id="b699c-234">每个新资源管理器窗口都属于原始进程，但它是在独立线程的控件下创建的。</span><span class="sxs-lookup"><span data-stu-id="b699c-234">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>

 <span data-ttu-id="b699c-235">使用 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.Controls.Frame> 控件，可以显示网页。</span><span class="sxs-lookup"><span data-stu-id="b699c-235">By using a [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="b699c-236">我们可以轻松创建简单的 Internet Explorer 替换。</span><span class="sxs-lookup"><span data-stu-id="b699c-236">We can easily create a simple Internet Explorer substitute.</span></span> <span data-ttu-id="b699c-237">让我们从一个重要功能开始：打开新资源管理器窗口的能力。</span><span class="sxs-lookup"><span data-stu-id="b699c-237">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="b699c-238">当用户单击“新建窗口”按钮时，我们将在单独的线程中启动窗口的副本。</span><span class="sxs-lookup"><span data-stu-id="b699c-238">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="b699c-239">这样一来，在其中一个窗口中的长时间运行或阻塞操作将不会锁定其他窗口。</span><span class="sxs-lookup"><span data-stu-id="b699c-239">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>

 <span data-ttu-id="b699c-240">在实际情况下，Web 浏览器模型自身拥有复杂的线程模型。</span><span class="sxs-lookup"><span data-stu-id="b699c-240">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="b699c-241">由于大多数读者都熟悉它，所以我们选择它。</span><span class="sxs-lookup"><span data-stu-id="b699c-241">We’ve chosen it because it should be familiar to most readers.</span></span>

 <span data-ttu-id="b699c-242">以下示例显示了代码。</span><span class="sxs-lookup"><span data-stu-id="b699c-242">The following example shows the code.</span></span>

 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]

 <span data-ttu-id="b699c-243">此代码中的以下线程段对我们来说是最有趣的：</span><span class="sxs-lookup"><span data-stu-id="b699c-243">The following threading segments of this code are the most interesting to us in this context:</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]

 <span data-ttu-id="b699c-244">当单击“新建窗口”按钮时，将调用该方法。</span><span class="sxs-lookup"><span data-stu-id="b699c-244">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="b699c-245">它创建了一个新线程，并以异步方式启动。</span><span class="sxs-lookup"><span data-stu-id="b699c-245">It creates a new thread and starts it asynchronously.</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]

 <span data-ttu-id="b699c-246">此方法是新线程的起点。</span><span class="sxs-lookup"><span data-stu-id="b699c-246">This method is the starting point for the new thread.</span></span> <span data-ttu-id="b699c-247">我们在此线程的控件下创建了一个新窗口。</span><span class="sxs-lookup"><span data-stu-id="b699c-247">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="b699c-248">自动创建新的 <xref:System.Windows.Threading.Dispatcher> 以管理新线程。</span><span class="sxs-lookup"><span data-stu-id="b699c-248">automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="b699c-249">为了使窗口正常运行，我们需要做的就是启动 <xref:System.Windows.Threading.Dispatcher> 。</span><span class="sxs-lookup"><span data-stu-id="b699c-249">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>

<a name="stumbling_points"></a>
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="b699c-250">技术详细信息和疑难点</span><span class="sxs-lookup"><span data-stu-id="b699c-250">Technical Details and Stumbling Points</span></span>

### <a name="writing-components-using-threading"></a><span data-ttu-id="b699c-251">使用线程处理编写组件</span><span class="sxs-lookup"><span data-stu-id="b699c-251">Writing Components Using Threading</span></span>
 <span data-ttu-id="b699c-252">Microsoft .NET Framework 开发人员指南介绍了有关组件如何向其客户端公开异步行为的模式 (查看 [基于事件的异步模式概述](/dotnet/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview)) 。</span><span class="sxs-lookup"><span data-stu-id="b699c-252">The Microsoft .NET Framework Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](/dotnet/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview)).</span></span> <span data-ttu-id="b699c-253">例如，假设我们想要将方法打包 `FetchWeatherFromServer` 到可重用的非图形组件。</span><span class="sxs-lookup"><span data-stu-id="b699c-253">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="b699c-254">按照标准 Microsoft .NET 框架模式，这会如下所示。</span><span class="sxs-lookup"><span data-stu-id="b699c-254">Following the standard Microsoft .NET Framework pattern, this would look something like the following.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]

 <span data-ttu-id="b699c-255">`GetWeatherAsync` 将使用上述的技术之一（如创建后台线程）来以异步方式工作，而非阻止调用线程。</span><span class="sxs-lookup"><span data-stu-id="b699c-255">`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>

 <span data-ttu-id="b699c-256">此模式中最重要的部分之一是 `Completed` 在调用方法 *名称* 方法的同一线程上调用方法1， `Async` 以开始。</span><span class="sxs-lookup"><span data-stu-id="b699c-256">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="b699c-257">你可以 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 通过存储来轻松地执行此操作， <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> 但之后，非图形组件只能在应用程序中使用，而不能在 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] Windows 窗体或 ASP.NET 程序中使用。</span><span class="sxs-lookup"><span data-stu-id="b699c-257">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] applications, not in Windows Forms or ASP.NET programs.</span></span>

 <span data-ttu-id="b699c-258"><xref:System.Windows.Threading.DispatcherSynchronizationContext>类可满足这一需要，将其视为 <xref:System.Windows.Threading.Dispatcher> 与其他框架一起工作的简化版本 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="b699c-258">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]

### <a name="nested-pumping"></a><span data-ttu-id="b699c-259">嵌套泵</span><span class="sxs-lookup"><span data-stu-id="b699c-259">Nested Pumping</span></span>
 <span data-ttu-id="b699c-260">有时完全锁定线程是不可行的 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="b699c-260">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="b699c-261">让我们考虑一下 <xref:System.Windows.MessageBox.Show%2A> 类的方法 <xref:System.Windows.MessageBox> 。</span><span class="sxs-lookup"><span data-stu-id="b699c-261">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <span data-ttu-id="b699c-262"><xref:System.Windows.MessageBox.Show%2A> 用户单击 "确定" 按钮后，才会返回。</span><span class="sxs-lookup"><span data-stu-id="b699c-262"><xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="b699c-263">但是，它却会创建一个窗口，该窗口为了获得交互性而必须具有消息循环。</span><span class="sxs-lookup"><span data-stu-id="b699c-263">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="b699c-264">在等待用户单击“确定”时，原始应用程序窗口将不会响应用户的输入。</span><span class="sxs-lookup"><span data-stu-id="b699c-264">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="b699c-265">但是，它将继续处理绘制消息。</span><span class="sxs-lookup"><span data-stu-id="b699c-265">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="b699c-266">当被覆盖和被显示时，原始窗口将重绘其本身。</span><span class="sxs-lookup"><span data-stu-id="b699c-266">The original window redraws itself when covered and revealed.</span></span>

 ![显示带有 "确定" 按钮的消息的屏幕截图](./media/threading-model/threading-message-loop.png)

 <span data-ttu-id="b699c-268">一些线程必须负责消息框窗口。</span><span class="sxs-lookup"><span data-stu-id="b699c-268">Some thread must be in charge of the message box window.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="b699c-269">可以为消息框窗口创建新线程，但此线程无法在原始窗口中绘制禁用的元素（请回忆之前所讨论的互相排斥）。</span><span class="sxs-lookup"><span data-stu-id="b699c-269">could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="b699c-270">相反， [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 使用嵌套消息处理系统。</span><span class="sxs-lookup"><span data-stu-id="b699c-270">Instead, [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="b699c-271"><xref:System.Windows.Threading.Dispatcher>类包含名为的特殊方法 <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> ，该方法存储应用程序的当前执行点，然后开始新的消息循环。</span><span class="sxs-lookup"><span data-stu-id="b699c-271">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="b699c-272">当嵌套消息循环完成时，执行将在原始调用后恢复 <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b699c-272">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>

 <span data-ttu-id="b699c-273">在这种情况下， <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> 会在调用时维护程序上下文 <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType> ，并启动一个新的消息循环，以重新绘制背景窗口，并处理消息框窗口中的输入。</span><span class="sxs-lookup"><span data-stu-id="b699c-273">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="b699c-274">当用户单击 "确定" 并清除弹出窗口时，嵌套循环将退出，并在调用后恢复控件 <xref:System.Windows.MessageBox.Show%2A> 。</span><span class="sxs-lookup"><span data-stu-id="b699c-274">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>

### <a name="stale-routed-events"></a><span data-ttu-id="b699c-275">过时的路由事件</span><span class="sxs-lookup"><span data-stu-id="b699c-275">Stale Routed Events</span></span>
 <span data-ttu-id="b699c-276">引发事件时，中的路由事件系统会 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 通知整个树。</span><span class="sxs-lookup"><span data-stu-id="b699c-276">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>

 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]

 <span data-ttu-id="b699c-277">当在椭圆上按下鼠标左键时， `handler2` 将执行。</span><span class="sxs-lookup"><span data-stu-id="b699c-277">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="b699c-278">`handler2`完成后，会将事件传递给 <xref:System.Windows.Controls.Canvas> 对象，后者使用 `handler1` 来处理该事件。</span><span class="sxs-lookup"><span data-stu-id="b699c-278">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="b699c-279">仅当 `handler2` 未将事件对象显式标记为已处理时，才会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="b699c-279">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>

 <span data-ttu-id="b699c-280">可能 `handler2` 需要大量时间来处理此事件。</span><span class="sxs-lookup"><span data-stu-id="b699c-280">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> <span data-ttu-id="b699c-281">`handler2` 可能使用 <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> 来开始一个嵌套消息循环，该循环在数小时内不会返回。</span><span class="sxs-lookup"><span data-stu-id="b699c-281">`handler2` might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="b699c-282">如果 `handler2` 在此消息循环完成时未将事件标记为已处理，则该事件将在树中向上传递，即使它非常旧。</span><span class="sxs-lookup"><span data-stu-id="b699c-282">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>

### <a name="reentrancy-and-locking"></a><span data-ttu-id="b699c-283">重新进入和锁定</span><span class="sxs-lookup"><span data-stu-id="b699c-283">Reentrancy and Locking</span></span>
 <span data-ttu-id="b699c-284">公共语言运行时 (CLR) 的锁定机制的行为与想象的行为完全不同;请求锁时，可能会希望线程完全停止操作。</span><span class="sxs-lookup"><span data-stu-id="b699c-284">The locking mechanism of the common language runtime (CLR) doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="b699c-285">实际上，该线程将继续接收和处理高优先级的消息。</span><span class="sxs-lookup"><span data-stu-id="b699c-285">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="b699c-286">这样有助于防止死锁，并使接口最低限度地响应，但这样做有可能引入细微 bug。</span><span class="sxs-lookup"><span data-stu-id="b699c-286">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="b699c-287">大多数 (情况下，您不需要了解有关此操作的任何信息，但在极少数情况下，通常会涉及 Win32 窗口消息或 COM STA 组件) 这样做很有价值。</span><span class="sxs-lookup"><span data-stu-id="b699c-287">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving Win32 window messages or COM STA components) this can be worth knowing.</span></span>

 <span data-ttu-id="b699c-288">大多数接口都不是以线程安全为基础生成的，因为开发人员可以假定 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 永远不会由多个线程访问。</span><span class="sxs-lookup"><span data-stu-id="b699c-288">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="b699c-289">在这种情况下，单个线程可能会在意外的时间发生环境更改，从而导致这类错误的影响，从而导致 <xref:System.Windows.Threading.DispatcherObject> 互斥机制能够解决。</span><span class="sxs-lookup"><span data-stu-id="b699c-289">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="b699c-290">请看下面的伪代码：</span><span class="sxs-lookup"><span data-stu-id="b699c-290">Consider the following pseudocode:</span></span>

 <span data-ttu-id="b699c-291">![显示线程重入的关系图。](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span><span class="sxs-lookup"><span data-stu-id="b699c-291">![Diagram that shows threading reentrancy.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span></span>

 <span data-ttu-id="b699c-292">大多数情况下都是正确的，但有时 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 这种意外重入可能会导致问题。</span><span class="sxs-lookup"><span data-stu-id="b699c-292">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="b699c-293">因此，在某些关键情况下 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] ， <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> 会调用，这将更改该线程的锁定指令以使用 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 无提示锁定，而不是使用常用的 CLR 锁。</span><span class="sxs-lookup"><span data-stu-id="b699c-293">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual CLR lock.</span></span>

 <span data-ttu-id="b699c-294">那么为什么 CLR 团队选择此行为呢？</span><span class="sxs-lookup"><span data-stu-id="b699c-294">So why did the CLR team choose this behavior?</span></span> <span data-ttu-id="b699c-295">它与 COM STA 对象和完成线程有关。</span><span class="sxs-lookup"><span data-stu-id="b699c-295">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="b699c-296">当对对象进行垃圾回收时，它的 `Finalize` 方法将在专用终结器线程上运行，而不是在线程上运行 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="b699c-296">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="b699c-297">其中存在问题，因为在线程上创建的 COM STA 对象 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 只能在线程上释放 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="b699c-297">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="b699c-298"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>在此示例中，CLR 使用 win32) 执行 (等效操作 `SendMessage` 。</span><span class="sxs-lookup"><span data-stu-id="b699c-298">The CLR does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="b699c-299">但如果 [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] 线程繁忙，则终结器线程将停止，并且无法释放 COM STA 对象，这将导致严重的内存泄漏。</span><span class="sxs-lookup"><span data-stu-id="b699c-299">But if the [!INCLUDE[TLA2#tla_ui](../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="b699c-300">因此，CLR 团队做出了很难的调用，使锁按照它们的工作方式工作。</span><span class="sxs-lookup"><span data-stu-id="b699c-300">So the CLR team made the tough call to make locks work the way they do.</span></span>

 <span data-ttu-id="b699c-301">的任务 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 是在不重新引入内存泄漏的情况下避免意外的重入，这就是我们不会在任何地方阻止重入的原因。</span><span class="sxs-lookup"><span data-stu-id="b699c-301">The task for [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>

## <a name="see-also"></a><span data-ttu-id="b699c-302">请参阅</span><span class="sxs-lookup"><span data-stu-id="b699c-302">See also</span></span>

- [<span data-ttu-id="b699c-303">具有长时间运行计算的单线程应用程序示例</span><span class="sxs-lookup"><span data-stu-id="b699c-303">Single-Threaded Application with Long-Running Calculation Sample</span></span>](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication)
