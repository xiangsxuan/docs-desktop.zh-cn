---
title: 依赖项属性元数据
ms.date: 03/30/2017
helpviewer_keywords:
- APIs [WPF], metadata
- dependency properties [WPF], metadata
- metadata [WPF], for dependency properties
- overriding metadata [WPF]
ms.assetid: d01ed009-b722-41bf-b82f-fe1a8cdc50dd
ms.openlocfilehash: 68724937df38372ea9b8221ee527368590cb6602
ms.sourcegitcommit: 069786bcadbf9cd931d7dc3d892262cd852d2ffb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/19/2021
ms.locfileid: "104666077"
---
# <a name="dependency-property-metadata"></a><span data-ttu-id="fc8b6-102">依赖项属性元数据</span><span class="sxs-lookup"><span data-stu-id="fc8b6-102">Dependency Property Metadata</span></span>
<span data-ttu-id="fc8b6-103">[!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)]属性系统包含一个元数据报告系统，该系统超出了可通过反射或常规公共语言运行时 (CLR) 特征报告的属性。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-103">The [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] property system includes a metadata reporting system that goes beyond what can be reported about a property through reflection or general common language runtime (CLR) characteristics.</span></span> <span data-ttu-id="fc8b6-104">依赖属性的元数据还可以由定义依赖属性的类来唯一地分配，可以在依赖属性添加到另一个类时进行更改，可以由所有从定义基类继承依赖属性的派生类来明确地重写。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-104">Metadata for a dependency property can also be assigned uniquely by the class that defines a dependency property, can be changed when the dependency property is added to a different class, and can be specifically overridden by all derived classes that inherit the dependency property from the defining base class.</span></span>  

<a name="prerequisites"></a>
## <a name="prerequisites"></a><span data-ttu-id="fc8b6-105">必备条件</span><span class="sxs-lookup"><span data-stu-id="fc8b6-105">Prerequisites</span></span>  
 <span data-ttu-id="fc8b6-106">本主题假定你从 [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] 类的现有依赖属性的使用者角度了解依赖属性，并且已阅读[依赖属性概述](dependency-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-106">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md).</span></span> <span data-ttu-id="fc8b6-107">若要理解本主题中的示例，还应当了解 [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] 并知道如何编写 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 应用程序。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-107">In order to follow the examples in this topic, you should also understand [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] and know how to write [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] applications.</span></span>  
  
<a name="dp_metadata_contents"></a>
## <a name="how-dependency-property-metadata-is-used"></a><span data-ttu-id="fc8b6-108">依赖属性元数据的使用方式</span><span class="sxs-lookup"><span data-stu-id="fc8b6-108">How Dependency Property Metadata is Used</span></span>  
 <span data-ttu-id="fc8b6-109">依赖属性的元数据作为一个对象存在，可以通过查询该对象来检查依赖属性的特征。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-109">Dependency property metadata exists as an object that can be queried to examine the characteristics of a dependency property.</span></span> <span data-ttu-id="fc8b6-110">当属性系统处理任何给定的依赖属性时，也会经常访问这些元数据。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-110">This metadata is also accessed frequently by the property system as it processes any given dependency property.</span></span> <span data-ttu-id="fc8b6-111">依赖属性的元数据对象可以包含以下类型的信息：</span><span class="sxs-lookup"><span data-stu-id="fc8b6-111">The metadata object for a dependency property can contain the following types of information:</span></span>  
  
- <span data-ttu-id="fc8b6-112">依赖项属性的默认值，如果无法按本地值、样式、继承等来确定依赖项属性的其他值，则为。有关为依赖属性赋值时默认值如何参与属性系统所使用的优先级的详细讨论，请参阅 [依赖属性值优先级](dependency-property-value-precedence.md)。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-112">Default value for the dependency property, if no other value can be determined for the dependency property by local value, style, inheritance, etc. For a thorough discussion of how default values participate in the precedence used by the property system when assigning values for dependency properties, see [Dependency Property Value Precedence](dependency-property-value-precedence.md).</span></span>  
  
- <span data-ttu-id="fc8b6-113">对影响每个所有者类型的强制行为或更改通知行为的回叫实现的引用。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-113">References to callback implementations that affect coercion or change-notification behaviors on a per-owner-type basis.</span></span> <span data-ttu-id="fc8b6-114">请注意，这些回叫通常是用非公共访问级别定义的，因此，除非实际引用位于允许的访问范围内，否则通常无法从元数据获得这些引用。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-114">Note that these callbacks are often defined with a nonpublic access level, so obtaining the actual references from metadata is generally not possible unless the references are within your permitted access scope.</span></span> <span data-ttu-id="fc8b6-115">有关依赖属性回叫的详细信息，请参阅[依赖属性回调和验证](dependency-property-callbacks-and-validation.md)。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-115">For more information on dependency property callbacks, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md).</span></span>  
  
- <span data-ttu-id="fc8b6-116">如果所讨论的依赖属性被视为一个 WPF 框架级别的属性，则元数据中可能包含 WPF 框架级别的依赖属性特征，这些特征报告各种服务（如 WPF 框架级别的布局引擎和属性继承逻辑）的信息和状态。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-116">If the dependency property in question is considered to be a WPF framework-level property, the metadata might contain WPF framework-level dependency property characteristics, which report information and state for services such as the WPF framework-level layout engine and property inheritance logic.</span></span> <span data-ttu-id="fc8b6-117">有关依赖属性元数据的这一方面的详细信息，请参阅[框架属性元数据](framework-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-117">For more information on this aspect of dependency property metadata, see [Framework Property Metadata](framework-property-metadata.md).</span></span>  
  
<a name="APIs"></a>
## <a name="metadata-apis"></a><span data-ttu-id="fc8b6-118">元数据 API</span><span class="sxs-lookup"><span data-stu-id="fc8b6-118">Metadata APIs</span></span>  
 <span data-ttu-id="fc8b6-119">报告属性系统使用的大多数元数据信息的类型是 <xref:System.Windows.PropertyMetadata> 类。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-119">The type that reports most of the metadata information used by the property system is the <xref:System.Windows.PropertyMetadata> class.</span></span> <span data-ttu-id="fc8b6-120">在向属性系统注册依赖属性时，可以选择指定元数据实例，并且可以为以下附加类型再次指定这些实例：将自身作为所有者添加的类型，或者重写它们从基类依赖属性定义继承的元数据的类型。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-120">Metadata instances are optionally specified when dependency properties are registered with the property system, and can be specified again for additional types that either add themselves as owners or override metadata they inherit from the base class dependency property definition.</span></span> <span data-ttu-id="fc8b6-121"> (在属性注册未指定元数据的情况下，将 <xref:System.Windows.PropertyMetadata> 使用该类的默认值创建默认值。 <xref:System.Windows.PropertyMetadata> 当调用 <xref:System.Windows.DependencyProperty.GetMetadata%2A> 从实例的依赖项属性获取元数据的各种重载时，将返回注册的元数据 ) <xref:System.Windows.DependencyObject> 。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-121">(For cases where a property registration does not specify metadata, a default <xref:System.Windows.PropertyMetadata> is created with default values for that class.)The registered metadata is returned as <xref:System.Windows.PropertyMetadata> when you call the various <xref:System.Windows.DependencyProperty.GetMetadata%2A> overloads that get metadata from a dependency property on a <xref:System.Windows.DependencyObject> instance.</span></span>  
  
 <span data-ttu-id="fc8b6-122"><xref:System.Windows.PropertyMetadata>然后从派生类，以便为体系结构分部（如 WPF 框架级类）提供更具体的元数据。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-122">The <xref:System.Windows.PropertyMetadata> class is then derived from to provide more specific metadata for architectural divisions such as the WPF framework-level classes.</span></span> <span data-ttu-id="fc8b6-123"><xref:System.Windows.UIPropertyMetadata> 添加动画报告，并 <xref:System.Windows.FrameworkPropertyMetadata> 提供上一节中提到的 WPF 框架级属性。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-123"><xref:System.Windows.UIPropertyMetadata> adds animation reporting, and <xref:System.Windows.FrameworkPropertyMetadata> provides the WPF framework-level properties mentioned in the previous section.</span></span> <span data-ttu-id="fc8b6-124">当注册依赖属性时，可以将它们注册到这些 <xref:System.Windows.PropertyMetadata> 派生类。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-124">When dependency properties are registered, they can be registered with these <xref:System.Windows.PropertyMetadata> derived classes.</span></span> <span data-ttu-id="fc8b6-125">检查元数据时， <xref:System.Windows.PropertyMetadata> 可以将基类型强制转换为派生类，以便可以检查更具体的属性。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-125">When the metadata is examined, the base <xref:System.Windows.PropertyMetadata> type can potentially be cast to the derived classes so that you can examine the more specific properties.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="fc8b6-126">在此文档中，可以指定的属性特征 <xref:System.Windows.FrameworkPropertyMetadata> 有时被称为 "标志"。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-126">The property characteristics that can be specified in <xref:System.Windows.FrameworkPropertyMetadata> are sometimes referred to in this documentation as "flags".</span></span> <span data-ttu-id="fc8b6-127">当你创建新的元数据实例以便在依赖属性注册或元数据重写中使用时，你可以使用 flagwise 枚举指定这些值， <xref:System.Windows.FrameworkPropertyMetadataOptions> 然后提供可能连接到 <xref:System.Windows.FrameworkPropertyMetadata> 构造函数的枚举值。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-127">When you create new metadata instances for use in dependency property registrations or metadata overrides, you specify these values using the flagwise enumeration <xref:System.Windows.FrameworkPropertyMetadataOptions> and then you supply possibly concatenated values of the enumeration to the <xref:System.Windows.FrameworkPropertyMetadata> constructor.</span></span> <span data-ttu-id="fc8b6-128">但是，一旦构造后，这些选项特征在中 <xref:System.Windows.FrameworkPropertyMetadata> 作为一系列布尔属性公开，而不是构造枚举值。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-128">However, once constructed, these option characteristics are exposed within a <xref:System.Windows.FrameworkPropertyMetadata> as a series of Boolean properties rather than the constructing enumeration value.</span></span> <span data-ttu-id="fc8b6-129">使用布尔属性，可以检查每个条件，而不必为了获得感兴趣的信息而向按标志枚举值应用掩码。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-129">The Boolean properties enable you to check each conditional, rather than requiring you to apply a mask to a flagwise enumeration value to get the information you are interested in.</span></span> <span data-ttu-id="fc8b6-130">构造函数使用串联以便 <xref:System.Windows.FrameworkPropertyMetadataOptions> 保持构造函数签名的长度合理，而实际构造的元数据公开了离散属性，使查询元数据更加直观。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-130">The constructor uses the concatenated <xref:System.Windows.FrameworkPropertyMetadataOptions> in order to keep the length of the constructor signature reasonable, whereas the actual constructed metadata exposes the discrete properties to make querying the metadata more intuitive.</span></span>  
  
<a name="override_or_subclass"></a>
## <a name="when-to-override-metadata-when-to-derive-a-class"></a><span data-ttu-id="fc8b6-131">何时重写元数据以及何时派生类</span><span class="sxs-lookup"><span data-stu-id="fc8b6-131">When to Override Metadata, When to Derive a Class</span></span>  
 <span data-ttu-id="fc8b6-132">[!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 属性系统已经建立了如下功能：在不必完全重新实现依赖属性的情况下，更改依赖属性的某些特征。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-132">The [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] property system has established capabilities for changing some characteristics of dependency properties without requiring them to be entirely re-implemented.</span></span> <span data-ttu-id="fc8b6-133">这是通过为特定类型上所存在的依赖属性构造不同的属性元数据实例来完成的。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-133">This is accomplished by constructing a different instance of property metadata for the dependency property as it exists on a particular type.</span></span> <span data-ttu-id="fc8b6-134">请注意，现有的大多数依赖属性都不是虚拟属性，因此，严格地说，只能通过隐藏现有成员来针对继承类“重新实现”依赖属性。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-134">Note that most existing dependency properties are not virtual properties, so strictly speaking "re-implementing" them on inherited classes could only be accomplished by shadowing the existing member.</span></span>  
  
 <span data-ttu-id="fc8b6-135">如果尝试对某个类型的依赖属性启用的方案不能通过修改现有依赖属性的特征来完成，则可能有必要创建一个派生类，然后为该派生类声明一个自定义依赖属性。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-135">If the scenario you are trying to enable for a dependency property on a type cannot be accomplished by modifying characteristics of existing dependency properties, it might then be necessary to create a derived class, and then to declare a custom dependency property on your derived class.</span></span> <span data-ttu-id="fc8b6-136">自定义依赖项属性的行为与 api 定义的依赖项属性的行为相同 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-136">A custom dependency property behaves identically to dependency properties defined by the [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] APIs.</span></span> <span data-ttu-id="fc8b6-137">有关自定义依赖属性的更多详细信息，请参阅[自定义依赖属性](custom-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-137">For more details about custom dependency properties, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="fc8b6-138">不能重写的依赖属性的一个显著特征就是它的值类型。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-138">One notable characteristic of a dependency property that you cannot override is its value type.</span></span> <span data-ttu-id="fc8b6-139">如果要继承的依赖属性的行为与所需的行为大体相同，但是要求它具有另一种类型，则必须实现一个自定义依赖属性，可能还需要通过类型转换或其他实现机制在自定义类上链接这些属性。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-139">If you are inheriting a dependency property that has the approximate behavior you require, but you require a different type for it, you will have to implement a custom dependency property and perhaps link the properties through type conversion or other implementation on your custom class.</span></span> <span data-ttu-id="fc8b6-140">此外，不能替换现有 <xref:System.Windows.ValidateValueCallback> 的，因为此回调存在于注册字段本身中，而不在其元数据中。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-140">Also, you cannot replace an existing <xref:System.Windows.ValidateValueCallback>, because this callback exists in the registration field itself and not within its metadata.</span></span>  
  
<a name="scenarios"></a>
## <a name="scenarios-for-changing-existing-metadata"></a><span data-ttu-id="fc8b6-141">更改现有元数据的方案</span><span class="sxs-lookup"><span data-stu-id="fc8b6-141">Scenarios for Changing Existing Metadata</span></span>  
 <span data-ttu-id="fc8b6-142">如果要处理现有依赖属性的元数据，则更改依赖属性元数据的一种常见方案是更改默认值。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-142">If you are working with metadata of an existing dependency property, one common scenario for changing dependency property metadata is to change the default value.</span></span> <span data-ttu-id="fc8b6-143">更改或添加属性系统回叫是一种更高级的方案。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-143">Changing or adding property system callbacks is a more advanced scenario.</span></span> <span data-ttu-id="fc8b6-144">如果所实现的派生类的依赖属性之间具有不同的相互关系，则你可能希望这样做。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-144">You might want to do this if your implementation of a derived class has different interrelationships between dependency properties.</span></span> <span data-ttu-id="fc8b6-145">让编程模型既支持代码又支持声明性用法的条件之一就是，属性必须能够按任何顺序设置。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-145">One of the conditionals of having a programming model that supports both code and declarative usage is that properties must enable being set in any order.</span></span> <span data-ttu-id="fc8b6-146">因此，需要在没有上下文的情况下实时设置任何依赖属性，而且可以不必知道设置顺序（例如，可能在构造函数中找到的顺序）。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-146">Thus any dependent properties need to be set just-in-time without context and cannot rely on knowing a setting order such as might be found in a constructor.</span></span> <span data-ttu-id="fc8b6-147">有关属性系统这一方面的详细信息，请参阅[依赖属性回调和验证](dependency-property-callbacks-and-validation.md)。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-147">For more information on this aspect of the property system, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md).</span></span> <span data-ttu-id="fc8b6-148">请注意，验证回叫不是元数据的一部分，而是依赖属性标识符的一部分。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-148">Note that validation callbacks are not part of the metadata; they are part of the dependency property identifier.</span></span> <span data-ttu-id="fc8b6-149">因此，不能通过重写元数据来更改验证回叫。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-149">Therefore, validation callbacks cannot be changed by overriding the metadata.</span></span>  
  
 <span data-ttu-id="fc8b6-150">在某些情况下，可能还希望在现有的依赖属性上改变 WPF 框架级别的属性元数据选项。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-150">In some cases you might also want to alter the WPF framework-level property metadata options on existing dependency properties.</span></span> <span data-ttu-id="fc8b6-151">这些选项将有关 WPF 框架级别属性的某些已知条件传递到其他 WPF 框架级别的进程，例如布局系统。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-151">These options communicate certain known conditionals about WPF framework-level properties to other WPF framework-level processes such as the layout system.</span></span>  <span data-ttu-id="fc8b6-152">通常，仅当注册新的依赖属性时才会设置选项，但也可以将 WPF 框架级别的属性元数据作为或调用的一部分进行 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 更改 <xref:System.Windows.DependencyProperty.AddOwner%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-152">Setting the options is generally done only when registering a new dependency property, but it is also possible to change the WPF framework-level property metadata as part of a <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> or <xref:System.Windows.DependencyProperty.AddOwner%2A> call.</span></span> <span data-ttu-id="fc8b6-153">有关要使用的特定值以及详细信息，请参阅[框架属性元数据](framework-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-153">For the specific values to use and more information, see [Framework Property Metadata](framework-property-metadata.md).</span></span> <span data-ttu-id="fc8b6-154">有关应当如何为新注册的依赖属性设置这些选项的详细信息，请参阅[自定义依赖属性](custom-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-154">For more information that is pertinent to how these options should be set for a newly registered dependency property, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
<a name="dp_override_metadata"></a>
### <a name="overriding-metadata"></a><span data-ttu-id="fc8b6-155">重写元数据</span><span class="sxs-lookup"><span data-stu-id="fc8b6-155">Overriding Metadata</span></span>  
 <span data-ttu-id="fc8b6-156">重写元数据的主要目的在于，使你有机会更改各种派生自元数据的行为，这些行为应用于类型上存在的依赖属性。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-156">The purpose of overriding metadata is primarily so that you have the opportunity to change the various metadata-derived behaviors that are applied to the dependency property as it exists on your type.</span></span> <span data-ttu-id="fc8b6-157">[元数据](#dp_metadata_contents)一节中更详细地介绍了重写元数据的原因。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-157">The reasons for this are explained in more detail in the [Metadata](#dp_metadata_contents) section.</span></span> <span data-ttu-id="fc8b6-158">有关详细信息（包括一些代码示例），请参阅[重写依赖属性的元数据](how-to-override-metadata-for-a-dependency-property.md)。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-158">For more information including some code examples, see [Override Metadata for a Dependency Property](how-to-override-metadata-for-a-dependency-property.md).</span></span>  
  
 <span data-ttu-id="fc8b6-159">可以在注册调用期间为依赖属性提供属性元数据， (<xref:System.Windows.DependencyProperty.Register%2A>) 。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-159">Property metadata can be supplied for a dependency property during the registration call (<xref:System.Windows.DependencyProperty.Register%2A>).</span></span> <span data-ttu-id="fc8b6-160">但是，在许多情况下，当类继承该依赖属性时，你可能希望为该类提供特定于类型的元数据。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-160">However, in many cases, you might want to provide type-specific metadata for your class when it inherits that dependency property.</span></span> <span data-ttu-id="fc8b6-161">可以通过调用方法来执行此操作 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-161">You can do this by calling the <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method.</span></span>  <span data-ttu-id="fc8b6-162">对于来自 api 的示例 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] ， <xref:System.Windows.FrameworkElement> 类是第一次注册依赖属性的类型 <xref:System.Windows.UIElement.Focusable%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-162">For an example from the [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] APIs, the <xref:System.Windows.FrameworkElement> class is the type that first registers the <xref:System.Windows.UIElement.Focusable%2A> dependency property.</span></span> <span data-ttu-id="fc8b6-163">但是， <xref:System.Windows.Controls.Control> 类会重写依赖属性的元数据，以提供其自己的初始默认值，将其从更改 `false` 为 `true` ，否则会重新使用原始 <xref:System.Windows.UIElement.Focusable%2A> 实现。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-163">But the <xref:System.Windows.Controls.Control> class overrides metadata for the dependency property to provide its own initial default value, changing it from `false` to `true`, and otherwise re-uses the original <xref:System.Windows.UIElement.Focusable%2A> implementation.</span></span>  
  
 <span data-ttu-id="fc8b6-164">当你重写元数据时，系统会合并或替换不同的元数据特征。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-164">When you override metadata, the different metadata characteristics are either merged or replaced.</span></span>  
  
- <span data-ttu-id="fc8b6-165"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 合并。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-165"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is merged.</span></span> <span data-ttu-id="fc8b6-166">如果添加新 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 的，则该回调将存储在元数据中。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-166">If you add a new <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>, that callback is stored in the metadata.</span></span> <span data-ttu-id="fc8b6-167">如果未 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 在重写中指定，则的值 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 将从在元数据中指定的最接近的上级中升级为引用。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-167">If you do not specify a <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is promoted as a reference from the nearest ancestor that specified it in metadata.</span></span>  
  
- <span data-ttu-id="fc8b6-168">的实际属性系统行为 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 是：在层次结构中的所有元数据所有者的实现将被保留并添加到表中，属性系统执行顺序是首先调用派生程度最高的派生类的回调。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-168">The actual property system behavior for <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is that implementations for all metadata owners in the hierarchy are retained and added to a table, with order of execution by the property system being that the most derived class's callbacks are invoked first.</span></span>  
  
- <span data-ttu-id="fc8b6-169"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> 被替换。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-169"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> is replaced.</span></span> <span data-ttu-id="fc8b6-170">如果未 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 在重写中指定，则的值来自在 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 元数据中指定它的最近上级。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-170">If you do not specify a <xref:System.Windows.PropertyMetadata.DefaultValue%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.DefaultValue%2A> comes from the nearest ancestor that specified it in metadata.</span></span>  
  
- <span data-ttu-id="fc8b6-171"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 替换实现。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-171"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementations are replaced.</span></span> <span data-ttu-id="fc8b6-172">如果添加新 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 的，则该回调将存储在元数据中。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-172">If you add a new <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>, that callback is stored in the metadata.</span></span> <span data-ttu-id="fc8b6-173">如果未 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 在重写中指定，则的值 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 将从在元数据中指定的最接近的上级中升级为引用。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-173">If you do not specify a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is promoted as a reference from the nearest ancestor that specified it in metadata.</span></span>  
  
- <span data-ttu-id="fc8b6-174">属性系统行为是只 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 调用直接元数据中的。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-174">The property system behavior is that only the <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> in the immediate metadata is invoked.</span></span> <span data-ttu-id="fc8b6-175">不 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 会保留对层次结构中的其他实现的引用。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-175">No references to other <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementations in the hierarchy are retained.</span></span>  
  
 <span data-ttu-id="fc8b6-176">此行为由实现 <xref:System.Windows.PropertyMetadata.Merge%2A> ，并且可在派生的元数据类上重写。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-176">This behavior is implemented by <xref:System.Windows.PropertyMetadata.Merge%2A>, and can be overridden on derived metadata classes.</span></span>  
  
#### <a name="overriding-attached-property-metadata"></a><span data-ttu-id="fc8b6-177">重写附加属性元数据</span><span class="sxs-lookup"><span data-stu-id="fc8b6-177">Overriding Attached Property Metadata</span></span>  
 <span data-ttu-id="fc8b6-178">在 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 中，附加属性作为依赖属性来实现。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-178">In [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)], attached properties are implemented as dependency properties.</span></span> <span data-ttu-id="fc8b6-179">这意味着它们还具有能够由个别类重写的属性元数据。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-179">This means that they also have property metadata, which individual classes can override.</span></span> <span data-ttu-id="fc8b6-180">中附加属性的作用域注意事项 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 通常是在 <xref:System.Windows.DependencyObject> 其上设置附加属性。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-180">The scoping considerations for an attached property in [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] are generally that any <xref:System.Windows.DependencyObject> can have an attached property set on them.</span></span> <span data-ttu-id="fc8b6-181">因此，任何 <xref:System.Windows.DependencyObject> 派生类都可以重写任何附加属性的元数据，因为它可能是在类的实例上设置的。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-181">Therefore, any <xref:System.Windows.DependencyObject> derived class can override the metadata for any attached property, as it might be set on an instance of the class.</span></span> <span data-ttu-id="fc8b6-182">可以重写默认值、回叫或 WPF 框架级别的特征报告属性。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-182">You can override default values, callbacks, or WPF framework-level characteristic-reporting properties.</span></span> <span data-ttu-id="fc8b6-183">如果针对类的实例设置了附加属性，则这些重写属性元数据特征将适用。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-183">If the attached property is set on an instance of your class, those override property metadata characteristics apply.</span></span> <span data-ttu-id="fc8b6-184">例如，可以重写默认值，这样，只要未以其他方式设置附加属性，重写值就会报告为类实例的附加属性的值。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-184">For instance, you can override the default value, such that your override value is reported as the value of the attached property on instances of your class, whenever the property is not otherwise set.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="fc8b6-185"><xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>属性与附加属性无关。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-185">The <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> property is not relevant for attached properties.</span></span>  
  
<a name="dp_add_owner"></a>
### <a name="adding-a-class-as-an-owner-of-an-existing-dependency-property"></a><span data-ttu-id="fc8b6-186">将类作为现有依赖属性的所有者来添加</span><span class="sxs-lookup"><span data-stu-id="fc8b6-186">Adding a Class as an Owner of an Existing Dependency Property</span></span>  
 <span data-ttu-id="fc8b6-187">类可以使用方法将自身添加为已注册的依赖属性的所有者 <xref:System.Windows.DependencyProperty.AddOwner%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-187">A class can add itself as an owner of a dependency property that has already been registered, by using the <xref:System.Windows.DependencyProperty.AddOwner%2A> method.</span></span> <span data-ttu-id="fc8b6-188">这使得该类可以使用最初针对另一个类型注册的依赖属性。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-188">This enables the class to use a dependency property that was originally registered for a different type.</span></span> <span data-ttu-id="fc8b6-189">添加类通常不是首先将该依赖属性注册为所有者的类型的派生类。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-189">The adding class is typically not a derived class of the type that first registered that dependency property as owner.</span></span> <span data-ttu-id="fc8b6-190">实际上，这使类及其派生类可以“继承”依赖属性实现，而不需要最初的所有者类，而且添加类也不必位于同一个实际的类层次结构中。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-190">Effectively, this allows your class and its derived classes to "inherit" a dependency property implementation without the original owner class and the adding class being in the same true class hierarchy.</span></span> <span data-ttu-id="fc8b6-191">另外，添加类（以及所有派生类）随后可以为最初的依赖属性提供特定于类型的元数据。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-191">In addition, the adding class (and all derived classes as well) can then provide type-specific metadata for the original dependency property.</span></span>  
  
 <span data-ttu-id="fc8b6-192">添加类除了通过属性系统的实用工具方法将自身添加为所有者以外，还应当在自身声明其他公共成员，以使依赖属性向代码和标记公开，从而完全参与属性系统。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-192">As well as adding itself as owner through the property system utility methods, the adding class should declare additional public members on itself in order to make the dependency property] a full participant in the property system with exposure to both code and markup.</span></span> <span data-ttu-id="fc8b6-193">就为依赖属性公开对象模型而言，添加现有依赖属性的类与定义新的自定义依赖属性的类具有相同的职责。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-193">A class that adds an existing dependency property has the same responsibilities as far as exposing the object model for that dependency property as does a class that defines a new custom dependency property.</span></span> <span data-ttu-id="fc8b6-194">要公开的第一个此类成员是依赖属性标识符字段。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-194">The first such member to expose is a dependency property identifier field.</span></span> <span data-ttu-id="fc8b6-195">此字段应为 `public static readonly` 类型为的字段 <xref:System.Windows.DependencyProperty> ，该字段将分配给调用的返回值 <xref:System.Windows.DependencyProperty.AddOwner%2A> 。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-195">This field should be a `public static readonly` field of type <xref:System.Windows.DependencyProperty>, which is assigned to the return value of the <xref:System.Windows.DependencyProperty.AddOwner%2A> call.</span></span> <span data-ttu-id="fc8b6-196">要定义的第二个成员是公共语言运行时 (CLR) "包装器" 属性。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-196">The second member to define is the common language runtime (CLR) "wrapper" property.</span></span> <span data-ttu-id="fc8b6-197">包装使你可以更方便地在代码中操作依赖属性 (避免 <xref:System.Windows.DependencyObject.SetValue%2A> 每次调用，并可以在包装器自身) 只调用一次。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-197">The wrapper makes it much more convenient to manipulate your dependency property in code (you avoid calls to <xref:System.Windows.DependencyObject.SetValue%2A> each time, and can make that call only once in the wrapper itself).</span></span> <span data-ttu-id="fc8b6-198">包装器的实现方式与在注册自定义依赖属性时的实现方式完全相同。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-198">The wrapper is implemented identically to how it would be implemented if you were registering a custom dependency property.</span></span> <span data-ttu-id="fc8b6-199">有关实现依赖属性的详细信息，请参阅[自定义依赖属性](custom-dependency-properties.md)和[为依赖属性添加所有者类型](how-to-add-an-owner-type-for-a-dependency-property.md)。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-199">For more information about implementing a dependency property, see [Custom Dependency Properties](custom-dependency-properties.md) and [Add an Owner Type for a Dependency Property](how-to-add-an-owner-type-for-a-dependency-property.md).</span></span>  
  
#### <a name="addowner-and-attached-properties"></a><span data-ttu-id="fc8b6-200">AddOwner 和附加属性</span><span class="sxs-lookup"><span data-stu-id="fc8b6-200">AddOwner and Attached Properties</span></span>  
 <span data-ttu-id="fc8b6-201">可以调用 <xref:System.Windows.DependencyProperty.AddOwner%2A> 由所有者类定义为附加属性的依赖属性。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-201">You can call <xref:System.Windows.DependencyProperty.AddOwner%2A> for a dependency property that is defined as an attached property by the owner class.</span></span> <span data-ttu-id="fc8b6-202">这样做的目的通常是为了将以前附加的属性作为非附加依赖属性来公开。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-202">Generally the reason for doing this is to expose the previously attached property as a non-attached dependency property.</span></span> <span data-ttu-id="fc8b6-203">然后，你会将 <xref:System.Windows.DependencyProperty.AddOwner%2A> 返回值公开为用作 `public static readonly` 依赖项属性标识符的字段，并将定义适当的 "包装器" 属性，以便属性显示在成员表中并支持类中的非附加属性用法。</span><span class="sxs-lookup"><span data-stu-id="fc8b6-203">You then will expose the <xref:System.Windows.DependencyProperty.AddOwner%2A> return value as a `public static readonly` field for use as the dependency property identifier, and will define appropriate "wrapper" properties so that the property appears in the members table and supports a non-attached property usage in your class.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="fc8b6-204">请参阅</span><span class="sxs-lookup"><span data-stu-id="fc8b6-204">See also</span></span>

- <xref:System.Windows.PropertyMetadata>
- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- <xref:System.Windows.DependencyProperty.GetMetadata%2A>
- [<span data-ttu-id="fc8b6-205">依赖项属性概述</span><span class="sxs-lookup"><span data-stu-id="fc8b6-205">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="fc8b6-206">框架属性元数据</span><span class="sxs-lookup"><span data-stu-id="fc8b6-206">Framework Property Metadata</span></span>](framework-property-metadata.md)
