---
title: 框架属性元数据
ms.date: 03/30/2017
helpviewer_keywords:
- metadata [WPF], framework properties
- framework property metadata [WPF]
ms.assetid: 9962f380-b885-4b61-a62e-457397083fea
ms.openlocfilehash: 33ed083a3ad26d52f3ffed8b757719f21d8bae32
ms.sourcegitcommit: 069786bcadbf9cd931d7dc3d892262cd852d2ffb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/19/2021
ms.locfileid: "104665453"
---
# <a name="framework-property-metadata"></a><span data-ttu-id="d2e7a-102">框架属性元数据</span><span class="sxs-lookup"><span data-stu-id="d2e7a-102">Framework Property Metadata</span></span>
<span data-ttu-id="d2e7a-103">对于 [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] 体系结构中被视为 WPF 框架级的对象元素的属性，将报告框架属性元数据选项。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-103">Framework property metadata options are reported for the properties of object elements considered to be at the WPF framework level in the [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] architecture.</span></span> <span data-ttu-id="d2e7a-104">通常，WPF 框架级别的指定要求呈现 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] api 和可执行文件处理呈现、数据绑定和属性系统优化等功能。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-104">In general the WPF framework-level designation entails that features such as rendering, data binding, and property system refinements are handled by the [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] presentation APIs and executables.</span></span> <span data-ttu-id="d2e7a-105">这些系统对框架属性元数据进行查询，以便为特定的元素属性确定特定于功能的特征。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-105">Framework property metadata is queried by these systems to determine feature-specific characteristics of particular element properties.</span></span>  

<a name="prerequisites"></a>
## <a name="prerequisites"></a><span data-ttu-id="d2e7a-106">必备条件</span><span class="sxs-lookup"><span data-stu-id="d2e7a-106">Prerequisites</span></span>  
 <span data-ttu-id="d2e7a-107">本主题假定你从 [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] 类的现有依赖属性的使用者角度了解依赖属性，并且已阅读[依赖属性概述](dependency-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-107">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md).</span></span> <span data-ttu-id="d2e7a-108">另外，应当已阅读[依赖属性元数据](dependency-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-108">You should also have read [Dependency Property Metadata](dependency-property-metadata.md).</span></span>  
  
<a name="What_Is_Communicated_by_Framework_Property"></a>
## <a name="what-is-communicated-by-framework-property-metadata"></a><span data-ttu-id="d2e7a-109">框架属性元数据传达的信息</span><span class="sxs-lookup"><span data-stu-id="d2e7a-109">What Is Communicated by Framework Property Metadata</span></span>  
 <span data-ttu-id="d2e7a-110">框架属性元数据分为以下类别：</span><span class="sxs-lookup"><span data-stu-id="d2e7a-110">Framework property metadata can be divided into the following categories:</span></span>  
  
- <span data-ttu-id="d2e7a-111">报表 (、) 影响元素的布局 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 属性 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> 。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-111">Reporting layout properties that affect an element (<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>).</span></span> <span data-ttu-id="d2e7a-112">如果属性影响到各个方面，则可以在元数据中设置这些标志，还可以实现 <xref:System.Windows.FrameworkElement.MeasureOverride%2A>  /  <xref:System.Windows.FrameworkElement.ArrangeOverride%2A> 类中的方法，以向布局系统提供特定的呈现行为和信息。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-112">You might set these flags in metadata if the property affects those respective aspects, and you are also implementing the <xref:System.Windows.FrameworkElement.MeasureOverride%2A> / <xref:System.Windows.FrameworkElement.ArrangeOverride%2A> methods in your class to supply specific rendering behavior and information to the layout system.</span></span> <span data-ttu-id="d2e7a-113">通常，如果在属性元数据中有布局属性为 true，则此类实现会在依赖属性中检查属性是否无效，并且只有无效属性才必须请求新的布局处理过程。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-113">Typically, such an implementation would check for property invalidations in dependency properties where any of these layout properties were true in the property metadata, and only those invalidations would necessitate requesting a new layout pass.</span></span>  
  
- <span data-ttu-id="d2e7a-114">报告影响元素的父元素的布局属性 (<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> ， <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>) 。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-114">Reporting layout properties that affect the parent element of an element (<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>).</span></span> <span data-ttu-id="d2e7a-115">默认情况下，设置这些标志的一些示例为 <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> 和 <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-115">Some examples where these flags are set by default are <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> and <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType>.</span></span>  
  
- <span data-ttu-id="d2e7a-116"><xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2e7a-116"><xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>.</span></span> <span data-ttu-id="d2e7a-117">默认情况下，依赖属性不会继承值。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-117">By default, dependency properties do not inherit values.</span></span> <span data-ttu-id="d2e7a-118"><xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> 允许将继承的路径传递到可视化树，这对于某些控件组合方案是必需的。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-118"><xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> allows the pathway of inheritance to also travel into a visual tree, which is necessary for some control compositing scenarios.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="d2e7a-119">属性值上下文中的术语“继承”指特定于依赖属性的情况；它意味着由于存在 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 属性系统的 WPF 框架级功能，子元素可以从父元素继承实际的依赖属性值。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-119">The term "inherits" in the context of property values means something specific for dependency properties; it means that child elements can inherit the actual dependency property value from parent elements because of a WPF framework-level capability of the [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] property system.</span></span> <span data-ttu-id="d2e7a-120">它与通过派生类型的托管代码类型和成员继承没有直接关系。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-120">It has nothing to do directly with managed code type and members inheritance through derived types.</span></span> <span data-ttu-id="d2e7a-121">有关详细信息，请参阅[属性值继承](property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-121">For details, see [Property Value Inheritance](property-value-inheritance.md).</span></span>  
  
- <span data-ttu-id="d2e7a-122">报表数据绑定特征 (<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> ， <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>) 。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-122">Reporting data binding characteristics (<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>).</span></span> <span data-ttu-id="d2e7a-123">默认情况下，框架中的依赖属性支持具有单向绑定行为的数据绑定。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-123">By default, dependency properties in the framework support data binding, with a one-way binding behavior.</span></span> <span data-ttu-id="d2e7a-124">如果没有 (的方案，则可以禁用数据绑定，因为它们的用途是灵活且可扩展的，所以在默认 api) 中没有很多示例 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-124">You might disable data binding if there were no scenario for it whatsoever (because they are intended to be flexible and extensible, there aren't many examples of such properties in the default [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] APIs).</span></span> <span data-ttu-id="d2e7a-125">你可以将绑定设置为具有两种默认值，用于在其组件部分之间绑定控件行为的属性 (<xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> 是一个示例) 或者，双向绑定是用户 (的 <xref:System.Windows.Controls.TextBox.Text%2A> 一个示例) 。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-125">You might set binding to have a two-way default for properties that tie together a control's behaviors amongst its component pieces (<xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> is an example) or where two-way binding is the common and expected scenario for users (<xref:System.Windows.Controls.TextBox.Text%2A> is an example).</span></span> <span data-ttu-id="d2e7a-126">更改与数据绑定相关的元数据只会影响默认值；始终可以根据各个绑定更改此默认值。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-126">Changing the data binding–related metadata only influences the default; on a per-binding basis that default can always be changed.</span></span> <span data-ttu-id="d2e7a-127">若要详细了解常规的绑定模式和绑定，请参阅[数据绑定概述](/dotnet/desktop-wpf/data/data-binding-overview)。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-127">For details on the binding modes and binding in general, see [Data Binding Overview](/dotnet/desktop-wpf/data/data-binding-overview).</span></span>  
  
- <span data-ttu-id="d2e7a-128">报告是否应按支持日记 () 的应用程序或服务记录属性 <xref:System.Windows.FrameworkPropertyMetadata.Journal%2A> 。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-128">Reporting whether properties should be journaled by applications or services that support journaling (<xref:System.Windows.FrameworkPropertyMetadata.Journal%2A>).</span></span> <span data-ttu-id="d2e7a-129">对于一般的元素，默认情况下不会启用日记记录功能，但可针对特定用户输入控件有选择性地启用。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-129">For general elements, journaling is not enabled by default, but it is selectively enabled for certain user input controls.</span></span> <span data-ttu-id="d2e7a-130">此属性专门由日记记录的 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 实现等日记记录服务读取，并且通常针对用户控件（例如用户在列表中选择的应在各导航步骤中保留的控件）设置此属性。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-130">This property is intended to be read by journaling services including the [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] implementation of journaling, and is typically set on user controls such as user selections within lists that should be persisted across navigation steps.</span></span> <span data-ttu-id="d2e7a-131">有关日记的信息，请参阅[导航概述](../app-development/navigation-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-131">For information about the journal, see [Navigation Overview](../app-development/navigation-overview.md).</span></span>  
  
<a name="Reading_FrameworkPropertyMetadata"></a>
## <a name="reading-frameworkpropertymetadata"></a><span data-ttu-id="d2e7a-132">读取 FrameworkPropertyMetadata</span><span class="sxs-lookup"><span data-stu-id="d2e7a-132">Reading FrameworkPropertyMetadata</span></span>  
 <span data-ttu-id="d2e7a-133">以上链接的每个属性都是 <xref:System.Windows.FrameworkPropertyMetadata> 添加到其直接基类的特定属性 <xref:System.Windows.UIPropertyMetadata> 。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-133">Each of the properties linked above are the specific properties that the <xref:System.Windows.FrameworkPropertyMetadata> adds to its immediate base class <xref:System.Windows.UIPropertyMetadata>.</span></span> <span data-ttu-id="d2e7a-134">默认情况下，这些属性都为 `false`。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-134">Each of these properties will be `false` by default.</span></span> <span data-ttu-id="d2e7a-135">在知道这些属性的值的情况下，属性的元数据请求应尝试将返回的元数据强制转换为 <xref:System.Windows.FrameworkPropertyMetadata> ，然后根据需要检查各个属性的值。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-135">A metadata request for a property where knowing the value of these properties is important should attempt to cast the returned metadata to <xref:System.Windows.FrameworkPropertyMetadata>, and then check the values of the individual properties as needed.</span></span>  
  
<a name="Specifying_Metadata"></a>
## <a name="specifying-metadata"></a><span data-ttu-id="d2e7a-136">指定元数据</span><span class="sxs-lookup"><span data-stu-id="d2e7a-136">Specifying Metadata</span></span>  
 <span data-ttu-id="d2e7a-137">当你创建新的元数据实例以将元数据应用于新的依赖属性注册时，你可以选择要使用的元数据类：基 <xref:System.Windows.PropertyMetadata> 或一些派生类（如） <xref:System.Windows.FrameworkPropertyMetadata> 。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-137">When you create a new metadata instance for purposes of applying metadata to a new dependency property registration, you have the choice of which metadata class to use: the base <xref:System.Windows.PropertyMetadata> or some derived class such as <xref:System.Windows.FrameworkPropertyMetadata>.</span></span> <span data-ttu-id="d2e7a-138">通常情况下，应使用 <xref:System.Windows.FrameworkPropertyMetadata> ，特别是在属性与属性系统和 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 功能（如布局和数据绑定）交互的情况下。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-138">In general, you should use <xref:System.Windows.FrameworkPropertyMetadata>, particularly if your property has any interaction with property system and [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] functions such as layout and data binding.</span></span> <span data-ttu-id="d2e7a-139">对于更复杂的方案，另一个选项是从派生 <xref:System.Windows.FrameworkPropertyMetadata> ，以创建自己的元数据报告类，并在其成员中携带额外的信息。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-139">Another option for more sophisticated scenarios is to derive from <xref:System.Windows.FrameworkPropertyMetadata> to create your own metadata reporting class with extra information carried in its members.</span></span> <span data-ttu-id="d2e7a-140">或者，你可以使用 <xref:System.Windows.PropertyMetadata> 或 <xref:System.Windows.UIPropertyMetadata> 来传达实现的功能的支持程度。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-140">Or you might use <xref:System.Windows.PropertyMetadata> or <xref:System.Windows.UIPropertyMetadata> to communicate the degree of support for features of your implementation.</span></span>  
  
 <span data-ttu-id="d2e7a-141">对于 (<xref:System.Windows.DependencyProperty.AddOwner%2A> 或调用) 的现有属性 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> ，应始终使用初始注册使用的元数据类型重写。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-141">For existing properties (<xref:System.Windows.DependencyProperty.AddOwner%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> call), you should always override with the metadata type used by the original registration.</span></span>  
  
 <span data-ttu-id="d2e7a-142">如果创建的是 <xref:System.Windows.FrameworkPropertyMetadata> 实例，可以通过两种方式来使用传达框架属性特征的特定属性的值来填充元数据：</span><span class="sxs-lookup"><span data-stu-id="d2e7a-142">If you are creating a <xref:System.Windows.FrameworkPropertyMetadata> instance, there are two ways to populate that metadata with values for the specific properties that communicate the framework property characteristics:</span></span>  
  
1. <span data-ttu-id="d2e7a-143">使用 <xref:System.Windows.FrameworkPropertyMetadata> 允许使用参数的构造函数 `flags` 签名。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-143">Use the <xref:System.Windows.FrameworkPropertyMetadata> constructor signature that allows a `flags` parameter.</span></span> <span data-ttu-id="d2e7a-144">应为此参数填充枚举标志的所有所需的组合值 <xref:System.Windows.FrameworkPropertyMetadataOptions> 。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-144">This parameter should be filled with all desired combined values of the <xref:System.Windows.FrameworkPropertyMetadataOptions> enumeration flags.</span></span>  
  
2. <span data-ttu-id="d2e7a-145">使用不带参数的其中一个签名 `flags` ，然后将每个报告的布尔属性设置为，以 <xref:System.Windows.FrameworkPropertyMetadata> `true` 针对每个所需的特征更改。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-145">Use one of the signatures without a `flags` parameter, and then set each reporting Boolean property on <xref:System.Windows.FrameworkPropertyMetadata> to `true` for each desired characteristic change.</span></span> <span data-ttu-id="d2e7a-146">为此，必须在构造具有此依赖属性的任何元素之前对这些属性进行设置；布尔属性是可读写属性，以允许此项避免 `flags` 参数的行为，同时仍然可以填充元数据，但元数据必须在属性使用之前进行有效密封。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-146">If you do this, you must set these properties before any elements with this dependency property are constructed; the Boolean properties are read-write in order to allow this behavior of avoiding the `flags` parameter and still populate the metadata, but the metadata must become effectively sealed before property use.</span></span> <span data-ttu-id="d2e7a-147">因此，尝试在请求元数据之后设置属性是无效操作。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-147">Thus, attempting to set the properties after metadata is requested will be an invalid operation.</span></span>  
  
<a name="Framework_Property_Metadata_Merge_Behavior"></a>
## <a name="framework-property-metadata-merge-behavior"></a><span data-ttu-id="d2e7a-148">框架属性元数据合并行为</span><span class="sxs-lookup"><span data-stu-id="d2e7a-148">Framework Property Metadata Merge Behavior</span></span>  
 <span data-ttu-id="d2e7a-149">重写框架属性元数据时，会合并或替换不同的元数据特征。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-149">When you override framework property metadata, the different metadata characteristics are either merged or replaced.</span></span>  
  
- <span data-ttu-id="d2e7a-150"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 合并。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-150"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is merged.</span></span> <span data-ttu-id="d2e7a-151">如果添加新 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 的，则该回调将存储在元数据中。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-151">If you add a new <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>, that callback is stored in the metadata.</span></span> <span data-ttu-id="d2e7a-152">如果未 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 在重写中指定，则的值 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 将从在元数据中指定的最接近的上级中升级为引用。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-152">If you do not specify a <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is promoted as a reference from the nearest ancestor that specified it in metadata.</span></span>  
  
- <span data-ttu-id="d2e7a-153">的实际属性系统行为 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 是：在层次结构中的所有元数据所有者的实现将被保留并添加到表中，属性系统执行顺序是先调用最深层派生类的回调。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-153">The actual property system behavior for <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is that implementations for all metadata owners in the hierarchy are retained and added to a table, with order of execution by the property system being that the callbacks of the most deeply derived class are invoked first.</span></span> <span data-ttu-id="d2e7a-154">继承的回叫仅运行一次，当将这些回叫放置在元数据中的类占有时计数。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-154">Inherited callbacks run only once, counting as being owned by the class that placed them in metadata.</span></span>  
  
- <span data-ttu-id="d2e7a-155"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> 被替换。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-155"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> is replaced.</span></span> <span data-ttu-id="d2e7a-156">如果未 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 在重写中指定，则的值来自在 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 元数据中指定它的最近上级。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-156">If you do not specify a <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.DefaultValue%2A> comes from the nearest ancestor that specified it in metadata.</span></span>  
  
- <span data-ttu-id="d2e7a-157"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 替换实现。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-157"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementations are replaced.</span></span> <span data-ttu-id="d2e7a-158">如果添加新 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 的，则该回调将存储在元数据中。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-158">If you add a new <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>, that callback is stored in the metadata.</span></span> <span data-ttu-id="d2e7a-159">如果未 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 在重写中指定，则的值 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 将从在元数据中指定的最接近的上级中升级为引用。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-159">If you do not specify a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is promoted as a reference from the nearest ancestor that specified it in metadata.</span></span>  
  
- <span data-ttu-id="d2e7a-160">属性系统行为是只 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 调用直接元数据中的。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-160">The property system behavior is that only the <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> in the immediate metadata is invoked.</span></span> <span data-ttu-id="d2e7a-161">不 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 会保留对层次结构中的其他实现的引用。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-161">No references to other <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementations in the hierarchy are retained.</span></span>  
  
- <span data-ttu-id="d2e7a-162">枚举的标志 <xref:System.Windows.FrameworkPropertyMetadataOptions> 合并为按位 "或" 运算。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-162">The flags of <xref:System.Windows.FrameworkPropertyMetadataOptions> enumeration are combined as a bitwise OR operation.</span></span>  <span data-ttu-id="d2e7a-163">如果指定 <xref:System.Windows.FrameworkPropertyMetadataOptions> ，则不会覆盖原始选项。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-163">If you specify <xref:System.Windows.FrameworkPropertyMetadataOptions>, the original options are not overwritten.</span></span>  <span data-ttu-id="d2e7a-164">若要更改选项，请在上设置相应的属性 <xref:System.Windows.FrameworkPropertyMetadata> 。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-164">To change an option, set the corresponding property on <xref:System.Windows.FrameworkPropertyMetadata>.</span></span> <span data-ttu-id="d2e7a-165">例如，如果原始 <xref:System.Windows.FrameworkPropertyMetadata> 对象设置了 <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable?displayProperty=nameWithType> 标志，则可以通过将设置为来更改该标志 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A?displayProperty=nameWithType> `false` 。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-165">For example, if the original <xref:System.Windows.FrameworkPropertyMetadata> object sets the <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable?displayProperty=nameWithType> flag, you can change that by setting <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A?displayProperty=nameWithType> to `false`.</span></span>  
  
 <span data-ttu-id="d2e7a-166">此行为由实现 <xref:System.Windows.FrameworkPropertyMetadata.Merge%2A> ，并且可在派生的元数据类上重写。</span><span class="sxs-lookup"><span data-stu-id="d2e7a-166">This behavior is implemented by <xref:System.Windows.FrameworkPropertyMetadata.Merge%2A>, and can be overridden on derived metadata classes.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d2e7a-167">请参阅</span><span class="sxs-lookup"><span data-stu-id="d2e7a-167">See also</span></span>

- <xref:System.Windows.DependencyProperty.GetMetadata%2A>
- [<span data-ttu-id="d2e7a-168">依赖项属性元数据</span><span class="sxs-lookup"><span data-stu-id="d2e7a-168">Dependency Property Metadata</span></span>](dependency-property-metadata.md)
- [<span data-ttu-id="d2e7a-169">依赖项属性概述</span><span class="sxs-lookup"><span data-stu-id="d2e7a-169">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="d2e7a-170">自定义依赖项属性</span><span class="sxs-lookup"><span data-stu-id="d2e7a-170">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
