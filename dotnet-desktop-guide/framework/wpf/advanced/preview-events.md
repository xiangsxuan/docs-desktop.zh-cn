---
title: 预览事件
ms.date: 03/30/2017
helpviewer_keywords:
- Preview events [WPF]
- suppressing events [WPF]
- events [WPF], Preview
- events [WPF], suppressing
ms.assetid: b5032308-aa9c-4d02-af11-630ecec8df7e
ms.openlocfilehash: 3eb60e40ed4bb5ec9cc9bc1aa9f18a4aec8bca31
ms.sourcegitcommit: 069786bcadbf9cd931d7dc3d892262cd852d2ffb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/19/2021
ms.locfileid: "104667130"
---
# <a name="preview-events"></a><span data-ttu-id="10bbc-102">预览事件</span><span class="sxs-lookup"><span data-stu-id="10bbc-102">Preview Events</span></span>
<span data-ttu-id="10bbc-103">预览事件，也称为隧道事件，是路由事件，其中路由的方向从应用程序根传到引发事件的元素，并在事件数据中报告为源。</span><span class="sxs-lookup"><span data-stu-id="10bbc-103">Preview events, also known as tunneling events, are routed events where the direction of the route travels from the application root towards the element that raised the event and is reported as the source in event data.</span></span> <span data-ttu-id="10bbc-104">并非所有事件方案都支持或要求预览事件;本主题介绍预览事件存在的情况，应用程序或组件应如何处理这些事件，以及在自定义组件或类中创建预览事件的情况可能是合适的。</span><span class="sxs-lookup"><span data-stu-id="10bbc-104">Not all event scenarios support or require preview events; this topic describes the situations where preview events exist, how applications or components should handle them, and cases where creating preview events in custom components or classes might be appropriate.</span></span>  
  
## <a name="preview-events-and-input"></a><span data-ttu-id="10bbc-105">预览事件和输入</span><span class="sxs-lookup"><span data-stu-id="10bbc-105">Preview Events and Input</span></span>  
 <span data-ttu-id="10bbc-106">通常在处理预览事件时，请注意在事件数据中标记已处理的事件。</span><span class="sxs-lookup"><span data-stu-id="10bbc-106">When you handle Preview events in general, be cautious about marking the events handled in the event data.</span></span> <span data-ttu-id="10bbc-107">在引发它的元素之外的任何元素上处理预览事件 (在事件数据) 中报告为源的元素，这会使元素无法提供处理它所源自的事件的机会。</span><span class="sxs-lookup"><span data-stu-id="10bbc-107">Handling a Preview event on any element other than the element that raised it (the element that is reported as the source in the event data) has the effect of not providing an element the opportunity to handle the event that it originated.</span></span> <span data-ttu-id="10bbc-108">有时，这是所需的结果，尤其是在控件的组合内的关系中存在相关元素时。</span><span class="sxs-lookup"><span data-stu-id="10bbc-108">Sometimes this is the desired result, particularly if the elements in question exist in relationships within the compositing of a control.</span></span>  
  
 <span data-ttu-id="10bbc-109">特别是对于输入事件，预览事件还会将事件数据实例与等效的冒泡事件共享。</span><span class="sxs-lookup"><span data-stu-id="10bbc-109">For input events specifically, Preview events also share event data instances with the equivalent bubbling event.</span></span> <span data-ttu-id="10bbc-110">如果使用预览版事件类处理程序将输入事件标记为已处理，则将不会调用冒泡 input 事件类处理程序。</span><span class="sxs-lookup"><span data-stu-id="10bbc-110">If you use a Preview event class handler to mark the input event handled, the bubbling input event class handler will not be invoked.</span></span> <span data-ttu-id="10bbc-111">或者，如果使用预览版事件实例处理程序将事件标记为已处理，则通常不会调用冒泡事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="10bbc-111">Or, if you use a Preview event instance handler to mark the event handled, handlers for the bubbling event will not typically be invoked.</span></span> <span data-ttu-id="10bbc-112">类处理程序或实例处理程序可以通过调用的选项进行注册或附加，即使该事件标记为已处理，但这种方法并不常用。</span><span class="sxs-lookup"><span data-stu-id="10bbc-112">Class handlers or instance handlers can be registered or attached with an option to be invoked even if the event is marked handled, but that technique is not commonly used.</span></span>  
  
 <span data-ttu-id="10bbc-113">有关类处理以及它如何与预览事件相关的详细信息，请参阅将 [路由事件标记为 "已处理" 和 "类处理"](marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="10bbc-113">For more information about class handling and how it relates to Preview events see [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
### <a name="working-around-event-suppression-by-controls"></a><span data-ttu-id="10bbc-114">通过控件解决事件禁止问题</span><span class="sxs-lookup"><span data-stu-id="10bbc-114">Working Around Event Suppression by Controls</span></span>  
 <span data-ttu-id="10bbc-115">通常使用预览事件的一种情况是对输入事件的复合控件处理。</span><span class="sxs-lookup"><span data-stu-id="10bbc-115">One scenario where Preview events are commonly used is for composited control handling of input events.</span></span> <span data-ttu-id="10bbc-116">有时，控件的作者会禁止某个事件从其控件发出，这可能是为了替换携带详细信息或表示更具体的行为的组件定义的事件。</span><span class="sxs-lookup"><span data-stu-id="10bbc-116">Sometimes, the author of the control suppresses a certain event from originating from their control, perhaps in order to substitute a component-defined event that carries more information or implies a more specific behavior.</span></span> <span data-ttu-id="10bbc-117">例如， [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> <xref:System.Windows.UIElement.MouseLeftButtonDown> <xref:System.Windows.UIElement.MouseRightButtonDown> 由或其复合元素引发的禁止显示和冒泡事件， <xref:System.Windows.Controls.Button> 以捕获鼠标并引发 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 始终由自身引发的事件 <xref:System.Windows.Controls.Button> 。</span><span class="sxs-lookup"><span data-stu-id="10bbc-117">For instance, a [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> suppresses <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseRightButtonDown> bubbling events raised by the <xref:System.Windows.Controls.Button> or its composite elements in favor of capturing the mouse and raising a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event that is always raised by the <xref:System.Windows.Controls.Button> itself.</span></span> <span data-ttu-id="10bbc-118">事件及其数据仍沿路由继续，但由于将 <xref:System.Windows.Controls.Button> 事件数据标记为 <xref:System.Windows.RoutedEventArgs.Handled%2A> ，因此只会调用专门指示它们应在事例中操作的事件的处理程序 `handledEventsToo` 。</span><span class="sxs-lookup"><span data-stu-id="10bbc-118">The event and its data still continue along the route, but because the <xref:System.Windows.Controls.Button> marks the event data as <xref:System.Windows.RoutedEventArgs.Handled%2A>, only handlers for the event that specifically indicated they should act in the `handledEventsToo` case  are invoked.</span></span>  <span data-ttu-id="10bbc-119">如果应用程序根的其他元素仍希望有机会处理控制抑制的事件，另一种方法是将处理程序附加到 `handledEventsToo` 指定为的代码中 `true` 。</span><span class="sxs-lookup"><span data-stu-id="10bbc-119">If other elements towards the root of your application still wanted an opportunity to handle a control-suppressed event, one alternative is to attach handlers in code with `handledEventsToo` specified as `true`.</span></span> <span data-ttu-id="10bbc-120">但通常，一种更简单的方法是将所处理的路由方向更改为与输入事件等效的预览。</span><span class="sxs-lookup"><span data-stu-id="10bbc-120">But often a simpler technique is to change the routing direction you handle to be the Preview equivalent of an input event.</span></span> <span data-ttu-id="10bbc-121">例如，如果控件禁止显示 <xref:System.Windows.UIElement.MouseLeftButtonDown> ，请改为尝试附加处理程序 <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> 。</span><span class="sxs-lookup"><span data-stu-id="10bbc-121">For instance, if a control suppresses <xref:System.Windows.UIElement.MouseLeftButtonDown>, try attaching a handler for <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> instead.</span></span> <span data-ttu-id="10bbc-122">此方法仅适用于基元素输入事件，例如 <xref:System.Windows.UIElement.MouseLeftButtonDown> 。</span><span class="sxs-lookup"><span data-stu-id="10bbc-122">This technique only works for base element input events such as <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="10bbc-123">这些输入事件使用隧道/冒泡对，引发这两个事件，并共享事件数据。</span><span class="sxs-lookup"><span data-stu-id="10bbc-123">These input events use tunnel/bubble pairs, raise both events, and share the event data.</span></span>  
  
 <span data-ttu-id="10bbc-124">上述每种方法都有副作用或限制。</span><span class="sxs-lookup"><span data-stu-id="10bbc-124">Each of these techniques has either side effects or limitations.</span></span> <span data-ttu-id="10bbc-125">处理预览事件的副作用是，在该点处理事件可能会禁用预期处理冒泡事件的处理程序，因此限制是在事件仍处于路由的预览部分时将事件标记为已处理是不是很好的做法。</span><span class="sxs-lookup"><span data-stu-id="10bbc-125">The side effect of handling the Preview event is that handling the event at that point might disable handlers that expect to handle the bubbling event, and therefore the limitation is that it is usually not a good idea to mark the event handled while it is still on the Preview part of the route.</span></span> <span data-ttu-id="10bbc-126">此方法的限制 `handledEventsToo` 是，您不能 `handledEventsToo` 在中指定处理程序 [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] 作为属性，您必须在获取对要附加处理程序的元素的对象引用后，在代码中注册事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="10bbc-126">The limitation of the `handledEventsToo` technique is that you cannot specify a `handledEventsToo` handler in [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] as an attribute, you must register the event handler in code after obtaining an object reference to the element where the handler is to be attached.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="10bbc-127">请参阅</span><span class="sxs-lookup"><span data-stu-id="10bbc-127">See also</span></span>

- [<span data-ttu-id="10bbc-128">将路由事件标记为“已处理”和“类处理”</span><span class="sxs-lookup"><span data-stu-id="10bbc-128">Marking Routed Events as Handled, and Class Handling</span></span>](marking-routed-events-as-handled-and-class-handling.md)
- [<span data-ttu-id="10bbc-129">路由事件概述</span><span class="sxs-lookup"><span data-stu-id="10bbc-129">Routed Events Overview</span></span>](routed-events-overview.md)
