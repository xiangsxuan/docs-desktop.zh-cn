---
title: 依赖项属性的安全性
ms.date: 03/30/2017
helpviewer_keywords:
- wrappers [WPF], access
- wrappers [WPF], security
- dependency properties [WPF], security
- security [WPF], wrappers
- validation [WPF], dependency properties
- dependency properties [WPF], access
- security [WPF], dependency properties
ms.assetid: d10150ec-90c5-4571-8d35-84bafa2429a4
ms.openlocfilehash: 4bb3f0e4264c8de2513fc757f5e1a5a2efdd541c
ms.sourcegitcommit: bf5dd80f4d7b202afa90e90d1148402c5474d826
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/30/2021
ms.locfileid: "96973044"
---
# <a name="dependency-property-security"></a><span data-ttu-id="48f8b-102">依赖项属性的安全性</span><span class="sxs-lookup"><span data-stu-id="48f8b-102">Dependency Property Security</span></span>
<span data-ttu-id="48f8b-103">依赖属性通常应当被视为公共属性。</span><span class="sxs-lookup"><span data-stu-id="48f8b-103">Dependency properties should generally be considered to be public properties.</span></span> <span data-ttu-id="48f8b-104">[!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] 属性系统在本质上无法对依赖属性值提供安全保证。</span><span class="sxs-lookup"><span data-stu-id="48f8b-104">The nature of the [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] property system prevents the ability to make security guarantees about a dependency property value.</span></span>  

<a name="AccessSecurity"></a>
## <a name="access-and-security-of-wrappers-and-dependency-properties"></a><span data-ttu-id="48f8b-105">包装器和依赖属性的访问和安全性</span><span class="sxs-lookup"><span data-stu-id="48f8b-105">Access and Security of Wrappers and Dependency Properties</span></span>  
 <span data-ttu-id="48f8b-106">通常，依赖属性与 "包装器" 公共语言运行时一起实现 (CLR) 属性，这些属性可以简化从实例获取或设置属性。</span><span class="sxs-lookup"><span data-stu-id="48f8b-106">Typically, dependency properties are implemented along with "wrapper" common language runtime (CLR) properties that simplify getting or setting the property from an instance.</span></span> <span data-ttu-id="48f8b-107">但包装实际上只是一种简便方法，可实现 <xref:System.Windows.DependencyObject.GetValue%2A> 在 <xref:System.Windows.DependencyObject.SetValue%2A> 与依赖属性交互时使用的基础调用和静态调用。</span><span class="sxs-lookup"><span data-stu-id="48f8b-107">But the wrappers are really just convenience methods that implement the underlying <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> static calls that are used when interacting with dependency properties.</span></span> <span data-ttu-id="48f8b-108">以另一种方式思考，属性将作为公共语言运行时 (CLR) 属性，这些属性确实是由依赖属性（而不是私有字段）支持的属性。</span><span class="sxs-lookup"><span data-stu-id="48f8b-108">Thinking of it in another way, the properties are exposed as common language runtime (CLR) properties that happen to be backed by a dependency property rather than by a private field.</span></span> <span data-ttu-id="48f8b-109">应用于包装器的安全机制与属性系统行为以及基础依赖属性的访问并不可比。</span><span class="sxs-lookup"><span data-stu-id="48f8b-109">Security mechanisms applied to the wrappers do not parallel the property system behavior and access of the underlying dependency property.</span></span> <span data-ttu-id="48f8b-110">在包装上放置安全要求仅会阻止使用便捷方法，但不会阻止对或的调用 <xref:System.Windows.DependencyObject.GetValue%2A> <xref:System.Windows.DependencyObject.SetValue%2A> 。</span><span class="sxs-lookup"><span data-stu-id="48f8b-110">Placing a security demand on the wrapper will only prevent the usage of the convenience method but will not prevent calls to <xref:System.Windows.DependencyObject.GetValue%2A> or <xref:System.Windows.DependencyObject.SetValue%2A>.</span></span> <span data-ttu-id="48f8b-111">同样，为包装器设置受保护或私有访问级别也不会提供任何有效的安全性。</span><span class="sxs-lookup"><span data-stu-id="48f8b-111">Similarly, placing protected or private access level on the wrappers does not provide any effective security.</span></span>  
  
 <span data-ttu-id="48f8b-112">如果你正在编写自己的依赖项属性，则应将包装和 <xref:System.Windows.DependencyProperty> 标识符字段声明为公共成员，以便调用方不会获得有关该属性的 true 访问级别的误导性信息 (因为其存储区作为依赖属性) 实现。</span><span class="sxs-lookup"><span data-stu-id="48f8b-112">If you are writing your own dependency properties, you should declare the wrappers and the <xref:System.Windows.DependencyProperty> identifier field as public members, so that callers do not get misleading information about the true access level of that property (because of its store being implemented as a dependency property).</span></span>  
  
 <span data-ttu-id="48f8b-113">对于自定义依赖属性，可以将属性注册为只读依赖属性，这确实提供了一种有效的方法来防止不包含对该属性的引用的任何人设置属性 <xref:System.Windows.DependencyPropertyKey> 。</span><span class="sxs-lookup"><span data-stu-id="48f8b-113">For a custom dependency property, you can register your property as a read-only dependency property, and this does provide an effective means of preventing a property being set by anyone that does not hold a reference to the <xref:System.Windows.DependencyPropertyKey> for that property.</span></span> <span data-ttu-id="48f8b-114">有关详细信息，请参阅[只读依赖属性](read-only-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="48f8b-114">For more information, see [Read-Only Dependency Properties](read-only-dependency-properties.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="48f8b-115"><xref:System.Windows.DependencyProperty>不禁止将标识符字段声明为私有的，因此可以使用它来帮助减少自定义类的直接公开命名空间，但不应将此类属性视为与公共语言运行时相同，因为公共语言运行时 (CLR) 语言定义会定义该访问级别，原因如下一节所述。</span><span class="sxs-lookup"><span data-stu-id="48f8b-115">Declaring a <xref:System.Windows.DependencyProperty> identifier field private is not forbidden, and it can conceivably be used to help reduce the immediately exposed namespace of a custom class, but such a property should not be considered "private" in the same sense as the common language runtime (CLR) language definitions define that access level, for reasons described in the next section.</span></span>  
  
<a name="PropertySystemExposure"></a>
## <a name="property-system-exposure-of-dependency-properties"></a><span data-ttu-id="48f8b-116">依赖属性的属性系统公开</span><span class="sxs-lookup"><span data-stu-id="48f8b-116">Property System Exposure of Dependency Properties</span></span>  
 <span data-ttu-id="48f8b-117">这种方法通常并不有用，它可能会产生误导性，将声明为除 public 以外的 <xref:System.Windows.DependencyProperty> 任何访问级别。</span><span class="sxs-lookup"><span data-stu-id="48f8b-117">It is not generally useful, and it is potentially misleading, to declare a <xref:System.Windows.DependencyProperty> as any access level other than public.</span></span> <span data-ttu-id="48f8b-118">该访问级别设置只是防止某人从声明类获得对实例的引用。</span><span class="sxs-lookup"><span data-stu-id="48f8b-118">That access level setting only prevents someone from being able to get a reference to the instance from the declaring class.</span></span> <span data-ttu-id="48f8b-119">但是，属性系统有多个方面将返回， <xref:System.Windows.DependencyProperty> 作为标识某个特定属性的方法，因为它存在于类或派生类实例的实例上， <xref:System.Windows.DependencyObject.SetValue%2A> 即使原始静态标识符声明为非公共的，也可以在调用中使用此标识符。</span><span class="sxs-lookup"><span data-stu-id="48f8b-119">But there are several aspects of the property system that will return a <xref:System.Windows.DependencyProperty> as the means of identifying a particular property as it exists on an instance of a class or a derived class instance, and this identifier is still usable in a <xref:System.Windows.DependencyObject.SetValue%2A> call even if the original static identifier is declared as nonpublic.</span></span> <span data-ttu-id="48f8b-120">此外， <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 虚方法接收任何现有依赖属性的信息，该属性更改了值。</span><span class="sxs-lookup"><span data-stu-id="48f8b-120">Also, <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> virtual methods receive information of any existing dependency property that changed value.</span></span> <span data-ttu-id="48f8b-121">此外，该 <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> 方法为实例上具有本地设置值的任何属性返回标识符。</span><span class="sxs-lookup"><span data-stu-id="48f8b-121">In addition, the <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> method returns identifiers for any property on instances with a locally set value.</span></span>  
  
### <a name="validation-and-security"></a><span data-ttu-id="48f8b-122">验证和安全</span><span class="sxs-lookup"><span data-stu-id="48f8b-122">Validation and Security</span></span>  
 <span data-ttu-id="48f8b-123">将需求应用到 <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> ，并预期在请求失败时验证失败，以防止设置属性的安全机制。</span><span class="sxs-lookup"><span data-stu-id="48f8b-123">Applying a demand to a <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> and expecting the validation failure on a demand failure to prevent a property from being set is not an adequate security mechanism.</span></span> <span data-ttu-id="48f8b-124">如果执行的设置值无效 <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> ，则如果这些调用方在应用程序域中运行，则它也会被恶意调用方抑制。</span><span class="sxs-lookup"><span data-stu-id="48f8b-124">Set-value invalidation enforced through <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> could also be suppressed by malicious callers, if those callers are operating within the application domain.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="48f8b-125">另请参阅</span><span class="sxs-lookup"><span data-stu-id="48f8b-125">See also</span></span>

- [<span data-ttu-id="48f8b-126">自定义依赖项属性</span><span class="sxs-lookup"><span data-stu-id="48f8b-126">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
