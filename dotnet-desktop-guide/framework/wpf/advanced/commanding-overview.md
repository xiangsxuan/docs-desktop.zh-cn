---
title: 命令概述
description: 了解如何在 Windows Presentation Foundation 中提供输入机制，该机制提供比设备输入更具语义级别的输入处理。
ms.date: 03/30/2017
ms.topic: overview
dev_langs:
- csharp
- vb
helpviewer_keywords:
- interfaces [WPF], ICommandSource
- command library [WPF]
- commands [WPF], definition of
- CommandBindings [WPF]
- ICommandSource interfaces [WPF]
- commanding [WPF]
- CommandManager [WPF]
ms.assetid: bc208dfe-367d-426a-99de-52b7e7511e81
ms.openlocfilehash: 3a04a218133664547047071e633bd60ea97a3b54
ms.sourcegitcommit: 069786bcadbf9cd931d7dc3d892262cd852d2ffb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/19/2021
ms.locfileid: "104666168"
---
# <a name="commanding-overview"></a><span data-ttu-id="f79e8-103">命令概述</span><span class="sxs-lookup"><span data-stu-id="f79e8-103">Commanding Overview</span></span>

<a name="introduction"></a><span data-ttu-id="f79e8-104">命令是 [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] 中的一种输出机制，与设备输出相比，其提供的输出处理更侧重于语义级别。</span><span class="sxs-lookup"><span data-stu-id="f79e8-104">Commanding is an input mechanism in [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] which provides input handling at a more semantic level than device input.</span></span> <span data-ttu-id="f79e8-105">示例命令如许多应用程序均具有的“复制”、“剪切”和“粘贴”操作。</span><span class="sxs-lookup"><span data-stu-id="f79e8-105">Examples of commands are the **Copy**, **Cut**, and **Paste** operations found on many applications.</span></span>  
  
 <span data-ttu-id="f79e8-106">本概述定义 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 中有哪些命令、哪些类属于命令模型以及如何在应用程序中使用和创建命令。</span><span class="sxs-lookup"><span data-stu-id="f79e8-106">This overview defines what commands are in [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)], which classes are part of the commanding model, and how to use and create commands in your applications.</span></span>  
  
 <span data-ttu-id="f79e8-107">本主题包含以下各节：</span><span class="sxs-lookup"><span data-stu-id="f79e8-107">This topic contains the following sections:</span></span>  
  
- [<span data-ttu-id="f79e8-108">什么是命令？</span><span class="sxs-lookup"><span data-stu-id="f79e8-108">What Are Commands?</span></span>](#commands_at_10000_feet)  
  
- [<span data-ttu-id="f79e8-109">WPF 中的简单命令示例</span><span class="sxs-lookup"><span data-stu-id="f79e8-109">Simple Command Example in WPF</span></span>](#simple_command)  
  
- [<span data-ttu-id="f79e8-110">WPF 命令中的四个主要概念</span><span class="sxs-lookup"><span data-stu-id="f79e8-110">Four Main Concepts in WPF Commanding</span></span>](#Four_main_Concepts)  
  
- [<span data-ttu-id="f79e8-111">命令库</span><span class="sxs-lookup"><span data-stu-id="f79e8-111">Command Library</span></span>](#Command_Library)  
  
- [<span data-ttu-id="f79e8-112">创建自定义命令</span><span class="sxs-lookup"><span data-stu-id="f79e8-112">Creating Custom Commands</span></span>](#creating_commands)  
  
<a name="commands_at_10000_feet"></a>

## <a name="what-are-commands"></a><span data-ttu-id="f79e8-113">什么是命令</span><span class="sxs-lookup"><span data-stu-id="f79e8-113">What Are Commands</span></span>  

 <span data-ttu-id="f79e8-114">命令具有多个用途。</span><span class="sxs-lookup"><span data-stu-id="f79e8-114">Commands have several purposes.</span></span> <span data-ttu-id="f79e8-115">第一个用途是分隔语义和从执行命令的逻辑调用命令的对象。</span><span class="sxs-lookup"><span data-stu-id="f79e8-115">The first purpose is to separate the semantics and the object that invokes a command from the logic that executes the command.</span></span> <span data-ttu-id="f79e8-116">这可使多个不同的源调用同一命令逻辑，并且可针对不同目标自定义命令逻辑。</span><span class="sxs-lookup"><span data-stu-id="f79e8-116">This allows for multiple and disparate sources to invoke the same command logic, and it allows the command logic to be customized for different targets.</span></span> <span data-ttu-id="f79e8-117">例如，许多应用程序中均有的编辑操作“复制”、“剪切”和“粘贴”若通过使用命令来实现，那么可通过使用不同的用户操作来调用它们。</span><span class="sxs-lookup"><span data-stu-id="f79e8-117">For example, the editing operations **Copy**, **Cut**, and **Paste**, which are found in many applications, can be invoked by using different user actions if they are implemented by using commands.</span></span> <span data-ttu-id="f79e8-118">应用程序可允许用户通过单击按钮、选择菜单中的项或使用组合键（例如 Ctrl+X）来剪切所选对象或文本。</span><span class="sxs-lookup"><span data-stu-id="f79e8-118">An application might allow a user to cut selected objects or text by either clicking a button, choosing an item in a menu, or using a key combination, such as CTRL+X.</span></span> <span data-ttu-id="f79e8-119">通过使用命令，可将每种类型的用户操作绑定到相同逻辑。</span><span class="sxs-lookup"><span data-stu-id="f79e8-119">By using commands, you can bind each type of user action to the same logic.</span></span>  
  
 <span data-ttu-id="f79e8-120">命令的另一用途是指示操作是否可用。</span><span class="sxs-lookup"><span data-stu-id="f79e8-120">Another purpose of commands is to indicate whether an action is available.</span></span> <span data-ttu-id="f79e8-121">继续以剪切对象或文本为例，此操作只有在选择了内容时才会发生作用。</span><span class="sxs-lookup"><span data-stu-id="f79e8-121">To continue the example of cutting an object or text, the action only makes sense when something is selected.</span></span> <span data-ttu-id="f79e8-122">如果用户在未选择任何内容的情况下尝试剪切对象或文本，则不会发生任何操作。</span><span class="sxs-lookup"><span data-stu-id="f79e8-122">If a user tries to cut an object or text without having anything selected, nothing would happen.</span></span> <span data-ttu-id="f79e8-123">为了向用户指示这一点，许多应用程序通过禁用按钮和菜单项来告知用户是否可以执行某操作。</span><span class="sxs-lookup"><span data-stu-id="f79e8-123">To indicate this to the user, many applications disable buttons and menu items so that the user knows whether it is possible to perform an action.</span></span> <span data-ttu-id="f79e8-124">命令可以通过实现 <xref:System.Windows.Input.ICommand.CanExecute%2A> 方法来指示操作是否可行。</span><span class="sxs-lookup"><span data-stu-id="f79e8-124">A command can indicate whether an action is possible by implementing the <xref:System.Windows.Input.ICommand.CanExecute%2A> method.</span></span> <span data-ttu-id="f79e8-125">按钮可以订阅 <xref:System.Windows.Input.ICommand.CanExecuteChanged> 事件，如果 <xref:System.Windows.Input.ICommand.CanExecute%2A> 返回 `false` 则禁用，如果 <xref:System.Windows.Input.ICommand.CanExecute%2A> 返回 `true` 则启用。</span><span class="sxs-lookup"><span data-stu-id="f79e8-125">A button can subscribe to the <xref:System.Windows.Input.ICommand.CanExecuteChanged> event and be disabled if <xref:System.Windows.Input.ICommand.CanExecute%2A> returns `false` or be enabled if <xref:System.Windows.Input.ICommand.CanExecute%2A> returns `true`.</span></span>  
  
 <span data-ttu-id="f79e8-126">虽然命令的语义在应用程序和类之间可保持一致，但操作的逻辑特定于操作所针对的特定对象。</span><span class="sxs-lookup"><span data-stu-id="f79e8-126">The semantics of a command can be consistent across applications and classes, but the logic of the action is specific to the particular object acted upon.</span></span> <span data-ttu-id="f79e8-127">组合键 Ctrl+X 调用文本类、图像类和 Web 浏览器中的“剪切”命令，但执行“剪切”操作的实际逻辑由执行剪切的应用程序定义。</span><span class="sxs-lookup"><span data-stu-id="f79e8-127">The key combination CTRL+X invokes the **Cut** command in text classes, image classes, and Web browsers, but the actual logic for performing the **Cut** operation is defined by the application that performs the cut.</span></span> <span data-ttu-id="f79e8-128"><xref:System.Windows.Input.RoutedCommand> 使客户端实现逻辑。</span><span class="sxs-lookup"><span data-stu-id="f79e8-128">A <xref:System.Windows.Input.RoutedCommand> enables clients to implement the logic.</span></span> <span data-ttu-id="f79e8-129">文本对象可将所选文本剪切到剪贴板，而图像对象则剪切所选图像。</span><span class="sxs-lookup"><span data-stu-id="f79e8-129">A text object may cut the selected text into the clipboard, while an image object may cut the selected image.</span></span> <span data-ttu-id="f79e8-130">应用程序处理 <xref:System.Windows.Input.CommandManager.Executed> 事件时可访问命令的目标，并根据目标的类型采取相应操作。</span><span class="sxs-lookup"><span data-stu-id="f79e8-130">When an application handles the <xref:System.Windows.Input.CommandManager.Executed> event, it has access to the target of the command and can take appropriate action depending on the target's type.</span></span>  
  
<a name="simple_command"></a>

## <a name="simple-command-example-in-wpf"></a><span data-ttu-id="f79e8-131">WPF 中的简单命令示例</span><span class="sxs-lookup"><span data-stu-id="f79e8-131">Simple Command Example in WPF</span></span>  

 <span data-ttu-id="f79e8-132">使用 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 中命令的最简单方式是使用其中一个命令库类中预定义的 <xref:System.Windows.Input.RoutedCommand>；使用具有命令处理本机支持的控件；使用具有命令调用本机支持的控件。</span><span class="sxs-lookup"><span data-stu-id="f79e8-132">The simplest way to use a command in [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] is to use a predefined <xref:System.Windows.Input.RoutedCommand> from one of the command library classes; use a control that has native support for handling the command; and use a control that has native support for invoking a command.</span></span>  <span data-ttu-id="f79e8-133"><xref:System.Windows.Input.ApplicationCommands.Paste%2A> 命令是 <xref:System.Windows.Input.ApplicationCommands> 类中的预定义命令之一。</span><span class="sxs-lookup"><span data-stu-id="f79e8-133">The <xref:System.Windows.Input.ApplicationCommands.Paste%2A> command is one of the predefined commands in the <xref:System.Windows.Input.ApplicationCommands> class.</span></span>  <span data-ttu-id="f79e8-134"><xref:System.Windows.Controls.TextBox> 控件含有用于处理 <xref:System.Windows.Input.ApplicationCommands.Paste%2A> 命令的内置逻辑。</span><span class="sxs-lookup"><span data-stu-id="f79e8-134">The <xref:System.Windows.Controls.TextBox> control has built in logic for handling the <xref:System.Windows.Input.ApplicationCommands.Paste%2A> command.</span></span>  <span data-ttu-id="f79e8-135"><xref:System.Windows.Controls.MenuItem> 类具有调用命令的本机支持。</span><span class="sxs-lookup"><span data-stu-id="f79e8-135">And the <xref:System.Windows.Controls.MenuItem> class has native support for invoking commands.</span></span>  
  
 <span data-ttu-id="f79e8-136">以下示例显示了如何设置 <xref:System.Windows.Controls.MenuItem>，以便在单击时它将调用 <xref:System.Windows.Controls.TextBox> 上的 <xref:System.Windows.Input.ApplicationCommands.Paste%2A> 命令，假定 <xref:System.Windows.Controls.TextBox> 具有键盘焦点。</span><span class="sxs-lookup"><span data-stu-id="f79e8-136">The following example shows how to set up a <xref:System.Windows.Controls.MenuItem> so that when it is clicked it will invoke the <xref:System.Windows.Input.ApplicationCommands.Paste%2A> command on a <xref:System.Windows.Controls.TextBox>, assuming the <xref:System.Windows.Controls.TextBox> has keyboard focus.</span></span>  
  
 [!code-xaml[CommandingOverviewSnippets#CommandingOverviewSimpleCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewsimplecommand)]  
  
 [!code-csharp[CommandingOverviewSnippets#CommandingOverviewCommandTargetCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewcommandtargetcodebehind)]
 [!code-vb[CommandingOverviewSnippets#CommandingOverviewCommandTargetCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewcommandtargetcodebehind)]  
  
<a name="Four_main_Concepts"></a>

## <a name="four-main-concepts-in-wpf-commanding"></a><span data-ttu-id="f79e8-137">WPF 命令中的四个主要概念</span><span class="sxs-lookup"><span data-stu-id="f79e8-137">Four Main Concepts in WPF Commanding</span></span>  

 <span data-ttu-id="f79e8-138">[!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 中的路由命令模型可分解为四个主要概念：命令、命令源、命令目标和命令绑定：</span><span class="sxs-lookup"><span data-stu-id="f79e8-138">The routed command model in [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] can be broken up into four main concepts: the command, the command source, the command target, and the command binding:</span></span>  
  
- <span data-ttu-id="f79e8-139">*命令* 是要执行的操作。</span><span class="sxs-lookup"><span data-stu-id="f79e8-139">The *command* is the action to be executed.</span></span>  
  
- <span data-ttu-id="f79e8-140">*命令源* 是调用命令的对象。</span><span class="sxs-lookup"><span data-stu-id="f79e8-140">The *command source* is the object which invokes the command.</span></span>  
  
- <span data-ttu-id="f79e8-141">*命令目标* 是在其上执行命令的对象。</span><span class="sxs-lookup"><span data-stu-id="f79e8-141">The *command target* is the object that the command is being executed on.</span></span>  
  
- <span data-ttu-id="f79e8-142">*命令绑定* 是将命令逻辑映射到命令的对象。</span><span class="sxs-lookup"><span data-stu-id="f79e8-142">The *command binding* is the object which maps the command logic to the command.</span></span>  
  
 <span data-ttu-id="f79e8-143">在前面的示例中，<xref:System.Windows.Input.ApplicationCommands.Paste%2A> 命令是命令，<xref:System.Windows.Controls.MenuItem> 是命令源，<xref:System.Windows.Controls.TextBox> 是命令目标，命令绑定由 <xref:System.Windows.Controls.TextBox> 控件提供。</span><span class="sxs-lookup"><span data-stu-id="f79e8-143">In the previous example, the <xref:System.Windows.Input.ApplicationCommands.Paste%2A> command is the command, the <xref:System.Windows.Controls.MenuItem> is the command source, the <xref:System.Windows.Controls.TextBox> is the command target, and the command binding is supplied by the <xref:System.Windows.Controls.TextBox> control.</span></span>  <span data-ttu-id="f79e8-144">值得注意的是，<xref:System.Windows.Input.CommandBinding> 并不总是由作为命令目标类的控件提供。</span><span class="sxs-lookup"><span data-stu-id="f79e8-144">It is worth noting that it is not always the case that the <xref:System.Windows.Input.CommandBinding> is supplied by the control that is the command target class.</span></span>  <span data-ttu-id="f79e8-145">通常，<xref:System.Windows.Input.CommandBinding> 必须由应用程序开发者创建，否则 <xref:System.Windows.Input.CommandBinding> 可能会附加到命令目标的上级元素。</span><span class="sxs-lookup"><span data-stu-id="f79e8-145">Quite often the <xref:System.Windows.Input.CommandBinding> must be created by the application developer, or the <xref:System.Windows.Input.CommandBinding> might be attached to an ancestor of the command target.</span></span>  
  
<a name="Commands"></a>

### <a name="commands"></a><span data-ttu-id="f79e8-146">命令</span><span class="sxs-lookup"><span data-stu-id="f79e8-146">Commands</span></span>  

 <span data-ttu-id="f79e8-147">[!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 中的命令是通过实现 <xref:System.Windows.Input.ICommand> 接口创建的。</span><span class="sxs-lookup"><span data-stu-id="f79e8-147">Commands in [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] are created by implementing the <xref:System.Windows.Input.ICommand> interface.</span></span>  <span data-ttu-id="f79e8-148"><xref:System.Windows.Input.ICommand> 公开了两种方法 <xref:System.Windows.Input.ICommand.Execute%2A> 和 <xref:System.Windows.Input.ICommand.CanExecute%2A>，以及一个事件 <xref:System.Windows.Input.ICommand.CanExecuteChanged>。</span><span class="sxs-lookup"><span data-stu-id="f79e8-148"><xref:System.Windows.Input.ICommand> exposes two methods, <xref:System.Windows.Input.ICommand.Execute%2A>, and <xref:System.Windows.Input.ICommand.CanExecute%2A>, and an event, <xref:System.Windows.Input.ICommand.CanExecuteChanged>.</span></span> <span data-ttu-id="f79e8-149"><xref:System.Windows.Input.ICommand.Execute%2A> 执行与该命令关联的操作。</span><span class="sxs-lookup"><span data-stu-id="f79e8-149"><xref:System.Windows.Input.ICommand.Execute%2A> performs the actions that are associated with the command.</span></span> <span data-ttu-id="f79e8-150"><xref:System.Windows.Input.ICommand.CanExecute%2A> 确定是否可以在当前命令目标上执行该命令。</span><span class="sxs-lookup"><span data-stu-id="f79e8-150"><xref:System.Windows.Input.ICommand.CanExecute%2A> determines whether the command can execute on the current command target.</span></span> <span data-ttu-id="f79e8-151">如果集中管理命令操作的命令管理器检测到命令源中存在一个可能使已引发命令无效但尚未由命令绑定执行的更改，则会引发 <xref:System.Windows.Input.ICommand.CanExecuteChanged>。</span><span class="sxs-lookup"><span data-stu-id="f79e8-151"><xref:System.Windows.Input.ICommand.CanExecuteChanged> is raised if the command manager that centralizes the commanding operations detects a change in the command source that might invalidate a command that has been raised but not yet executed by the command binding.</span></span>  <span data-ttu-id="f79e8-152"><xref:System.Windows.Input.ICommand> 的 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 实现是 <xref:System.Windows.Input.RoutedCommand> 类，并且是本概述的重点。</span><span class="sxs-lookup"><span data-stu-id="f79e8-152">The [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] implementation of <xref:System.Windows.Input.ICommand> is the <xref:System.Windows.Input.RoutedCommand> class and is the focus of this overview.</span></span>  
  
 <span data-ttu-id="f79e8-153">[!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 中输入的主要源是鼠标、键盘、墨迹和路由命令。</span><span class="sxs-lookup"><span data-stu-id="f79e8-153">The main sources of input in [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] are the mouse, the keyboard, ink, and routed commands.</span></span>  <span data-ttu-id="f79e8-154">面向设备程度更高的输入使用 <xref:System.Windows.RoutedEvent> 通知应用程序页中的对象输入事件已发生。</span><span class="sxs-lookup"><span data-stu-id="f79e8-154">The more device-oriented inputs use a <xref:System.Windows.RoutedEvent> to notify objects in an application page that an input event has occurred.</span></span>  <span data-ttu-id="f79e8-155"><xref:System.Windows.Input.RoutedCommand> 也不例外。</span><span class="sxs-lookup"><span data-stu-id="f79e8-155">A <xref:System.Windows.Input.RoutedCommand> is no different.</span></span>  <span data-ttu-id="f79e8-156"><xref:System.Windows.Input.RoutedCommand> 的 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 和 <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> 方法不包含该命令的应用程序逻辑，而是引发通过元素树通行和浮升的路由事件，直到遇到具有 <xref:System.Windows.Input.CommandBinding> 的对象。</span><span class="sxs-lookup"><span data-stu-id="f79e8-156">The <xref:System.Windows.Input.RoutedCommand.Execute%2A> and <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> methods of a <xref:System.Windows.Input.RoutedCommand> do not contain the application logic for the command, but rather they raise routed events that tunnel and bubble through the element tree until they encounter an object with a <xref:System.Windows.Input.CommandBinding>.</span></span>  <span data-ttu-id="f79e8-157"><xref:System.Windows.Input.CommandBinding> 包含这些事件的处理程序，命令正是由这些处理程序执行。</span><span class="sxs-lookup"><span data-stu-id="f79e8-157">The <xref:System.Windows.Input.CommandBinding> contains the handlers for these events and it is the handlers that perform the command.</span></span>  <span data-ttu-id="f79e8-158">有关 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 中事件路由的详细信息，请参阅[路由事件概述](routed-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="f79e8-158">For more information on event routing in [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)], see [Routed Events Overview](routed-events-overview.md).</span></span>  
  
 <span data-ttu-id="f79e8-159"><xref:System.Windows.Input.RoutedCommand> 上的 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 方法引发命令目标上的 <xref:System.Windows.Input.CommandManager.PreviewExecuted> 和 <xref:System.Windows.Input.CommandManager.Executed> 事件。</span><span class="sxs-lookup"><span data-stu-id="f79e8-159">The <xref:System.Windows.Input.RoutedCommand.Execute%2A> method on a <xref:System.Windows.Input.RoutedCommand> raises the <xref:System.Windows.Input.CommandManager.PreviewExecuted> and the <xref:System.Windows.Input.CommandManager.Executed> events on the command target.</span></span>  <span data-ttu-id="f79e8-160"><xref:System.Windows.Input.RoutedCommand> 上的 <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> 方法引发命令目标上的 <xref:System.Windows.Input.CommandManager.CanExecute> 和 <xref:System.Windows.Input.CommandManager.PreviewCanExecute> 事件。</span><span class="sxs-lookup"><span data-stu-id="f79e8-160">The <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> method on a <xref:System.Windows.Input.RoutedCommand> raises the <xref:System.Windows.Input.CommandManager.CanExecute> and <xref:System.Windows.Input.CommandManager.PreviewCanExecute> events on the command target.</span></span>  <span data-ttu-id="f79e8-161">这些事件通过元素树通行和浮升，直到遇到一个具有针对该特定命令的 <xref:System.Windows.Input.CommandBinding> 的对象。</span><span class="sxs-lookup"><span data-stu-id="f79e8-161">These events tunnel and bubble through the element tree until they encounter an object which has a <xref:System.Windows.Input.CommandBinding> for that particular command.</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="f79e8-162">提供了分布在几个类中的一组常用路由命令：<xref:System.Windows.Input.MediaCommands>、<xref:System.Windows.Input.ApplicationCommands>、<xref:System.Windows.Input.NavigationCommands>、<xref:System.Windows.Input.ComponentCommands> 和 <xref:System.Windows.Documents.EditingCommands>。</span><span class="sxs-lookup"><span data-stu-id="f79e8-162">supplies a set of common routed commands spread across several classes: <xref:System.Windows.Input.MediaCommands>, <xref:System.Windows.Input.ApplicationCommands>, <xref:System.Windows.Input.NavigationCommands>, <xref:System.Windows.Input.ComponentCommands>, and <xref:System.Windows.Documents.EditingCommands>.</span></span>  <span data-ttu-id="f79e8-163">这些类仅由 <xref:System.Windows.Input.RoutedCommand> 对象构成，而不包含命令的实现逻辑。</span><span class="sxs-lookup"><span data-stu-id="f79e8-163">These classes consist only of the <xref:System.Windows.Input.RoutedCommand> objects and not the implementation logic of the command.</span></span>  <span data-ttu-id="f79e8-164">实现逻辑由在其上执行命令的对象负责。</span><span class="sxs-lookup"><span data-stu-id="f79e8-164">The implementation logic is the responsibility of the object on which the command is being executed on.</span></span>  
  
<a name="Command_Sources"></a>

### <a name="command-sources"></a><span data-ttu-id="f79e8-165">命令源</span><span class="sxs-lookup"><span data-stu-id="f79e8-165">Command Sources</span></span>  

 <span data-ttu-id="f79e8-166">命令源是调用命令的对象。</span><span class="sxs-lookup"><span data-stu-id="f79e8-166">A command source is the object which invokes the command.</span></span>  <span data-ttu-id="f79e8-167">命令源的示例有 <xref:System.Windows.Controls.MenuItem>、<xref:System.Windows.Controls.Button> 和 <xref:System.Windows.Input.KeyGesture>。</span><span class="sxs-lookup"><span data-stu-id="f79e8-167">Examples of command sources are <xref:System.Windows.Controls.MenuItem>, <xref:System.Windows.Controls.Button>, and <xref:System.Windows.Input.KeyGesture>.</span></span>  
  
 <span data-ttu-id="f79e8-168">[!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 中的命令源通常实现 <xref:System.Windows.Input.ICommandSource> 接口。</span><span class="sxs-lookup"><span data-stu-id="f79e8-168">Command sources in [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] generally implement the <xref:System.Windows.Input.ICommandSource> interface.</span></span>  
  
 <span data-ttu-id="f79e8-169"><xref:System.Windows.Input.ICommandSource> 公开三个属性：<xref:System.Windows.Input.ICommandSource.Command%2A>、<xref:System.Windows.Input.ICommandSource.CommandTarget%2A> 和 <xref:System.Windows.Input.ICommandSource.CommandParameter%2A>：</span><span class="sxs-lookup"><span data-stu-id="f79e8-169"><xref:System.Windows.Input.ICommandSource> exposes three properties: <xref:System.Windows.Input.ICommandSource.Command%2A>, <xref:System.Windows.Input.ICommandSource.CommandTarget%2A>, and <xref:System.Windows.Input.ICommandSource.CommandParameter%2A>:</span></span>  
  
- <span data-ttu-id="f79e8-170"><xref:System.Windows.Input.ICommandSource.Command%2A> 是在调用命令源时执行的命令。</span><span class="sxs-lookup"><span data-stu-id="f79e8-170"><xref:System.Windows.Input.ICommandSource.Command%2A> is the command to execute when the command source is invoked.</span></span>  
  
- <span data-ttu-id="f79e8-171"><xref:System.Windows.Input.ICommandSource.CommandTarget%2A> 是要执行命令的对象。</span><span class="sxs-lookup"><span data-stu-id="f79e8-171"><xref:System.Windows.Input.ICommandSource.CommandTarget%2A> is the object on which to execute the command.</span></span>  <span data-ttu-id="f79e8-172">值得注意的是，在 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 中，仅当 <xref:System.Windows.Input.ICommand> 为 <xref:System.Windows.Input.RoutedCommand> 时，<xref:System.Windows.Input.ICommandSource> 上的 <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> 属性才适用。</span><span class="sxs-lookup"><span data-stu-id="f79e8-172">It is worth noting that in [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] the <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> property on <xref:System.Windows.Input.ICommandSource> is only applicable when the <xref:System.Windows.Input.ICommand> is a <xref:System.Windows.Input.RoutedCommand>.</span></span>  <span data-ttu-id="f79e8-173">如果在 <xref:System.Windows.Input.ICommandSource> 上设置 <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> 并且相应的命令不是 <xref:System.Windows.Input.RoutedCommand>，则忽略命令目标。</span><span class="sxs-lookup"><span data-stu-id="f79e8-173">If the <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> is set on an <xref:System.Windows.Input.ICommandSource> and the corresponding command is not a <xref:System.Windows.Input.RoutedCommand>, the command target is ignored.</span></span> <span data-ttu-id="f79e8-174">如果未设置 <xref:System.Windows.Input.ICommandSource.CommandTarget%2A>，则具有键盘焦点的元素将成为命令目标。</span><span class="sxs-lookup"><span data-stu-id="f79e8-174">If the <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> is not set, the element with keyboard focus will be the command target.</span></span>  
  
- <span data-ttu-id="f79e8-175"><xref:System.Windows.Input.ICommandSource.CommandParameter%2A> 是用于将信息传递给实现命令的处理程序的用户定义数据类型。</span><span class="sxs-lookup"><span data-stu-id="f79e8-175"><xref:System.Windows.Input.ICommandSource.CommandParameter%2A> is a user-defined data type used to pass information to the handlers implementing the command.</span></span>  
  
 <span data-ttu-id="f79e8-176">实现 <xref:System.Windows.Input.ICommandSource> 的 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 类是 <xref:System.Windows.Controls.Primitives.ButtonBase>、<xref:System.Windows.Controls.MenuItem>、<xref:System.Windows.Documents.Hyperlink> 和 <xref:System.Windows.Input.InputBinding>。</span><span class="sxs-lookup"><span data-stu-id="f79e8-176">The [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] classes that implement <xref:System.Windows.Input.ICommandSource> are <xref:System.Windows.Controls.Primitives.ButtonBase>, <xref:System.Windows.Controls.MenuItem>, <xref:System.Windows.Documents.Hyperlink>, and <xref:System.Windows.Input.InputBinding>.</span></span>  <span data-ttu-id="f79e8-177">单击 <xref:System.Windows.Controls.Primitives.ButtonBase>、<xref:System.Windows.Controls.MenuItem> 和 <xref:System.Windows.Documents.Hyperlink> 时，调用一个命令，当执行与其关联的 <xref:System.Windows.Input.InputGesture> 时，<xref:System.Windows.Input.InputBinding> 调用命令。</span><span class="sxs-lookup"><span data-stu-id="f79e8-177"><xref:System.Windows.Controls.Primitives.ButtonBase>, <xref:System.Windows.Controls.MenuItem>, and <xref:System.Windows.Documents.Hyperlink> invoke a command when they are clicked, and an <xref:System.Windows.Input.InputBinding> invokes a command when the <xref:System.Windows.Input.InputGesture> associated with it is performed.</span></span>  
  
 <span data-ttu-id="f79e8-178">以下示例显示如何将 <xref:System.Windows.Controls.ContextMenu> 中的 <xref:System.Windows.Controls.MenuItem> 用作 <xref:System.Windows.Input.ApplicationCommands.Properties%2A> 命令的命令源。</span><span class="sxs-lookup"><span data-stu-id="f79e8-178">The following example shows how to use a <xref:System.Windows.Controls.MenuItem> in a <xref:System.Windows.Controls.ContextMenu> as a command source for the <xref:System.Windows.Input.ApplicationCommands.Properties%2A> command.</span></span>  
  
 [!code-xaml[CommandingOverviewSnippets#CommandingOverviewCmdSourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewcmdsourcexaml)]  
  
 [!code-csharp[CommandingOverviewSnippets#CommandingOverviewCmdSource](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewcmdsource)]
 [!code-vb[CommandingOverviewSnippets#CommandingOverviewCmdSource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewcmdsource)]  
  
 <span data-ttu-id="f79e8-179">通常，命令源将侦听 <xref:System.Windows.Input.RoutedCommand.CanExecuteChanged> 事件。</span><span class="sxs-lookup"><span data-stu-id="f79e8-179">Typically, a command source will listen to the <xref:System.Windows.Input.RoutedCommand.CanExecuteChanged> event.</span></span>  <span data-ttu-id="f79e8-180">此事件通知命令源在当前命令目标上执行命令的能力可能已发生更改。</span><span class="sxs-lookup"><span data-stu-id="f79e8-180">This event informs the command source that the ability of the command to execute on the current command target may have changed.</span></span>  <span data-ttu-id="f79e8-181">命令源可以使用 <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> 方法查询 <xref:System.Windows.Input.RoutedCommand> 的当前状态。</span><span class="sxs-lookup"><span data-stu-id="f79e8-181">The command source can query the current status of the <xref:System.Windows.Input.RoutedCommand> by using the <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> method.</span></span>  <span data-ttu-id="f79e8-182">如果命令无法执行，命令源可禁用自身。</span><span class="sxs-lookup"><span data-stu-id="f79e8-182">The command source can then disable itself if the command cannot execute.</span></span>  <span data-ttu-id="f79e8-183">此情况的一个示例是 <xref:System.Windows.Controls.MenuItem>，在命令无法执行时，它自身将灰显。</span><span class="sxs-lookup"><span data-stu-id="f79e8-183">An example of this is a <xref:System.Windows.Controls.MenuItem> graying itself out when a command cannot execute.</span></span>  
  
 <span data-ttu-id="f79e8-184"><xref:System.Windows.Input.InputGesture> 可以用作命令源。</span><span class="sxs-lookup"><span data-stu-id="f79e8-184">An <xref:System.Windows.Input.InputGesture> can be used as a command source.</span></span>  <span data-ttu-id="f79e8-185">[!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 中的两种输入笔势是 <xref:System.Windows.Input.KeyGesture> 和 <xref:System.Windows.Input.MouseGesture>。</span><span class="sxs-lookup"><span data-stu-id="f79e8-185">Two types of input gestures in [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] are the <xref:System.Windows.Input.KeyGesture> and <xref:System.Windows.Input.MouseGesture>.</span></span>  <span data-ttu-id="f79e8-186">可以将 <xref:System.Windows.Input.KeyGesture> 视为键盘快捷方式，例如 Ctrl+C。</span><span class="sxs-lookup"><span data-stu-id="f79e8-186">You can think of a <xref:System.Windows.Input.KeyGesture> as a keyboard shortcut, such as CTRL+C.</span></span>  <span data-ttu-id="f79e8-187"><xref:System.Windows.Input.KeyGesture> 由一个 <xref:System.Windows.Input.Key> 和一组 <xref:System.Windows.Input.ModifierKeys> 组成。</span><span class="sxs-lookup"><span data-stu-id="f79e8-187">A <xref:System.Windows.Input.KeyGesture> is comprised of a <xref:System.Windows.Input.Key> and a set of <xref:System.Windows.Input.ModifierKeys>.</span></span>  <span data-ttu-id="f79e8-188"><xref:System.Windows.Input.MouseGesture> 由 <xref:System.Windows.Input.MouseAction> 和一组可选的 <xref:System.Windows.Input.ModifierKeys> 组成。</span><span class="sxs-lookup"><span data-stu-id="f79e8-188">A <xref:System.Windows.Input.MouseGesture> is comprised of a <xref:System.Windows.Input.MouseAction> and an optional set of <xref:System.Windows.Input.ModifierKeys>.</span></span>  
  
 <span data-ttu-id="f79e8-189">为了将 <xref:System.Windows.Input.InputGesture> 用作命令源，它必须与一个命令相关联。</span><span class="sxs-lookup"><span data-stu-id="f79e8-189">In order for an <xref:System.Windows.Input.InputGesture> to act as a command source, it must be associated with a command.</span></span> <span data-ttu-id="f79e8-190">可通过几种方式来实现此目的。</span><span class="sxs-lookup"><span data-stu-id="f79e8-190">There are a few ways to accomplish this.</span></span>  <span data-ttu-id="f79e8-191">其中一种方法是使用 <xref:System.Windows.Input.InputBinding>。</span><span class="sxs-lookup"><span data-stu-id="f79e8-191">One way is to use an <xref:System.Windows.Input.InputBinding>.</span></span>  
  
 <span data-ttu-id="f79e8-192">以下示例演示如何在 <xref:System.Windows.Input.KeyGesture> 和 <xref:System.Windows.Input.RoutedCommand> 之间创建 <xref:System.Windows.Input.KeyBinding>。</span><span class="sxs-lookup"><span data-stu-id="f79e8-192">The following example shows how to create a <xref:System.Windows.Input.KeyBinding> between a <xref:System.Windows.Input.KeyGesture> and a <xref:System.Windows.Input.RoutedCommand>.</span></span>  
  
 [!code-xaml[CommandingOverviewSnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 [!code-csharp[CommandingOverviewSnippets#CommandingOverviewKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewkeybinding)]
 [!code-vb[CommandingOverviewSnippets#CommandingOverviewKeyBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewkeybinding)]  
  
 <span data-ttu-id="f79e8-193">将 <xref:System.Windows.Input.InputGesture> 关联到 <xref:System.Windows.Input.RoutedCommand> 的另一种方法是将 <xref:System.Windows.Input.InputGesture> 添加到 <xref:System.Windows.Input.RoutedCommand> 上的 <xref:System.Windows.Input.InputGestureCollection>。</span><span class="sxs-lookup"><span data-stu-id="f79e8-193">Another way to associate an <xref:System.Windows.Input.InputGesture> to a <xref:System.Windows.Input.RoutedCommand> is to add the <xref:System.Windows.Input.InputGesture> to the <xref:System.Windows.Input.InputGestureCollection> on the <xref:System.Windows.Input.RoutedCommand>.</span></span>  
  
 <span data-ttu-id="f79e8-194">以下示例演示如何将 <xref:System.Windows.Input.KeyGesture> 添加到 <xref:System.Windows.Input.RoutedCommand> 的 <xref:System.Windows.Input.InputGestureCollection> 中。</span><span class="sxs-lookup"><span data-stu-id="f79e8-194">The following example shows how to add a <xref:System.Windows.Input.KeyGesture> to the <xref:System.Windows.Input.InputGestureCollection> of a <xref:System.Windows.Input.RoutedCommand>.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#CommandingOverviewKeyGestureOnCmd](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewkeygestureoncmd)]
 [!code-vb[CommandingOverviewSnippets#CommandingOverviewKeyGestureOnCmd](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewkeygestureoncmd)]  
  
<a name="Command_Binding"></a>

### <a name="commandbinding"></a><span data-ttu-id="f79e8-195">CommandBinding</span><span class="sxs-lookup"><span data-stu-id="f79e8-195">CommandBinding</span></span>  

 <span data-ttu-id="f79e8-196"><xref:System.Windows.Input.CommandBinding> 将命令与实现该命令的事件处理程序相关联。</span><span class="sxs-lookup"><span data-stu-id="f79e8-196">A <xref:System.Windows.Input.CommandBinding> associates a command with the event handlers that implement the command.</span></span>  
  
 <span data-ttu-id="f79e8-197"><xref:System.Windows.Input.CommandBinding> 类包含 <xref:System.Windows.Input.CommandBinding.Command%2A> 属性，及 <xref:System.Windows.Input.CommandBinding.PreviewExecuted>、<xref:System.Windows.Input.CommandBinding.Executed>、<xref:System.Windows.Input.CommandBinding.PreviewCanExecute> 和 <xref:System.Windows.Input.CommandBinding.CanExecute> 事件。</span><span class="sxs-lookup"><span data-stu-id="f79e8-197">The <xref:System.Windows.Input.CommandBinding> class contains a <xref:System.Windows.Input.CommandBinding.Command%2A> property, and <xref:System.Windows.Input.CommandBinding.PreviewExecuted>, <xref:System.Windows.Input.CommandBinding.Executed>, <xref:System.Windows.Input.CommandBinding.PreviewCanExecute>, and <xref:System.Windows.Input.CommandBinding.CanExecute> events.</span></span>  
  
 <span data-ttu-id="f79e8-198"><xref:System.Windows.Input.CommandBinding.Command%2A> 是与 <xref:System.Windows.Input.CommandBinding> 关联的命令。</span><span class="sxs-lookup"><span data-stu-id="f79e8-198"><xref:System.Windows.Input.CommandBinding.Command%2A> is the command that the <xref:System.Windows.Input.CommandBinding> is being associated with.</span></span>  <span data-ttu-id="f79e8-199">附加到 <xref:System.Windows.Input.CommandBinding.PreviewExecuted> 和 <xref:System.Windows.Input.CommandBinding.Executed> 事件的事件处理程序实现命令逻辑。</span><span class="sxs-lookup"><span data-stu-id="f79e8-199">The event handlers which are attached to the <xref:System.Windows.Input.CommandBinding.PreviewExecuted> and <xref:System.Windows.Input.CommandBinding.Executed> events implement the command logic.</span></span>  <span data-ttu-id="f79e8-200">附加到 <xref:System.Windows.Input.CommandBinding.PreviewCanExecute> 和 <xref:System.Windows.Input.CommandBinding.CanExecute> 事件的事件处理程序确定是否可以在当前命令目标上执行该命令。</span><span class="sxs-lookup"><span data-stu-id="f79e8-200">The event handlers attached to the <xref:System.Windows.Input.CommandBinding.PreviewCanExecute> and <xref:System.Windows.Input.CommandBinding.CanExecute> events determine if the command can execute on the current command target.</span></span>  
  
 <span data-ttu-id="f79e8-201">以下示例演示如何在应用程序的根 <xref:System.Windows.Window> 上创建 <xref:System.Windows.Input.CommandBinding>。</span><span class="sxs-lookup"><span data-stu-id="f79e8-201">The following example shows how to create a <xref:System.Windows.Input.CommandBinding> on the root <xref:System.Windows.Window> of an application.</span></span>  <span data-ttu-id="f79e8-202"><xref:System.Windows.Input.CommandBinding> 将 <xref:System.Windows.Input.ApplicationCommands.Open%2A> 命令与 <xref:System.Windows.Input.CommandManager.Executed> 和 <xref:System.Windows.Input.CommandBinding.CanExecute> 处理程序关联。</span><span class="sxs-lookup"><span data-stu-id="f79e8-202">The <xref:System.Windows.Input.CommandBinding> associates the <xref:System.Windows.Input.ApplicationCommands.Open%2A> command with <xref:System.Windows.Input.CommandManager.Executed> and <xref:System.Windows.Input.CommandBinding.CanExecute> handlers.</span></span>  
  
 [!code-xaml[commandwithhandler#CommandHandlerCommandBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/commandWithHandler/CSharp/Window1.xaml#commandhandlercommandbinding)]  
  
 [!code-csharp[CommandHandlerProcedural#CommandHandlerBindingInit](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandHandlerProcedural/CSharp/Window1.xaml.cs#commandhandlerbindinginit)]
 [!code-vb[CommandHandlerProcedural#CommandHandlerBindingInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandHandlerProcedural/visualbasic/window1.xaml.vb#commandhandlerbindinginit)]  
  
 <span data-ttu-id="f79e8-203">接下来，创建了 <xref:System.Windows.Input.ExecutedRoutedEventHandler> 和 <xref:System.Windows.Input.CanExecuteRoutedEventHandler>。</span><span class="sxs-lookup"><span data-stu-id="f79e8-203">Next, the <xref:System.Windows.Input.ExecutedRoutedEventHandler> and a <xref:System.Windows.Input.CanExecuteRoutedEventHandler> are created.</span></span>  <span data-ttu-id="f79e8-204"><xref:System.Windows.Input.ExecutedRoutedEventHandler> 打开了显示字符串的 <xref:System.Windows.MessageBox>，该字符串表示已执行此命令。</span><span class="sxs-lookup"><span data-stu-id="f79e8-204">The <xref:System.Windows.Input.ExecutedRoutedEventHandler> opens a <xref:System.Windows.MessageBox> that displays a string saying the command has been executed.</span></span>  <span data-ttu-id="f79e8-205"><xref:System.Windows.Input.CanExecuteRoutedEventHandler> 将 <xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A> 属性设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="f79e8-205">The <xref:System.Windows.Input.CanExecuteRoutedEventHandler> sets the <xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A> property to `true`.</span></span>  
  
 [!code-csharp[commandwithhandler#CommandHandlerExecutedHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/commandWithHandler/CSharp/Window1.xaml.cs#commandhandlerexecutedhandler)]
 [!code-vb[commandwithhandler#CommandHandlerExecutedHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/commandWithHandler/VisualBasic/Window1.xaml.vb#commandhandlerexecutedhandler)]  
  
 [!code-csharp[commandwithhandler#CommandHandlerCanExecuteHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/commandWithHandler/CSharp/Window1.xaml.cs#commandhandlercanexecutehandler)]
 [!code-vb[commandwithhandler#CommandHandlerCanExecuteHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/commandWithHandler/VisualBasic/Window1.xaml.vb#commandhandlercanexecutehandler)]  
  
 <span data-ttu-id="f79e8-206">将 <xref:System.Windows.Input.CommandBinding> 附加到特定对象，例如应用程序或控件的根 <xref:System.Windows.Window>。</span><span class="sxs-lookup"><span data-stu-id="f79e8-206">A <xref:System.Windows.Input.CommandBinding> is attached to a specific object, such as the root <xref:System.Windows.Window> of the application or a control.</span></span>  <span data-ttu-id="f79e8-207"><xref:System.Windows.Input.CommandBinding> 附加到的对象定义了绑定的范围。</span><span class="sxs-lookup"><span data-stu-id="f79e8-207">The object that the <xref:System.Windows.Input.CommandBinding> is attached to defines the scope of the binding.</span></span>  <span data-ttu-id="f79e8-208">例如，附加到命令目标的上级元素的 <xref:System.Windows.Input.CommandBinding> 可以通过 <xref:System.Windows.Input.CommandBinding.Executed> 事件到达，但无法到达附加到命令目标的下级元素的 <xref:System.Windows.Input.CommandBinding>。</span><span class="sxs-lookup"><span data-stu-id="f79e8-208">For example, a <xref:System.Windows.Input.CommandBinding> attached to an ancestor of the command target can be reached by the <xref:System.Windows.Input.CommandBinding.Executed> event, but a <xref:System.Windows.Input.CommandBinding> attached to a descendant of the command target cannot be reached.</span></span>  <span data-ttu-id="f79e8-209">其直接原因在于 <xref:System.Windows.RoutedEvent> 从引发事件的对象通行和浮升的方式。</span><span class="sxs-lookup"><span data-stu-id="f79e8-209">This is a direct consequence of the way a <xref:System.Windows.RoutedEvent> tunnels and bubbles from the object that raises the event.</span></span>  
  
 <span data-ttu-id="f79e8-210">在某些情况下，<xref:System.Windows.Input.CommandBinding> 会附加到命令目标本身，例如 <xref:System.Windows.Controls.TextBox> 类及 <xref:System.Windows.Input.ApplicationCommands.Cut%2A>、<xref:System.Windows.Input.ApplicationCommands.Copy%2A> 和 <xref:System.Windows.Input.ApplicationCommands.Paste%2A> 命令。</span><span class="sxs-lookup"><span data-stu-id="f79e8-210">In some situations the <xref:System.Windows.Input.CommandBinding> is attached to the command target itself, such as with the <xref:System.Windows.Controls.TextBox> class and the <xref:System.Windows.Input.ApplicationCommands.Cut%2A>, <xref:System.Windows.Input.ApplicationCommands.Copy%2A>, and <xref:System.Windows.Input.ApplicationCommands.Paste%2A> commands.</span></span> <span data-ttu-id="f79e8-211">然而，很多时候将 <xref:System.Windows.Input.CommandBinding> 附加到命令目标的上级元素（例如主要 <xref:System.Windows.Window> 或应用程序对象）会更加方便，尤其是在同一 <xref:System.Windows.Input.CommandBinding> 可用于多个命令目标时。</span><span class="sxs-lookup"><span data-stu-id="f79e8-211">Quite often though, it is more convenient to attach the <xref:System.Windows.Input.CommandBinding> to an ancestor of the command target, such as the main <xref:System.Windows.Window> or the Application object, especially if the same <xref:System.Windows.Input.CommandBinding> can be used for multiple command targets.</span></span>  <span data-ttu-id="f79e8-212">这是在创建命令基础结构时需要考虑的设计决策。</span><span class="sxs-lookup"><span data-stu-id="f79e8-212">These are design decisions you will want to consider when you are creating your commanding infrastructure.</span></span>  
  
<a name="Commane_Target"></a>

### <a name="command-target"></a><span data-ttu-id="f79e8-213">命令目标</span><span class="sxs-lookup"><span data-stu-id="f79e8-213">Command Target</span></span>  

 <span data-ttu-id="f79e8-214">命令目标是在其上执行命令的元素。</span><span class="sxs-lookup"><span data-stu-id="f79e8-214">The command target is the element on which the command is executed.</span></span>  <span data-ttu-id="f79e8-215">关于 <xref:System.Windows.Input.RoutedCommand>，命令目标是 <xref:System.Windows.Input.CommandManager.Executed> 和 <xref:System.Windows.Input.CommandManager.CanExecute> 的路由开始的元素。</span><span class="sxs-lookup"><span data-stu-id="f79e8-215">With regards to a <xref:System.Windows.Input.RoutedCommand>, the command target is the element at which routing of the <xref:System.Windows.Input.CommandManager.Executed> and <xref:System.Windows.Input.CommandManager.CanExecute> starts.</span></span>  <span data-ttu-id="f79e8-216">如前所述，在 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 中，仅当 <xref:System.Windows.Input.ICommand> 为 <xref:System.Windows.Input.RoutedCommand> 时，<xref:System.Windows.Input.ICommandSource> 上的 <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> 属性才适用。</span><span class="sxs-lookup"><span data-stu-id="f79e8-216">As noted previously, in [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] the <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> property on <xref:System.Windows.Input.ICommandSource> is only applicable when the <xref:System.Windows.Input.ICommand> is a <xref:System.Windows.Input.RoutedCommand>.</span></span>  <span data-ttu-id="f79e8-217">如果在 <xref:System.Windows.Input.ICommandSource> 上设置 <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> 并且相应的命令不是 <xref:System.Windows.Input.RoutedCommand>，则忽略命令目标。</span><span class="sxs-lookup"><span data-stu-id="f79e8-217">If the <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> is set on an <xref:System.Windows.Input.ICommandSource> and the corresponding command is not a <xref:System.Windows.Input.RoutedCommand>, the command target is ignored.</span></span>  
  
 <span data-ttu-id="f79e8-218">命令源可以显式设置命令目标。</span><span class="sxs-lookup"><span data-stu-id="f79e8-218">The command source can explicitly set the command target.</span></span>  <span data-ttu-id="f79e8-219">如果未定义命令目标，则具有键盘焦点的元素将用作命令目标。</span><span class="sxs-lookup"><span data-stu-id="f79e8-219">If the command target is not defined, the element with keyboard focus will be used as the command target.</span></span>  <span data-ttu-id="f79e8-220">将具有键盘焦点的元素用作命令目标的一个好处在于，这样可使应用程序开发者能够使用同一命令源在多个目标上调用命令，而无需跟踪命令目标。</span><span class="sxs-lookup"><span data-stu-id="f79e8-220">One of the benefits of using the element with keyboard focus as the command target is that it allows the application developer to use the same command source to invoke a command on multiple targets without having to keep track of the command target.</span></span>  <span data-ttu-id="f79e8-221">例如，如果 <xref:System.Windows.Controls.MenuItem> 在具有 <xref:System.Windows.Controls.TextBox> 控件和 <xref:System.Windows.Controls.PasswordBox> 控件的应用程序中调用“Paste”命令，则目标可以是 <xref:System.Windows.Controls.TextBox> 或 <xref:System.Windows.Controls.PasswordBox>，具体取决于哪个控件具有键盘焦点。</span><span class="sxs-lookup"><span data-stu-id="f79e8-221">For example, if a <xref:System.Windows.Controls.MenuItem> invokes the **Paste** command in an application that has a <xref:System.Windows.Controls.TextBox> control and a <xref:System.Windows.Controls.PasswordBox> control, the target can be either the <xref:System.Windows.Controls.TextBox> or <xref:System.Windows.Controls.PasswordBox> depending on which control has keyboard focus.</span></span>  
  
 <span data-ttu-id="f79e8-222">以下示例演示如何在标记和代码隐藏中显式设置命令目标。</span><span class="sxs-lookup"><span data-stu-id="f79e8-222">The following example shows how to explicitly set the command target in markup and in code behind.</span></span>  
  
 [!code-xaml[CommandingOverviewSnippets#CommandingOverviewXAMLCommandTarget](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlcommandtarget)]  
  
 [!code-csharp[CommandingOverviewSnippets#CommandingOverviewCommandTargetCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewcommandtargetcodebehind)]
 [!code-vb[CommandingOverviewSnippets#CommandingOverviewCommandTargetCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewcommandtargetcodebehind)]  
  
<a name="Command_Manager"></a>

### <a name="the-commandmanager"></a><span data-ttu-id="f79e8-223">CommandManager</span><span class="sxs-lookup"><span data-stu-id="f79e8-223">The CommandManager</span></span>  

 <span data-ttu-id="f79e8-224"><xref:System.Windows.Input.CommandManager> 提供许多与命令相关的函数。</span><span class="sxs-lookup"><span data-stu-id="f79e8-224">The <xref:System.Windows.Input.CommandManager> serves a number of command related functions.</span></span>  <span data-ttu-id="f79e8-225">它提供了一组静态方法，用于在特定元素中添加和删除 <xref:System.Windows.Input.CommandManager.PreviewExecuted>、<xref:System.Windows.Input.CommandManager.Executed>、<xref:System.Windows.Input.CommandManager.PreviewCanExecute> 和 <xref:System.Windows.Input.CommandManager.CanExecute> 事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="f79e8-225">It provides a set of static methods for adding and removing <xref:System.Windows.Input.CommandManager.PreviewExecuted>, <xref:System.Windows.Input.CommandManager.Executed>, <xref:System.Windows.Input.CommandManager.PreviewCanExecute>, and <xref:System.Windows.Input.CommandManager.CanExecute> event handlers to and from a specific element.</span></span>  <span data-ttu-id="f79e8-226">它提供了将 <xref:System.Windows.Input.CommandBinding> 和 <xref:System.Windows.Input.InputBinding> 对象注册到特定类的方法。</span><span class="sxs-lookup"><span data-stu-id="f79e8-226">It provides a means to register <xref:System.Windows.Input.CommandBinding> and <xref:System.Windows.Input.InputBinding> objects onto a specific class.</span></span>  <span data-ttu-id="f79e8-227"><xref:System.Windows.Input.CommandManager> 还通过 <xref:System.Windows.Input.CommandManager.RequerySuggested> 事件提供了一种方法，用于在应引发 <xref:System.Windows.Input.ICommand.CanExecuteChanged> 事件时通知命令。</span><span class="sxs-lookup"><span data-stu-id="f79e8-227">The <xref:System.Windows.Input.CommandManager> also provides a means, through the <xref:System.Windows.Input.CommandManager.RequerySuggested> event, to notify a command when it should raise the <xref:System.Windows.Input.ICommand.CanExecuteChanged> event.</span></span>  
  
 <span data-ttu-id="f79e8-228"><xref:System.Windows.Input.CommandManager.InvalidateRequerySuggested%2A> 方法强制 <xref:System.Windows.Input.CommandManager> 引发 <xref:System.Windows.Input.CommandManager.RequerySuggested> 事件。</span><span class="sxs-lookup"><span data-stu-id="f79e8-228">The <xref:System.Windows.Input.CommandManager.InvalidateRequerySuggested%2A> method forces the <xref:System.Windows.Input.CommandManager> to raise the <xref:System.Windows.Input.CommandManager.RequerySuggested> event.</span></span>  <span data-ttu-id="f79e8-229">这在应禁用/启用命令的情况下非常有用，但对于 <xref:System.Windows.Input.CommandManager> 可识别的情况，则不太有用。</span><span class="sxs-lookup"><span data-stu-id="f79e8-229">This is useful for conditions that should disable/enable a command but are not conditions that the <xref:System.Windows.Input.CommandManager> is aware of.</span></span>  
  
<a name="Command_Library"></a>

## <a name="command-library"></a><span data-ttu-id="f79e8-230">命令库</span><span class="sxs-lookup"><span data-stu-id="f79e8-230">Command Library</span></span>  

 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="f79e8-231">提供一组预定义命令。</span><span class="sxs-lookup"><span data-stu-id="f79e8-231">provides a set of predefined commands.</span></span>  <span data-ttu-id="f79e8-232">命令库包括以下类：<xref:System.Windows.Input.ApplicationCommands>、<xref:System.Windows.Input.NavigationCommands>、<xref:System.Windows.Input.MediaCommands>、<xref:System.Windows.Documents.EditingCommands> 和 <xref:System.Windows.Input.ComponentCommands>。</span><span class="sxs-lookup"><span data-stu-id="f79e8-232">The command library consists of the following classes: <xref:System.Windows.Input.ApplicationCommands>, <xref:System.Windows.Input.NavigationCommands>, <xref:System.Windows.Input.MediaCommands>, <xref:System.Windows.Documents.EditingCommands>, and the <xref:System.Windows.Input.ComponentCommands>.</span></span>  <span data-ttu-id="f79e8-233">这些类提供诸如 <xref:System.Windows.Input.ApplicationCommands.Cut%2A>、<xref:System.Windows.Input.NavigationCommands.BrowseBack%2A>、<xref:System.Windows.Input.NavigationCommands.BrowseForward%2A>、<xref:System.Windows.Input.MediaCommands.Play%2A>、<xref:System.Windows.Input.MediaCommands.Stop%2A> 和 <xref:System.Windows.Input.MediaCommands.Pause%2A> 的命令。</span><span class="sxs-lookup"><span data-stu-id="f79e8-233">These classes provide commands such as <xref:System.Windows.Input.ApplicationCommands.Cut%2A>, <xref:System.Windows.Input.NavigationCommands.BrowseBack%2A> and <xref:System.Windows.Input.NavigationCommands.BrowseForward%2A>, <xref:System.Windows.Input.MediaCommands.Play%2A>, <xref:System.Windows.Input.MediaCommands.Stop%2A>, and <xref:System.Windows.Input.MediaCommands.Pause%2A>.</span></span>  
  
 <span data-ttu-id="f79e8-234">许多这些命令都包含一组默认输入绑定。</span><span class="sxs-lookup"><span data-stu-id="f79e8-234">Many of these commands include a set of default input bindings.</span></span>  <span data-ttu-id="f79e8-235">例如，如果指定应用程序处理 "复制" 命令，则会自动获取键盘绑定 "CTRL + C"。还会获取其他输入设备的绑定，如 Tablet PC 笔笔势和语音信息。</span><span class="sxs-lookup"><span data-stu-id="f79e8-235">For example, if you specify that your application handles the copy command, you automatically get the keyboard binding "CTRL+C" You also get bindings for other input devices, such as Tablet PC pen gestures and speech information.</span></span>  
  
 <span data-ttu-id="f79e8-236">使用 [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] 引用各个命令库中的命令时，通常可省略公开静态命令属性的库类的类名。</span><span class="sxs-lookup"><span data-stu-id="f79e8-236">When you reference commands in the various command libraries using [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)], you can usually omit the class name of the library class that exposes the static command property.</span></span> <span data-ttu-id="f79e8-237">一般来说，命令名称是明确作为字符串的，且存在所属类型来提供命令的逻辑分组，不过对于消除二义性这并不必要。</span><span class="sxs-lookup"><span data-stu-id="f79e8-237">Generally, the command names are unambiguous as strings, and the owning types exist to provide a logical grouping of commands but are not necessary for disambiguation.</span></span> <span data-ttu-id="f79e8-238">例如，可指定 `Command="Cut"` 而不是更为冗长的 `Command="ApplicationCommands.Cut"`。</span><span class="sxs-lookup"><span data-stu-id="f79e8-238">For instance, you can specify `Command="Cut"` rather than the more verbose `Command="ApplicationCommands.Cut"`.</span></span> <span data-ttu-id="f79e8-239">这是一种便利的机制，它内置于处理器中， [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] 用于更精确地 (命令，它是的类型转换器行为 <xref:System.Windows.Input.ICommand> ， [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] 在加载时) 处理器引用。</span><span class="sxs-lookup"><span data-stu-id="f79e8-239">This is a convenience mechanism that is built in to the [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] processor for commands (more precisely, it is a type converter behavior of <xref:System.Windows.Input.ICommand>, which the [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] processor references at load time).</span></span>  
  
<a name="creating_commands"></a>

## <a name="creating-custom-commands"></a><span data-ttu-id="f79e8-240">创建自定义命令</span><span class="sxs-lookup"><span data-stu-id="f79e8-240">Creating Custom Commands</span></span>  

 <span data-ttu-id="f79e8-241">如果命令库类中的命令不能满足需要，你可以创建自己的命令。</span><span class="sxs-lookup"><span data-stu-id="f79e8-241">If the commands in the command library classes do not meet your needs, then you can create your own commands.</span></span>  <span data-ttu-id="f79e8-242">可通过两种方式创建自定义命令。</span><span class="sxs-lookup"><span data-stu-id="f79e8-242">There are two ways to create a custom command.</span></span>  <span data-ttu-id="f79e8-243">第一种方式是从头开始并实现 <xref:System.Windows.Input.ICommand> 接口。</span><span class="sxs-lookup"><span data-stu-id="f79e8-243">The first is to start from the ground up and implement the <xref:System.Windows.Input.ICommand> interface.</span></span>  <span data-ttu-id="f79e8-244">另一种更常见的方法是创建 <xref:System.Windows.Input.RoutedCommand> 或 <xref:System.Windows.Input.RoutedUICommand>。</span><span class="sxs-lookup"><span data-stu-id="f79e8-244">The other way, and the more common approach, is to create a <xref:System.Windows.Input.RoutedCommand> or a <xref:System.Windows.Input.RoutedUICommand>.</span></span>  
  
 <span data-ttu-id="f79e8-245">有关创建自定义 <xref:System.Windows.Input.RoutedCommand> 的示例，请参阅[创建自定义 RoutedCommand 示例](https://github.com/Microsoft/WPF-Samples/tree/master/Input%20and%20Commands/CustomRoutedCommand)。</span><span class="sxs-lookup"><span data-stu-id="f79e8-245">For an example of creating a custom <xref:System.Windows.Input.RoutedCommand>, see [Create a Custom RoutedCommand Sample](https://github.com/Microsoft/WPF-Samples/tree/master/Input%20and%20Commands/CustomRoutedCommand).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f79e8-246">请参阅</span><span class="sxs-lookup"><span data-stu-id="f79e8-246">See also</span></span>

- <xref:System.Windows.Input.RoutedCommand>
- <xref:System.Windows.Input.CommandBinding>
- <xref:System.Windows.Input.InputBinding>
- <xref:System.Windows.Input.CommandManager>
- [<span data-ttu-id="f79e8-247">输入概述</span><span class="sxs-lookup"><span data-stu-id="f79e8-247">Input Overview</span></span>](input-overview.md)
- [<span data-ttu-id="f79e8-248">路由事件概述</span><span class="sxs-lookup"><span data-stu-id="f79e8-248">Routed Events Overview</span></span>](routed-events-overview.md)
- [<span data-ttu-id="f79e8-249">实现 ICommandSource</span><span class="sxs-lookup"><span data-stu-id="f79e8-249">Implement ICommandSource</span></span>](how-to-implement-icommandsource.md)
- <span data-ttu-id="f79e8-250">[如何：将命令添加到菜单项](/previous-versions/dotnet/netframework-3.5/ms741839(v=vs.90))</span><span class="sxs-lookup"><span data-stu-id="f79e8-250">[How to: Add a Command to a MenuItem](/previous-versions/dotnet/netframework-3.5/ms741839(v=vs.90))</span></span>
- [<span data-ttu-id="f79e8-251">创建自定义 RoutedCommand 示例</span><span class="sxs-lookup"><span data-stu-id="f79e8-251">Create a Custom RoutedCommand Sample</span></span>](https://github.com/Microsoft/WPF-Samples/tree/master/Input%20and%20Commands/CustomRoutedCommand)
