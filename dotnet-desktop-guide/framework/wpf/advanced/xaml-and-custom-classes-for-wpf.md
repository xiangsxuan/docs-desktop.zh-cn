---
title: XAML 和自定义类
ms.date: 03/30/2017
helpviewer_keywords:
- custom classes in XAML [WPF]
- XAML [WPF], custom classes
- classes [WPF], custom classes in XAML
ms.assetid: e7313137-581e-4a64-8453-d44e15a6164a
ms.openlocfilehash: 86d3c01e6080a0c6f4f7f7d687d70a074b9adc88
ms.sourcegitcommit: 069786bcadbf9cd931d7dc3d892262cd852d2ffb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/19/2021
ms.locfileid: "104667442"
---
# <a name="xaml-and-custom-classes-for-wpf"></a><span data-ttu-id="5de1f-102">XAML 及 WPF 的自定义类</span><span class="sxs-lookup"><span data-stu-id="5de1f-102">XAML and Custom Classes for WPF</span></span>
<span data-ttu-id="5de1f-103">在公共语言运行时中实现的 XAML (CLR) 框架支持在任何公共语言运行时 (CLR) 语言中定义自定义类或结构，然后使用 XAML 标记访问该类。</span><span class="sxs-lookup"><span data-stu-id="5de1f-103">XAML as implemented in common language runtime (CLR) frameworks supports the ability to define a custom class or structure in any common language runtime (CLR) language, and then access that class using XAML markup.</span></span> <span data-ttu-id="5de1f-104">通常通过将自定义类型映射到 XAML 命名空间前缀，可在同一标记文件中混合使用 [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] 定义类型和自定义类型。</span><span class="sxs-lookup"><span data-stu-id="5de1f-104">You can use a mixture of [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)]-defined types and your custom types within the same markup file, typically by mapping the custom types to a XAML namespace prefix.</span></span> <span data-ttu-id="5de1f-105">本主题讨论将自定义类用作 XAML 元素必须满足的要求。</span><span class="sxs-lookup"><span data-stu-id="5de1f-105">This topic discusses the requirements that a custom class must satisfy to be usable as a XAML element.</span></span>  

<a name="Custom_Classes_in_Applications_vs__in_Assemblies"></a>
## <a name="custom-classes-in-applications-or-assemblies"></a><span data-ttu-id="5de1f-106">应用程序或程序集中的自定义类</span><span class="sxs-lookup"><span data-stu-id="5de1f-106">Custom Classes in Applications or Assemblies</span></span>  
 <span data-ttu-id="5de1f-107">XAML 中使用的自定义类可通过两种不同的方式进行定义：在代码隐藏或其他生成主 [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] 应用程序的代码内，或者在单独程序集中作为类（例如用作类库的可执行文件或 DLL）。</span><span class="sxs-lookup"><span data-stu-id="5de1f-107">Custom classes that are used in XAML can be defined in two distinct ways: within the code-behind or other code that produces the primary [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] application, or as a class in a separate assembly, such as an executable or DLL used as a class library.</span></span> <span data-ttu-id="5de1f-108">这些方法各有特定的优点和缺点。</span><span class="sxs-lookup"><span data-stu-id="5de1f-108">Each of these approaches has particular advantages and disadvantages.</span></span>  
  
- <span data-ttu-id="5de1f-109">创建类库的优点在于可在多个不同的应用程序间共享任意此类自定义类。</span><span class="sxs-lookup"><span data-stu-id="5de1f-109">The advantage of creating a class library is that any such custom classes can be shared across many different possible applications.</span></span> <span data-ttu-id="5de1f-110">通过使用单独的库，更易于控制应用程序的版本控制问题，并可简化类创建过程，在此过程中，所需的类用法是作为 XAML 页面上的根元素。</span><span class="sxs-lookup"><span data-stu-id="5de1f-110">A separate library also makes versioning issues of applications easier to control, and simplifies creating a class where the intended class usage is as a root element on a XAML page.</span></span>  
  
- <span data-ttu-id="5de1f-111">在应用程序中定义自定义类的优点在于此方法相对轻量，可减少在主应用程序可执行文件外引入单独程序集时遇到的部署和测试问题。</span><span class="sxs-lookup"><span data-stu-id="5de1f-111">The advantage of defining the custom classes in the application is that this technique is relatively lightweight and minimizes the deployment and testing issues encountered when you introduce separate assemblies beyond the main application executable.</span></span>  
  
- <span data-ttu-id="5de1f-112">无论定义在相同还是不同的程序集中，自定义类若要在 XAML 中用作元素，都需要在 CLR 命名空间和 XML 命名空间之间进行映射。</span><span class="sxs-lookup"><span data-stu-id="5de1f-112">Whether defined in the same or different assembly, custom classes need to be mapped between CLR  namespace and XML  namespace in order to be used in XAML as elements.</span></span> <span data-ttu-id="5de1f-113">请参阅 [WPF XAML 的 XAML 命名空间和命名空间映射](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="5de1f-113">See [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="Requirements_for_a_Custom_Class_as_a_XAML_Element"></a>
## <a name="requirements-for-a-custom-class-as-a-xaml-element"></a><span data-ttu-id="5de1f-114">将自定义类用作 XAML 元素的要求</span><span class="sxs-lookup"><span data-stu-id="5de1f-114">Requirements for a Custom Class as a XAML Element</span></span>  
 <span data-ttu-id="5de1f-115">为能够实例化为对象元素，类必须满足以下要求：</span><span class="sxs-lookup"><span data-stu-id="5de1f-115">In order to be able to be instantiated as an object element, your class must meet the following requirements:</span></span>  
  
- <span data-ttu-id="5de1f-116">自定义类必须是公共的且支持默认（无参数）公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="5de1f-116">Your custom class must be public and support a default (parameterless) public constructor.</span></span> <span data-ttu-id="5de1f-117">（有关结构注释，请参阅下节内容。）</span><span class="sxs-lookup"><span data-stu-id="5de1f-117">(See following section for notes regarding structures.)</span></span>  
  
- <span data-ttu-id="5de1f-118">自定义类不得为嵌套类。</span><span class="sxs-lookup"><span data-stu-id="5de1f-118">Your custom class must not be a nested class.</span></span> <span data-ttu-id="5de1f-119">嵌套类及其常规 CLR 使用语法中的“点”会干扰其他 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 和/或 XAML 功能（例如附加属性）。</span><span class="sxs-lookup"><span data-stu-id="5de1f-119">Nested classes and the "dot" in their general CLR usage syntax interfere with other [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] and/or XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="5de1f-120">除启用对象元素语法外，对象定义还会对任何其他将该对象作为值类型的公共属性启用属性元素语法。</span><span class="sxs-lookup"><span data-stu-id="5de1f-120">In addition to enabling object element syntax, your object definition also enables property element syntax for any other public properties that take that object as the value type.</span></span> <span data-ttu-id="5de1f-121">这是因为对象现在可被实例化为对象元素，且可填充此类属性的属性元素值。</span><span class="sxs-lookup"><span data-stu-id="5de1f-121">This is because the object can now be instantiated as an object element and can fill the property element value of such a property.</span></span>  
  
### <a name="structures"></a><span data-ttu-id="5de1f-122">結構</span><span class="sxs-lookup"><span data-stu-id="5de1f-122">Structures</span></span>  
 <span data-ttu-id="5de1f-123">你定义为自定义类型的结构始终能够在中的 XAML 中构造 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 。这是因为 CLR 编译器会为结构隐式创建一个无参数的构造函数，该构造函数将所有属性值初始化为其默认值。</span><span class="sxs-lookup"><span data-stu-id="5de1f-123">Structures that you define as custom types are always able to be constructed in XAML  in [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] .This is because the CLR compilers implicitly create a parameterless constructor for a structure that initializes all property values to their defaults.</span></span> <span data-ttu-id="5de1f-124">某些情况下，结构并不需要默认构造行为和/或对象元素用法。</span><span class="sxs-lookup"><span data-stu-id="5de1f-124">In some cases, the default construction behavior and/or object element usage for a structure is not desirable.</span></span> <span data-ttu-id="5de1f-125">这可能是因为结构需要通过概念方式将值和函数作为联合来填充，其中包含的值可能具有互斥的解释，因而其不存在任何可设置属性。</span><span class="sxs-lookup"><span data-stu-id="5de1f-125">This might be because the structure is intended to fill values and function conceptually as a union, where the values contained might have mutually exclusive interpretations and thus none of its properties are settable.</span></span> <span data-ttu-id="5de1f-126">[!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)]此类结构的一个示例是 <xref:System.Windows.GridLength> 。</span><span class="sxs-lookup"><span data-stu-id="5de1f-126">A [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] example of such a structure is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="5de1f-127">通常情况下，此类结构应实现类型转换器，以便可通过属性形式表达值，方法是使用创建结构值的不同解释或模式的字符串约定。</span><span class="sxs-lookup"><span data-stu-id="5de1f-127">Generally, such structures should implement a type converter such that the values can be expressed in attribute form, using string conventions that create the different interpretations or modes of the structure's values.</span></span> <span data-ttu-id="5de1f-128">结构还应通过非参数构造函数公开代码构造的类似行为。</span><span class="sxs-lookup"><span data-stu-id="5de1f-128">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>  
  
<a name="Requirements_for_Properties_of_a_Custom_Class_as_XAML"></a>
## <a name="requirements-for-properties-of-a-custom-class-as-xaml-attributes"></a><span data-ttu-id="5de1f-129">将自定义类属性用作 XAML 特性的要求</span><span class="sxs-lookup"><span data-stu-id="5de1f-129">Requirements for Properties of a Custom Class as XAML Attributes</span></span>  
 <span data-ttu-id="5de1f-130">属性必须引用按值类型 (例如基元) ，或使用具有可参数构造函数或 XAML 处理器可以访问的专用类型转换器的类型的类。</span><span class="sxs-lookup"><span data-stu-id="5de1f-130">Properties must reference a by-value type (such as a primitive), or use a class for type that has either a parameterless constructor or a dedicated type converter that a XAML processor can access.</span></span> <span data-ttu-id="5de1f-131">在 CLR XAML 实现中，XAML 处理器通过对语言基元的本机支持或通过应用 <xref:System.ComponentModel.TypeConverterAttribute> 到后备类型定义中的类型或成员查找此类转换器</span><span class="sxs-lookup"><span data-stu-id="5de1f-131">In the CLR XAML implementation, XAML processors either find such converters through native support for language primitives, or through application of <xref:System.ComponentModel.TypeConverterAttribute> to a type or member in backing type definitions</span></span>  
  
 <span data-ttu-id="5de1f-132">或者，属性可引用抽象类类型或接口。</span><span class="sxs-lookup"><span data-stu-id="5de1f-132">Alternatively, the property may reference an abstract class type, or an interface.</span></span> <span data-ttu-id="5de1f-133">对于抽象类或接口，XAML 分析的所需条件是必须用实现接口的实际类实例或派生自抽象类的类型实例填充属性值。</span><span class="sxs-lookup"><span data-stu-id="5de1f-133">For abstract classes or interfaces, the expectation for XAML parsing is that the property value must be filled with practical class instances that implement the interface, or instances of types that derive from the abstract class.</span></span>  
  
 <span data-ttu-id="5de1f-134">属性可在抽象类上声明，但仅可在派生自抽象类的实际类上设置。</span><span class="sxs-lookup"><span data-stu-id="5de1f-134">Properties can be declared on an abstract class, but can only be set on practical classes that derive from the abstract class.</span></span> <span data-ttu-id="5de1f-135">这是因为，为类创建对象元素根本需要类的公共无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="5de1f-135">This is because creating the object element for the class at all requires a public parameterless constructor on the class.</span></span>  
  
### <a name="typeconverter-enabled-attribute-syntax"></a><span data-ttu-id="5de1f-136">启用 TypeConverter 的特性语法</span><span class="sxs-lookup"><span data-stu-id="5de1f-136">TypeConverter Enabled Attribute Syntax</span></span>  
 <span data-ttu-id="5de1f-137">如果提供类级别的专用特性化类型转换器，则应用的类型转换会对需实例化该类型的任何属性启用特性语法。</span><span class="sxs-lookup"><span data-stu-id="5de1f-137">If you provide a dedicated, attributed type converter at the class level, the applied type conversion enables attribute syntax for any property that needs to instantiate that type.</span></span> <span data-ttu-id="5de1f-138">类型转换器不启用类型的对象元素用法;只有该类型的无参数构造函数才会启用对象元素用法。</span><span class="sxs-lookup"><span data-stu-id="5de1f-138">A type converter does not enable object element usage of the type; only the presence of a parameterless constructor for that type enables object element usage.</span></span> <span data-ttu-id="5de1f-139">因此，启用类型转换器的属性通常不适用于属性语法，除非类型本身也支持对象元素语法。</span><span class="sxs-lookup"><span data-stu-id="5de1f-139">Therefore, properties that are type-converter enabled are generally speaking not usable in property syntax, unless the type itself also supports object element syntax.</span></span> <span data-ttu-id="5de1f-140">此规则存在一个例外，即可指定属性元素语法，但使属性元素包含一个字符串。</span><span class="sxs-lookup"><span data-stu-id="5de1f-140">The exception to this is that you can specify a property element syntax, but have the property element contain a string.</span></span> <span data-ttu-id="5de1f-141">这种用法实质上相当于属性语法用法，因此，这种用法并不常见，除非需要对特性值进行更可靠的空白处理。</span><span class="sxs-lookup"><span data-stu-id="5de1f-141">That usage is really essentially equivalent to an attribute syntax usage, and such a usage is not common unless there is a need for more robust white-space handling of the attribute value.</span></span> <span data-ttu-id="5de1f-142">例如，以下是一个采用字符串的属性元素用法以及一个特性用法等效项：</span><span class="sxs-lookup"><span data-stu-id="5de1f-142">For example, the following is a property element usage that takes a string, and the attribute usage equivalent:</span></span>  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe)]  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE2](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe2)]  
  
 <span data-ttu-id="5de1f-143">允许使用特性语法的属性的示例，但不允许通过 XAML 使用包含对象元素的属性元素语法，这是采用类型的各种属性 <xref:System.Windows.Input.Cursor> 。</span><span class="sxs-lookup"><span data-stu-id="5de1f-143">Examples of properties where attribute syntax is allowed but property element syntax that contains an object element is disallowed through XAML are various properties that take the <xref:System.Windows.Input.Cursor> type.</span></span> <span data-ttu-id="5de1f-144"><xref:System.Windows.Input.Cursor>类具有专用的类型转换器 <xref:System.Windows.Input.CursorConverter> ，但不公开无参数构造函数，因此， <xref:System.Windows.FrameworkElement.Cursor%2A> 只能通过特性语法来设置属性，即使实际 <xref:System.Windows.Input.Cursor> 类型是引用类型。</span><span class="sxs-lookup"><span data-stu-id="5de1f-144">The <xref:System.Windows.Input.Cursor> class has a dedicated type converter <xref:System.Windows.Input.CursorConverter>, but does not expose a parameterless constructor, so the <xref:System.Windows.FrameworkElement.Cursor%2A> property can only be set through attribute syntax even though the actual <xref:System.Windows.Input.Cursor> type is a reference type.</span></span>  
  
### <a name="per-property-type-converters"></a><span data-ttu-id="5de1f-145">按属性类型转换器</span><span class="sxs-lookup"><span data-stu-id="5de1f-145">Per-Property Type Converters</span></span>  
 <span data-ttu-id="5de1f-146">或者，属性本身可能声明属性级别的类型转换器。</span><span class="sxs-lookup"><span data-stu-id="5de1f-146">Alternatively, the property itself may declare a type converter at the property level.</span></span> <span data-ttu-id="5de1f-147">这将启用 "微型语言"，它通过将属性的传入字符串值作为基于适当类型的操作的输入处理，来实例化内联属性类型的对象 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 。</span><span class="sxs-lookup"><span data-stu-id="5de1f-147">This enables a "mini language" that instantiates objects of the type of the property inline, by processing incoming string values of the attribute as input for a <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> operation based on the appropriate type.</span></span> <span data-ttu-id="5de1f-148">此操作的目的通常是提供方便的访问器，且这不是在 XAML 中启用属性设置的唯一方式。</span><span class="sxs-lookup"><span data-stu-id="5de1f-148">Typically this is done to provide a convenience accessor, and not as the sole means to enable setting a property in XAML.</span></span> <span data-ttu-id="5de1f-149">但是，也可以将类型转换器用于要使用不提供无参数构造函数或特性化类型转换器的现有 CLR 类型的特性。</span><span class="sxs-lookup"><span data-stu-id="5de1f-149">However, it is also possible to use type converters for attributes where you want to use existing CLR types that do not supply either a parameterless constructor or an attributed type converter.</span></span> <span data-ttu-id="5de1f-150">API 中的示例 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 是采用类型的某些属性 <xref:System.Globalization.CultureInfo> 。</span><span class="sxs-lookup"><span data-stu-id="5de1f-150">Examples from the [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] API are certain properties that take the <xref:System.Globalization.CultureInfo> type.</span></span> <span data-ttu-id="5de1f-151">在这种情况下， [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 使用现有的 Microsoft .NET 框架 <xref:System.Globalization.CultureInfo> 类型可以更好地解决在早期版本的框架中使用的兼容性和迁移方案，但该 <xref:System.Globalization.CultureInfo> 类型不支持作为 XAML 属性值直接使用所需的构造函数或类型级别类型转换。</span><span class="sxs-lookup"><span data-stu-id="5de1f-151">In this case, [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] used the existing Microsoft .NET Framework <xref:System.Globalization.CultureInfo> type to better address compatibility and migration scenarios that were used in earlier versions of frameworks, but the <xref:System.Globalization.CultureInfo> type did not support the necessary constructors or type-level type conversion to be usable as a XAML property value directly.</span></span>  
  
 <span data-ttu-id="5de1f-152">每当公开具有 XAML 用法的属性时，特别是对于控件作者，应特别考虑使用依赖属性支持此属性。</span><span class="sxs-lookup"><span data-stu-id="5de1f-152">Whenever you expose a property that has a XAML usage, particularly if you are a control author, you should strongly consider backing that property with a dependency property.</span></span> <span data-ttu-id="5de1f-153">如果你使用 XAML 处理器的现有实现，则这一点尤其重要 [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] ，因为你可以使用后备来提高性能 <xref:System.Windows.DependencyProperty> 。</span><span class="sxs-lookup"><span data-stu-id="5de1f-153">This is particularly true if you use the existing [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] implementation of the XAML processor, because you can improve performance by using <xref:System.Windows.DependencyProperty> backing.</span></span> <span data-ttu-id="5de1f-154">依赖属性将对用户针对 XAML 可访问属性所需的属性公开属性系统功能。</span><span class="sxs-lookup"><span data-stu-id="5de1f-154">A dependency property will expose property system features for your property that users will come to expect for a XAML accessible property.</span></span> <span data-ttu-id="5de1f-155">这包括动画、数据绑定和样式支持等功能。</span><span class="sxs-lookup"><span data-stu-id="5de1f-155">This includes features such as animation, data binding, and style support.</span></span> <span data-ttu-id="5de1f-156">有关详细信息，请参阅[自定义依赖属性](custom-dependency-properties.md)和 [XAML 加载和依赖属性](xaml-loading-and-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="5de1f-156">For more information, see [Custom Dependency Properties](custom-dependency-properties.md) and [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>  
  
### <a name="writing-and-attributing-a-type-converter"></a><span data-ttu-id="5de1f-157">编写和特性化类型转换器</span><span class="sxs-lookup"><span data-stu-id="5de1f-157">Writing and Attributing a Type Converter</span></span>  
 <span data-ttu-id="5de1f-158">偶尔需要编写自定义 <xref:System.ComponentModel.TypeConverter> 派生类，以便为属性类型提供类型转换。</span><span class="sxs-lookup"><span data-stu-id="5de1f-158">You occasionally will need to write a custom <xref:System.ComponentModel.TypeConverter> derived class to provide type conversion for your property type.</span></span> <span data-ttu-id="5de1f-159">有关如何从派生并创建可支持 XAML 用法的类型转换器以及如何应用的说明， <xref:System.ComponentModel.TypeConverterAttribute> 请参阅 [TYPECONVERTERS 和 XAML](typeconverters-and-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="5de1f-159">For instructions on how to derive from and create a type converter that can support XAML usages, and how to apply the <xref:System.ComponentModel.TypeConverterAttribute>, see [TypeConverters and XAML](typeconverters-and-xaml.md).</span></span>  
  
<a name="Requirements_for_Events_of_a_Custom_Class_as_XAML"></a>
## <a name="requirements-for-xaml-event-handler-attribute-syntax-on-events-of-a-custom-class"></a><span data-ttu-id="5de1f-160">自定义类事件上 XAML 事件处理程序特性语法的要求</span><span class="sxs-lookup"><span data-stu-id="5de1f-160">Requirements for XAML Event Handler Attribute Syntax on Events of a Custom Class</span></span>  
 <span data-ttu-id="5de1f-161">若要用作 CLR 事件，事件必须作为支持无参数构造函数的类上的公共事件公开，或在可在派生类上访问事件的抽象类上公开。</span><span class="sxs-lookup"><span data-stu-id="5de1f-161">To be usable as a CLR event, the event must be exposed as a public event on a class that supports a parameterless constructor, or on an abstract class where the event can be accessed on derived classes.</span></span> <span data-ttu-id="5de1f-162">为了方便地用作路由事件，CLR 事件应该实现显式 `add` 和 `remove` 方法，这些方法可为 CLR 事件签名添加和删除处理程序，并将这些处理程序转发给 <xref:System.Windows.UIElement.AddHandler%2A> 和 <xref:System.Windows.UIElement.RemoveHandler%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="5de1f-162">In order to be used conveniently as a routed event, your CLR event should implement explicit `add` and `remove` methods, which add and remove handlers for the CLR event signature and forward those handlers to the <xref:System.Windows.UIElement.AddHandler%2A> and <xref:System.Windows.UIElement.RemoveHandler%2A> methods.</span></span> <span data-ttu-id="5de1f-163">这些方法添加或删除事件所附加到的实例上的路由事件处理程序存储的处理程序。</span><span class="sxs-lookup"><span data-stu-id="5de1f-163">These methods add or remove the handlers to the routed event handler store on the instance that the event is attached to.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="5de1f-164">可以使用为路由事件直接注册处理程序 <xref:System.Windows.UIElement.AddHandler%2A> ，并特意不定义公开路由事件的 CLR 事件。</span><span class="sxs-lookup"><span data-stu-id="5de1f-164">It is possible to register handlers directly for routed events using <xref:System.Windows.UIElement.AddHandler%2A>, and to deliberately not define a CLR event that exposes the routed event.</span></span> <span data-ttu-id="5de1f-165">通常不建议采用此操作，因为事件不会启用 XAML 特性语法用于附加处理程序，并且生成类提供的类型功能的 XAML 视图透明度较低。</span><span class="sxs-lookup"><span data-stu-id="5de1f-165">This is not generally recommended because the event will not enable XAML attribute syntax for attaching handlers, and your resulting class will offer a less transparent XAML view of that type's capabilities.</span></span>  
  
<a name="Collection_Properties"></a>
## <a name="writing-collection-properties"></a><span data-ttu-id="5de1f-166">编写集合属性</span><span class="sxs-lookup"><span data-stu-id="5de1f-166">Writing Collection Properties</span></span>  
 <span data-ttu-id="5de1f-167">采用集合类型的属性所具有的 XAML 语法使你可指定添加到集合的对象。</span><span class="sxs-lookup"><span data-stu-id="5de1f-167">Properties that take a collection type have a XAML syntax that enables you to specify objects that are added to the collection.</span></span> <span data-ttu-id="5de1f-168">此语法具有两个重要功能。</span><span class="sxs-lookup"><span data-stu-id="5de1f-168">This syntax has two notable features.</span></span>  
  
- <span data-ttu-id="5de1f-169">无需在对象元素语法中指定作为集合对象的对象。</span><span class="sxs-lookup"><span data-stu-id="5de1f-169">The object that is the collection object does not need to be specified in object element syntax.</span></span> <span data-ttu-id="5de1f-170">无论何时在采用集合类型的 XAML 中指定属性，该集合类型的状态总是隐式。</span><span class="sxs-lookup"><span data-stu-id="5de1f-170">The presence of that collection type is implicit whenever you specify a property in XAML that takes a collection type.</span></span>  
  
- <span data-ttu-id="5de1f-171">标记中集合属性的子元素经处理后变成集合的成员。</span><span class="sxs-lookup"><span data-stu-id="5de1f-171">Child elements of the collection property in markup are processed to become members of the collection.</span></span> <span data-ttu-id="5de1f-172">对集合成员的代码访问通常通过列表/字典方法（例如 `Add`）或通过索引器执行。</span><span class="sxs-lookup"><span data-stu-id="5de1f-172">Ordinarily, the code access to the members of a collection is performed through list/dictionary methods such as `Add`, or through an indexer.</span></span> <span data-ttu-id="5de1f-173">但是，XAML 语法不支持方法和索引器（例外：XAML 2009 可支持这些方法，但使用 XAML 2009 会限制可能的 WPF 用法；请参阅 [XAML 2009 语言功能](/dotnet/desktop-wpf/xaml-services/xaml-2009-language-features)）。</span><span class="sxs-lookup"><span data-stu-id="5de1f-173">But XAML syntax does not support methods or indexers (exception: XAML 2009 can support methods, but using XAML 2009 restricts the possible WPF usages; see [XAML 2009 Language Features](/dotnet/desktop-wpf/xaml-services/xaml-2009-language-features)).</span></span> <span data-ttu-id="5de1f-174">对生成元素树而言，集合显然是非常常见的要求，并且你需要某种方法来填充声明 XAML 中的这些集合。</span><span class="sxs-lookup"><span data-stu-id="5de1f-174">Collections are obviously a very common requirement for building a tree of elements, and you need some way to populate these collections in declarative XAML.</span></span> <span data-ttu-id="5de1f-175">因此，通过将集合属性的子元素添加到作为集合属性类型值的集合中来对其进行处理。</span><span class="sxs-lookup"><span data-stu-id="5de1f-175">Therefore, child elements of a collection property are processed by adding them to the collection that is the collection property type value.</span></span>  
  
 <span data-ttu-id="5de1f-176">.NET Framework XAML 服务实现和 WPF XAML 处理器将以下定义用于组成集合属性的项。</span><span class="sxs-lookup"><span data-stu-id="5de1f-176">The .NET Framework XAML Services implementation and thus the WPF XAML processor uses the following definition for what constitutes a collection property.</span></span> <span data-ttu-id="5de1f-177">属性的属性类型必须实现以下项之一：</span><span class="sxs-lookup"><span data-stu-id="5de1f-177">The property type of the property must implement one of the following:</span></span>  
  
- <span data-ttu-id="5de1f-178">实现 <xref:System.Collections.IList>。</span><span class="sxs-lookup"><span data-stu-id="5de1f-178">Implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="5de1f-179">实现 <xref:System.Collections.IDictionary> 或泛型等效 (<xref:System.Collections.Generic.IDictionary%602>) 。</span><span class="sxs-lookup"><span data-stu-id="5de1f-179">Implements <xref:System.Collections.IDictionary> or the generic equivalent (<xref:System.Collections.Generic.IDictionary%602>).</span></span>  
  
- <span data-ttu-id="5de1f-180">派生自 <xref:System.Array> (有关 XAML 中数组的详细信息，请参阅 [X:Array 标记扩展](/dotnet/desktop-wpf/xaml-services/xarray-markup-extension)。 ) </span><span class="sxs-lookup"><span data-stu-id="5de1f-180">Derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](/dotnet/desktop-wpf/xaml-services/xarray-markup-extension).)</span></span>  
  
- <span data-ttu-id="5de1f-181">实现 <xref:System.Windows.Markup.IAddChild> () 定义的接口 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="5de1f-181">Implements <xref:System.Windows.Markup.IAddChild> (an interface defined by [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)]).</span></span>  
  
 <span data-ttu-id="5de1f-182">CLR 中这些类型每个都具有 `Add` 方法，创建对象图时，XAML 处理器使用该方法将项添加到基础集合。</span><span class="sxs-lookup"><span data-stu-id="5de1f-182">Each of these types in CLR has an `Add` method, which is used by the XAML processor to add items to the underlying collection when creating the object graph.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="5de1f-183">`List` `Dictionary` <xref:System.Collections.Generic.IList%601> <xref:System.Collections.Generic.IDictionary%602> XAML 处理器不支持对泛型和接口 (和) 进行集合检测 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 。</span><span class="sxs-lookup"><span data-stu-id="5de1f-183">The generic `List` and `Dictionary` interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection by the [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] XAML processor.</span></span> <span data-ttu-id="5de1f-184">但是，可以将 <xref:System.Collections.Generic.List%601> 类用作基类，因为它 <xref:System.Collections.IList> 直接实现或 <xref:System.Collections.Generic.Dictionary%602> 作为基类，因为它 <xref:System.Collections.IDictionary> 直接实现。</span><span class="sxs-lookup"><span data-stu-id="5de1f-184">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="5de1f-185">声明采用集合的属性时，请注意类型的新实例中如何实例化此属性值。</span><span class="sxs-lookup"><span data-stu-id="5de1f-185">When you declare a property that takes a collection, be cautious about how that property value is initialized in new instances of the type.</span></span> <span data-ttu-id="5de1f-186">如果不将此属性实现为依赖属性，则使属性使用调用此集合类型构造函数的支持字段已可满足使用需求。</span><span class="sxs-lookup"><span data-stu-id="5de1f-186">If you are not implementing the property as a dependency property, then having the property use a backing field that calls the collection type constructor is adequate.</span></span> <span data-ttu-id="5de1f-187">如果属性为依赖属性，则可能需要将集合属性初始化为默认类型构造函数的一部分。</span><span class="sxs-lookup"><span data-stu-id="5de1f-187">If your property is a dependency property, then you may need to initialize the collection property as part of the default type constructor.</span></span> <span data-ttu-id="5de1f-188">这是因为依赖属性从元数据获取其默认值，而通常不希望集合属性的初始值为静态共享集合。</span><span class="sxs-lookup"><span data-stu-id="5de1f-188">This is because a dependency property takes its default value from metadata, and you typically do not want the initial value of a collection property to be a static, shared collection.</span></span> <span data-ttu-id="5de1f-189">每个包含类型实例应具有一个集合实例。</span><span class="sxs-lookup"><span data-stu-id="5de1f-189">There should be a collection instance per each containing type instance.</span></span> <span data-ttu-id="5de1f-190">有关详细信息，请参阅[自定义依赖属性](custom-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="5de1f-190">For more information, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="5de1f-191">可为集合属性实现自定义集合类型。</span><span class="sxs-lookup"><span data-stu-id="5de1f-191">You can implement a custom collection type for your collection property.</span></span> <span data-ttu-id="5de1f-192">由于隐式集合属性处理，自定义集合类型不需要提供无参数的构造函数即可在 XAML 中隐式使用。</span><span class="sxs-lookup"><span data-stu-id="5de1f-192">Because of implicit collection property treatment, the custom collection type does not need to provide a parameterless constructor in order to be used in XAML implicitly.</span></span> <span data-ttu-id="5de1f-193">但是，您可以选择为集合类型提供无参数的构造函数。</span><span class="sxs-lookup"><span data-stu-id="5de1f-193">However, you can optionally provide a parameterless constructor for the collection type.</span></span> <span data-ttu-id="5de1f-194">此做法是有用的。</span><span class="sxs-lookup"><span data-stu-id="5de1f-194">This can be a worthwhile practice.</span></span> <span data-ttu-id="5de1f-195">除非提供无参数的构造函数，否则不能将集合显式声明为对象元素。</span><span class="sxs-lookup"><span data-stu-id="5de1f-195">Unless you do provide a parameterless constructor, you cannot explicitly declare the collection as an object element.</span></span> <span data-ttu-id="5de1f-196">一些标记作者可能希望看到作为标记样式的显式集合。</span><span class="sxs-lookup"><span data-stu-id="5de1f-196">Some markup authors might prefer to see the explicit collection as a matter of markup style.</span></span> <span data-ttu-id="5de1f-197">此外，在创建将集合类型用作属性值的新对象时，无参数构造函数可以简化初始化要求。</span><span class="sxs-lookup"><span data-stu-id="5de1f-197">Also, a parameterless constructor can simplify the initialization requirements when you create new objects that use your collection type as a property value.</span></span>  
  
<a name="XAMLCONtent"></a>
## <a name="declaring-xaml-content-properties"></a><span data-ttu-id="5de1f-198">声明 XAML 内容属性</span><span class="sxs-lookup"><span data-stu-id="5de1f-198">Declaring XAML Content Properties</span></span>  
 <span data-ttu-id="5de1f-199">XAML 语言定义 [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] 内容属性的概念。</span><span class="sxs-lookup"><span data-stu-id="5de1f-199">The XAML language defines the concept of a [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] content property.</span></span> <span data-ttu-id="5de1f-200">对象语法中可用的每个类仅可具有一个 XAML 内容属性。</span><span class="sxs-lookup"><span data-stu-id="5de1f-200">Each class that is usable in object syntax can have exactly one XAML content property.</span></span> <span data-ttu-id="5de1f-201">若要将属性声明为类的 XAML 内容属性，请将 <xref:System.Windows.Markup.ContentPropertyAttribute> 作为类定义的一部分。</span><span class="sxs-lookup"><span data-stu-id="5de1f-201">To declare a property to be the XAML content property for your class, apply the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of the class definition.</span></span> <span data-ttu-id="5de1f-202">将预期 XAML 内容属性的名称指定为 <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> 属性中的。</span><span class="sxs-lookup"><span data-stu-id="5de1f-202">Specify the name of the intended XAML content property as the <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> in the attribute.</span></span> <span data-ttu-id="5de1f-203">属性按名称指定为字符串，而不是作为反射构造（如）指定 <xref:System.Reflection.PropertyInfo> 。</span><span class="sxs-lookup"><span data-stu-id="5de1f-203">The property is specified as a string by name, not as a reflection construct such as <xref:System.Reflection.PropertyInfo>.</span></span>  
  
 <span data-ttu-id="5de1f-204">可将集合属性指定为 XAML 内容属性。</span><span class="sxs-lookup"><span data-stu-id="5de1f-204">You can specify a collection property to be the XAML content property.</span></span> <span data-ttu-id="5de1f-205">这产生一种属性的用法，通过此用法，对象元素可具有一个或多个子元素，不干扰集合对象元素或属性元素标记。</span><span class="sxs-lookup"><span data-stu-id="5de1f-205">This results in a usage for that property whereby the object element can have one or more child elements, without any intervening collection object elements or property element tags.</span></span> <span data-ttu-id="5de1f-206">这些元素被视为 XAML 内容属性的值，并添加到支持集合实例中。</span><span class="sxs-lookup"><span data-stu-id="5de1f-206">These elements are then treated as the value for the XAML content property and added to the backing collection instance.</span></span>  
  
 <span data-ttu-id="5de1f-207">一些现有 XAML 内容属性使用 `Object` 的属性类型。</span><span class="sxs-lookup"><span data-stu-id="5de1f-207">Some existing XAML content properties use the property type of `Object`.</span></span> <span data-ttu-id="5de1f-208">这将启用 XAML 内容属性，该属性可以采用基元值（如）， <xref:System.String> 也可以采用单个引用对象值。</span><span class="sxs-lookup"><span data-stu-id="5de1f-208">This enables a XAML content property that can take primitive values such as a <xref:System.String> as well as taking a single reference object value.</span></span> <span data-ttu-id="5de1f-209">如果按照此模型，类型负责类型确定以及处理可能的类型。</span><span class="sxs-lookup"><span data-stu-id="5de1f-209">If you follow this model, your type is responsible for type determination as well as the handling of possible types.</span></span> <span data-ttu-id="5de1f-210">内容类型的典型原因 <xref:System.Object> 是为了支持将对象内容添加为字符串 (的简单方法，该方法可接收默认的演示处理) ，或者添加对象内容（用于指定非默认的演示文稿或其他数据）的高级方法。</span><span class="sxs-lookup"><span data-stu-id="5de1f-210">The typical reason for an <xref:System.Object> content type is to support both a simple means of adding object content as a string (which receives a default presentation treatment), or an advanced means of adding object content that specifies a non-default presentation or additional data.</span></span>  
  
<a name="Serializing"></a>
## <a name="serializing-xaml"></a><span data-ttu-id="5de1f-211">序列化 XAML</span><span class="sxs-lookup"><span data-stu-id="5de1f-211">Serializing XAML</span></span>  
 <span data-ttu-id="5de1f-212">某些情况下（例如对于控件作者），可能还需要确保任何可在 XAML 中实例化的对象演示文稿也可被序列化到等效的 XAML 标记。</span><span class="sxs-lookup"><span data-stu-id="5de1f-212">For certain scenarios, such as if you are a control author, you may also want to assure that any object representation that can be instantiated in XAML can also be serialized back to equivalent XAML markup.</span></span> <span data-ttu-id="5de1f-213">本主题中未介绍序列化要求。</span><span class="sxs-lookup"><span data-stu-id="5de1f-213">Serialization requirements are not described in this topic.</span></span> <span data-ttu-id="5de1f-214">请参阅[控件创作概述](../controls/control-authoring-overview.md)和[元素树和序列化](element-tree-and-serialization.md)。</span><span class="sxs-lookup"><span data-stu-id="5de1f-214">See [Control Authoring Overview](../controls/control-authoring-overview.md) and [Element Tree and Serialization](element-tree-and-serialization.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5de1f-215">请参阅</span><span class="sxs-lookup"><span data-stu-id="5de1f-215">See also</span></span>

- [<span data-ttu-id="5de1f-216">XAML 概述 (WPF)</span><span class="sxs-lookup"><span data-stu-id="5de1f-216">XAML Overview (WPF)</span></span>](/dotnet/desktop-wpf/fundamentals/xaml)
- [<span data-ttu-id="5de1f-217">自定义依赖项属性</span><span class="sxs-lookup"><span data-stu-id="5de1f-217">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="5de1f-218">控件创作概述</span><span class="sxs-lookup"><span data-stu-id="5de1f-218">Control Authoring Overview</span></span>](../controls/control-authoring-overview.md)
- [<span data-ttu-id="5de1f-219">基元素概述</span><span class="sxs-lookup"><span data-stu-id="5de1f-219">Base Elements Overview</span></span>](base-elements-overview.md)
- [<span data-ttu-id="5de1f-220">XAML 加载和依赖项属性</span><span class="sxs-lookup"><span data-stu-id="5de1f-220">XAML Loading and Dependency Properties</span></span>](xaml-loading-and-dependency-properties.md)
