---
title: TypeConverters 和 XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], TypeConverter class
ms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b
ms.openlocfilehash: caf218cc5eb2854ad51efbd321a8c42b8de0bb16
ms.sourcegitcommit: bf5dd80f4d7b202afa90e90d1148402c5474d826
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/30/2021
ms.locfileid: "96974009"
---
# <a name="typeconverters-and-xaml"></a><span data-ttu-id="51ffe-102">TypeConverters 和 XAML</span><span class="sxs-lookup"><span data-stu-id="51ffe-102">TypeConverters and XAML</span></span>
<span data-ttu-id="51ffe-103">本主题介绍将从字符串进行的类型转换作为常规 XAML 语言功能的用途。</span><span class="sxs-lookup"><span data-stu-id="51ffe-103">This topic introduces the purpose of type conversion from string as a general XAML language feature.</span></span> <span data-ttu-id="51ffe-104">在 .NET Framework 中， <xref:System.ComponentModel.TypeConverter> 类将特定用途作为托管自定义类的实现的一部分提供，可用作 XAML 特性用法中的属性值。</span><span class="sxs-lookup"><span data-stu-id="51ffe-104">In the .NET Framework, the <xref:System.ComponentModel.TypeConverter> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage.</span></span> <span data-ttu-id="51ffe-105">如果你编写自定义类，并且希望类的实例可以用作 XAML 可设置属性值，则你可能需要将应用 <xref:System.ComponentModel.TypeConverterAttribute> 到你的类，编写自定义 <xref:System.ComponentModel.TypeConverter> 类，或同时使用这两者。</span><span class="sxs-lookup"><span data-stu-id="51ffe-105">If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <xref:System.ComponentModel.TypeConverterAttribute> to your class, write a custom <xref:System.ComponentModel.TypeConverter> class, or both.</span></span>  

## <a name="type-conversion-concepts"></a><span data-ttu-id="51ffe-106">类型转换概念</span><span class="sxs-lookup"><span data-stu-id="51ffe-106">Type Conversion Concepts</span></span>  
  
### <a name="xaml-and-string-values"></a><span data-ttu-id="51ffe-107">XAML 和字符串值</span><span class="sxs-lookup"><span data-stu-id="51ffe-107">XAML and String Values</span></span>  
 <span data-ttu-id="51ffe-108">在 XAML 文件中设置特性值时，该值的初始类型是纯文本形式的字符串。</span><span class="sxs-lookup"><span data-stu-id="51ffe-108">When you set an attribute value in a XAML file, the initial type of that value is a string in pure text.</span></span> <span data-ttu-id="51ffe-109">甚至其他基元（如） <xref:System.Double> 最初是文本字符串到 XAML 处理器。</span><span class="sxs-lookup"><span data-stu-id="51ffe-109">Even other primitives such as <xref:System.Double> are initially text strings to a XAML processor.</span></span>  
  
 <span data-ttu-id="51ffe-110">XAML 处理器需要两条信息来处理特性值。</span><span class="sxs-lookup"><span data-stu-id="51ffe-110">A XAML processor needs two pieces of information in order to process an attribute value.</span></span> <span data-ttu-id="51ffe-111">第一条信息是所设置的属性的值类型。</span><span class="sxs-lookup"><span data-stu-id="51ffe-111">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="51ffe-112">定义特性值以及在 XAML 中进行处理的任何字符串都必须最终转换或解析为该类型的值。</span><span class="sxs-lookup"><span data-stu-id="51ffe-112">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="51ffe-113">如果值是 XAML 分析器可理解的基元（如数值），则会尝试直接转换字符串。</span><span class="sxs-lookup"><span data-stu-id="51ffe-113">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="51ffe-114">如果值是枚举，则字符串用于检查是否存在与该枚举中的命名常量匹配的名称。</span><span class="sxs-lookup"><span data-stu-id="51ffe-114">If the value is an enumeration, the string is used to check for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="51ffe-115">如果值既不是分析器可理解的基元，也不是枚举，则所讨论的类型必须能够基于转换后的字符串提供类型的实例或值。</span><span class="sxs-lookup"><span data-stu-id="51ffe-115">If the value is neither a parser-understood primitive nor an enumeration, then the type in question must be able to provide an instance of the type, or a value, based on a converted string.</span></span> <span data-ttu-id="51ffe-116">可通过指示类型转换器类达到此目的。</span><span class="sxs-lookup"><span data-stu-id="51ffe-116">This is done by indicating a type converter class.</span></span> <span data-ttu-id="51ffe-117">类型转换器实际上是提供其他类的值的帮助器类，可用于的 XAML 方案和 .NET 代码中的代码调用。</span><span class="sxs-lookup"><span data-stu-id="51ffe-117">The type converter is effectively a helper class for providing values of another class, both for the XAML scenario and also potentially for code calls in .NET code.</span></span>  
  
### <a name="using-existing-type-conversion-behavior-in-xaml"></a><span data-ttu-id="51ffe-118">在 XAML 中使用现有的类型转换行为</span><span class="sxs-lookup"><span data-stu-id="51ffe-118">Using Existing Type Conversion Behavior in XAML</span></span>  
 <span data-ttu-id="51ffe-119">你可能已经在基础应用程序 XAML 中使用了类型转换行为，只是你还不知道，具体取决于你对基础 XAML 概念的熟悉程度。</span><span class="sxs-lookup"><span data-stu-id="51ffe-119">Depending on your familiarity with the underlying XAML concepts, you may already be using type conversion behavior in basic application XAML without realizing it.</span></span> <span data-ttu-id="51ffe-120">例如，WPF 定义了数百个采用类型值的属性 <xref:System.Windows.Point> 。</span><span class="sxs-lookup"><span data-stu-id="51ffe-120">For instance, WPF defines literally hundreds of properties that take a value of type <xref:System.Windows.Point>.</span></span> <span data-ttu-id="51ffe-121"><xref:System.Windows.Point>是描述二维坐标空间中的坐标的值，它实际上只具有两个重要属性： <xref:System.Windows.Point.X%2A> 和 <xref:System.Windows.Point.Y%2A> 。</span><span class="sxs-lookup"><span data-stu-id="51ffe-121">A <xref:System.Windows.Point> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A>.</span></span> <span data-ttu-id="51ffe-122">当您在 XAML 中指定一个点时，可以将其指定为带有分隔符的字符串 (通常是在提供的和值之间使用逗号) <xref:System.Windows.Point.X%2A> <xref:System.Windows.Point.Y%2A> 。</span><span class="sxs-lookup"><span data-stu-id="51ffe-122">When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values you provide.</span></span> <span data-ttu-id="51ffe-123">例如：`<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`。</span><span class="sxs-lookup"><span data-stu-id="51ffe-123">For example: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.</span></span>  
  
 <span data-ttu-id="51ffe-124">甚至此简单类型的 <xref:System.Windows.Point> 和它在 XAML 中的简单用法都涉及类型转换器。</span><span class="sxs-lookup"><span data-stu-id="51ffe-124">Even this simple type of <xref:System.Windows.Point> and its simple usage in XAML involve a type converter.</span></span> <span data-ttu-id="51ffe-125">在这种情况下，为类 <xref:System.Windows.PointConverter> 。</span><span class="sxs-lookup"><span data-stu-id="51ffe-125">In this case that is the class <xref:System.Windows.PointConverter>.</span></span>  
  
 <span data-ttu-id="51ffe-126"><xref:System.Windows.Point>在类级别定义的类型转换器可简化所采用的所有属性的标记用法 <xref:System.Windows.Point> 。</span><span class="sxs-lookup"><span data-stu-id="51ffe-126">The type converter for <xref:System.Windows.Point> defined at the class level streamlines the markup usages of all properties that take <xref:System.Windows.Point>.</span></span> <span data-ttu-id="51ffe-127">如果没有类型转换器，那么对于前面显示的同一示例，将需要更冗长的标记，如下所示：</span><span class="sxs-lookup"><span data-stu-id="51ffe-127">Without a type converter here, you would need the following much more verbose markup for the same example shown previously:</span></span>  

```xaml
<LinearGradientBrush>
  <LinearGradientBrush.StartPoint>
    <Point X="0" Y="0"/>
  </LinearGradientBrush.StartPoint>
  <LinearGradientBrush.EndPoint>
    <Point X="1" Y="1"/>
  </LinearGradientBrush.EndPoint>
</LinearGradientBrush>
 ```
  
 <span data-ttu-id="51ffe-128">使用类型转换字符串或使用更复杂的等效语法通常是编码风格的选择。</span><span class="sxs-lookup"><span data-stu-id="51ffe-128">Whether to use the type conversion string or a more verbose equivalent syntax is generally a coding style choice.</span></span> <span data-ttu-id="51ffe-129">XAML 工具工作流也可能会影响值的设置方式。</span><span class="sxs-lookup"><span data-stu-id="51ffe-129">Your XAML tooling workflow might also influence how values are set.</span></span> <span data-ttu-id="51ffe-130">某些 XAML 工具可能会生成最复杂的标记窗体，以便更容易往返于设计器视图或其自身的序列化机制。</span><span class="sxs-lookup"><span data-stu-id="51ffe-130">Some XAML tools tend to emit the most verbose form of the markup because it is easier to round-trip to designer views or its own serialization mechanism.</span></span>  
  
 <span data-ttu-id="51ffe-131">通常可以在 WPF 和 .NET Framework 类型上发现现有类型转换器，方法是检查类 (或属性) 是否存在已应用的 <xref:System.ComponentModel.TypeConverterAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="51ffe-131">Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="51ffe-132">此属性将对支持类型转换器转换类型的值的类进行命名，用于 XAML 或其他可能的用途。</span><span class="sxs-lookup"><span data-stu-id="51ffe-132">This attribute will name the class that is the supporting type converter for values of that type, for XAML purposes as well as potentially other purposes.</span></span>  
  
### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="51ffe-133">类型转换器和标记扩展</span><span class="sxs-lookup"><span data-stu-id="51ffe-133">Type Converters and Markup Extensions</span></span>  
 <span data-ttu-id="51ffe-134">标记扩展和类型转换器根据 XAML 处理器行为及其应用场景来实现正交角色。</span><span class="sxs-lookup"><span data-stu-id="51ffe-134">Markup extensions and type converters fill orthogonal roles in terms of XAML processor behavior and the scenarios that they are applied to.</span></span> <span data-ttu-id="51ffe-135">尽管上下文可用于标记扩展用途，但通常不会在标记扩展实现中检查属性的类型转换行为（其中标记扩展提供了一个值）。</span><span class="sxs-lookup"><span data-stu-id="51ffe-135">Although context is available for markup extension usages, type conversion behavior of properties where a markup extension provides a value is generally is not checked in the markup extension implementations.</span></span> <span data-ttu-id="51ffe-136">换言之，即使标记扩展返回一个文本字符串作为其 `ProvideValue` 输出，该字符串上应用于特定属性或属性值类型的类型转换行为也不会被调用。通常，标记扩展的目的是在不调用任何类型转换器的情况下，处理字符串和返回对象。</span><span class="sxs-lookup"><span data-stu-id="51ffe-136">In other words, even if a markup extension returns a text string as its `ProvideValue` output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved.</span></span>  
  
 <span data-ttu-id="51ffe-137">需要标记扩展而不是类型转换器的一种常见情况是使对已存在的对象进行引用。</span><span class="sxs-lookup"><span data-stu-id="51ffe-137">One common situation where a markup extension is necessary rather than a type converter is to make a reference to an object that already exists.</span></span> <span data-ttu-id="51ffe-138">无状态类型转换器最多只能生成新实例，这可能并不理想。</span><span class="sxs-lookup"><span data-stu-id="51ffe-138">At best, a stateless type converter could only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="51ffe-139">若要深入了解标记扩展，请参阅[标记扩展和 WPF XAML](markup-extensions-and-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="51ffe-139">For more information on markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span>  
  
### <a name="native-type-converters"></a><span data-ttu-id="51ffe-140">本机类型转换器</span><span class="sxs-lookup"><span data-stu-id="51ffe-140">Native Type Converters</span></span>  
 <span data-ttu-id="51ffe-141">在 XAML 分析器的 WPF 和 .NET XAML 实现中，某些特定类型具有本机类型转换处理，但在传统上可能不会将这些类型视为基元。</span><span class="sxs-lookup"><span data-stu-id="51ffe-141">In the WPF and .NET Framework implementation of the XAML parser, there are certain types that have native type conversion handling, yet are not types that might conventionally be thought of as primitives.</span></span> <span data-ttu-id="51ffe-142">这种类型的一个示例是 <xref:System.DateTime>。</span><span class="sxs-lookup"><span data-stu-id="51ffe-142">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="51ffe-143">这种情况的原因取决于 .NET Framework 体系结构的工作原理：类型 <xref:System.DateTime> 在 mscorlib 中定义，这是 .net 中最基本的库。</span><span class="sxs-lookup"><span data-stu-id="51ffe-143">The reason for this is based on how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="51ffe-144"><xref:System.DateTime> 不允许使用来自其他程序集的特性进行特性化，而该程序集引入了依赖项 (<xref:System.ComponentModel.TypeConverterAttribute> 来自系统) ，因此不能支持通过特性化进行的正常类型转换器发现机制。</span><span class="sxs-lookup"><span data-stu-id="51ffe-144"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System) so the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="51ffe-145">相反，XAML 分析器具有需要此类本机处理的类型的列表，它可通过与真正基元的处理方式类似的方式来处理这些类型。</span><span class="sxs-lookup"><span data-stu-id="51ffe-145">Instead, the XAML parser has a list of types that need such native processing and processes these similarly to how the true primitives are processed.</span></span> <span data-ttu-id="51ffe-146">在这种情况下 (<xref:System.DateTime> 涉及调用 <xref:System.DateTime.Parse%2A> 。 ) </span><span class="sxs-lookup"><span data-stu-id="51ffe-146">(In the case of <xref:System.DateTime> this involves a call to <xref:System.DateTime.Parse%2A>.)</span></span>  
  
<a name="Implementing_a_Type_Converter"></a>
## <a name="implementing-a-type-converter"></a><span data-ttu-id="51ffe-147">实现类型转换器</span><span class="sxs-lookup"><span data-stu-id="51ffe-147">Implementing a Type Converter</span></span>  
  
### <a name="typeconverter"></a><span data-ttu-id="51ffe-148">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="51ffe-148">TypeConverter</span></span>  
 <span data-ttu-id="51ffe-149">在 <xref:System.Windows.Point> 前面给出的示例中， <xref:System.Windows.PointConverter> 提到了类。</span><span class="sxs-lookup"><span data-stu-id="51ffe-149">In the <xref:System.Windows.Point> example given previously, the class <xref:System.Windows.PointConverter> was mentioned.</span></span> <span data-ttu-id="51ffe-150">对于 XAML 的 .NET 实现，用于 XAML 用途的所有类型转换器都是从基类派生的类 <xref:System.ComponentModel.TypeConverter> 。</span><span class="sxs-lookup"><span data-stu-id="51ffe-150">For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="51ffe-151"><xref:System.ComponentModel.TypeConverter>类存在于 XAML 存在之前的 .NET Framework 版本中，它的原始用法之一是在可视化设计器中为属性对话框提供字符串转换。</span><span class="sxs-lookup"><span data-stu-id="51ffe-151">The <xref:System.ComponentModel.TypeConverter> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers.</span></span> <span data-ttu-id="51ffe-152">对于 XAML，的角色 <xref:System.ComponentModel.TypeConverter> 会扩展为包括：作为字符串的基类和允许分析字符串属性值的字符串转换，并可能将特定对象属性的运行时值处理回字符串，以便作为属性进行序列化。</span><span class="sxs-lookup"><span data-stu-id="51ffe-152">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute.</span></span>  
  
 <span data-ttu-id="51ffe-153"><xref:System.ComponentModel.TypeConverter> 定义了四个成员，它们与用于在 XAML 处理目的中转换为字符串和从字符串进行转换的成员相关：</span><span class="sxs-lookup"><span data-stu-id="51ffe-153"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to and from strings for XAML processing purposes:</span></span>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  
  
 <span data-ttu-id="51ffe-154">其中，最重要的方法是 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 。</span><span class="sxs-lookup"><span data-stu-id="51ffe-154">Of these, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span></span> <span data-ttu-id="51ffe-155">此方法将输入字符串转换为所需的对象类型。</span><span class="sxs-lookup"><span data-stu-id="51ffe-155">This method converts the input string to the required object type.</span></span> <span data-ttu-id="51ffe-156">严格地说， <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 可以实现此方法以将范围更广泛的类型转换为转换器的预期目标类型，从而为超出 xaml （如支持运行时转换）的目的提供支持，但对于 xaml 而言，这只是可以处理 <xref:System.String> 重要输入的代码路径。</span><span class="sxs-lookup"><span data-stu-id="51ffe-156">Strictly speaking, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <xref:System.String> input that matters.</span></span>  
  
 <span data-ttu-id="51ffe-157">下一个最重要的方法是 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 。</span><span class="sxs-lookup"><span data-stu-id="51ffe-157">The next most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="51ffe-158">如果将应用程序转换为标记表示形式 (例如，如果它作为文件) 保存到 XAML， <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 则负责生成标记表示形式。</span><span class="sxs-lookup"><span data-stu-id="51ffe-158">If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is responsible for producing a markup representation.</span></span> <span data-ttu-id="51ffe-159">在这种情况下，对 XAML 重要的代码路径是传递 `destinationType` 的 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="51ffe-159">In this case, the code path that matters for XAML is when you pass a `destinationType` of <xref:System.String> .</span></span>  
  
 <span data-ttu-id="51ffe-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 和 <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> 是在服务查询 <xref:System.ComponentModel.TypeConverter> 实现的功能时使用的支持方法。</span><span class="sxs-lookup"><span data-stu-id="51ffe-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="51ffe-161">必须实现这些方法以便为转换器的等效转换方法支持的特定于类型的情况返回 `true` 。</span><span class="sxs-lookup"><span data-stu-id="51ffe-161">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="51ffe-162">对于 XAML 用途，这通常意味着 <xref:System.String> 类型。</span><span class="sxs-lookup"><span data-stu-id="51ffe-162">For XAML purposes, this generally means the <xref:System.String> type.</span></span>  
  
### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="51ffe-163">XAML 的区域性信息和类型转换器</span><span class="sxs-lookup"><span data-stu-id="51ffe-163">Culture Information and Type Converters for XAML</span></span>  

 <span data-ttu-id="51ffe-164">每个 <xref:System.ComponentModel.TypeConverter> 实现都可以对构成转换的有效字符串的内容进行自己的解释，还可以使用或忽略作为参数传递的类型说明。</span><span class="sxs-lookup"><span data-stu-id="51ffe-164">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters.</span></span> <span data-ttu-id="51ffe-165">对于区域性和 XAML 类型转换，有一个重要的注意事项。</span><span class="sxs-lookup"><span data-stu-id="51ffe-165">There is an important consideration with regard to culture and XAML type conversion.</span></span> <span data-ttu-id="51ffe-166">XAML 完全支持使用可本地化的字符串作为特性值。</span><span class="sxs-lookup"><span data-stu-id="51ffe-166">Using localizable strings as attribute values is entirely supported by XAML.</span></span> <span data-ttu-id="51ffe-167">但不支持将该可本地化字符串用作具有特定区域性要求的类型转换器输入，因为 XAML 特性值的类型转换器包含一个必要的固定语言分析行为，该行为使用 `en-US` 区域性。</span><span class="sxs-lookup"><span data-stu-id="51ffe-167">But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using `en-US` culture.</span></span> <span data-ttu-id="51ffe-168">有关此限制的设计原因的详细信息，请参阅 XAML 语言规范 ([ \[ ms-chap \] ](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf)。</span><span class="sxs-lookup"><span data-stu-id="51ffe-168">For more information on the design reasons for this restriction, you should consult the XAML language specification ([\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf).</span></span>  
  
 <span data-ttu-id="51ffe-169">区域性可能会产生问题的示例之一是，某些区域性使用逗号作为数字的小数点分隔符。</span><span class="sxs-lookup"><span data-stu-id="51ffe-169">As an example where culture can be an issue, some cultures use a comma as their decimal point delimiter for numbers.</span></span> <span data-ttu-id="51ffe-170">这将与许多 WPF XAML 类型转换器所具有的使用逗号作为分隔符的行为发生冲突（根据常用的 X,Y 形式等过去的先例，或逗号分隔的列表）。</span><span class="sxs-lookup"><span data-stu-id="51ffe-170">This will collide with the behavior that many of the WPF XAML type converters have, which is to use a comma as a delimiter (based on historical precedents such as the common X,Y form, or comma delimited lists).</span></span> <span data-ttu-id="51ffe-171">即使在周围的 XAML 中传递区域性（将 `Language` 或 `xml:lang` 设置为 `sl-SI` 区域性，以此方式使用逗号作为小数点的区域性的一个示例）也不能解决此问题。</span><span class="sxs-lookup"><span data-stu-id="51ffe-171">Even passing a culture in the surrounding XAML (setting `Language` or `xml:lang` to the `sl-SI` culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue.</span></span>  
  
### <a name="implementing-convertfrom"></a><span data-ttu-id="51ffe-172">实现 ConvertFrom</span><span class="sxs-lookup"><span data-stu-id="51ffe-172">Implementing ConvertFrom</span></span>  
 <span data-ttu-id="51ffe-173">若要能够用作支持 XAML 的 <xref:System.ComponentModel.TypeConverter> 实现，该转换器的 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 方法必须接受字符串作为 `value` 参数。</span><span class="sxs-lookup"><span data-stu-id="51ffe-173">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="51ffe-174">如果字符串采用有效格式，并且可以由实现进行转换 <xref:System.ComponentModel.TypeConverter> ，则返回的对象必须支持强制转换为属性所需的类型。</span><span class="sxs-lookup"><span data-stu-id="51ffe-174">If the string was in valid format, and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, then the returned object must support a cast to the type expected by the property.</span></span> <span data-ttu-id="51ffe-175">否则， <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 实现必须返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="51ffe-175">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>  
  
 <span data-ttu-id="51ffe-176">每个 <xref:System.ComponentModel.TypeConverter> 实现都可以对构成转换的有效字符串的内容进行自己的解释，还可以使用或忽略作为参数传递的类型说明或区域性上下文。</span><span class="sxs-lookup"><span data-stu-id="51ffe-176">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters.</span></span> <span data-ttu-id="51ffe-177">但是，WPF XAML 处理可能不会在所有情况下都将值传递给类型说明上下文，还可能不会基于 `xml:lang` 传递区域性。</span><span class="sxs-lookup"><span data-stu-id="51ffe-177">However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on `xml:lang`.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="51ffe-178">请勿使用大括号字符（尤其是 {）作为字符串格式的可能元素。</span><span class="sxs-lookup"><span data-stu-id="51ffe-178">Do not use the curly brace characters, particularly {, as a possible element of your string format.</span></span> <span data-ttu-id="51ffe-179">这些字符保留作为标记扩展序列的入口和出口。</span><span class="sxs-lookup"><span data-stu-id="51ffe-179">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>  
  
### <a name="implementing-convertto"></a><span data-ttu-id="51ffe-180">实现 ConvertTo</span><span class="sxs-lookup"><span data-stu-id="51ffe-180">Implementing ConvertTo</span></span>  
 <span data-ttu-id="51ffe-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 可能用于序列化支持。</span><span class="sxs-lookup"><span data-stu-id="51ffe-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="51ffe-182">通过 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 为自定义类型及其类型转换器实现的序列化支持不是绝对要求。</span><span class="sxs-lookup"><span data-stu-id="51ffe-182">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="51ffe-183">但是，如果要实现控件，或使用序列化作为类的功能或设计的一部分，则应实现 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="51ffe-183">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>  
  
 <span data-ttu-id="51ffe-184">若要用作 <xref:System.ComponentModel.TypeConverter> 支持 XAML 的实现，该转换器的 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 方法必须接受 (类型的实例，或接受作为参数) 支持的值 `value` 。</span><span class="sxs-lookup"><span data-stu-id="51ffe-184">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) being supported as the `value` parameter.</span></span> <span data-ttu-id="51ffe-185">如果 `destinationType` 参数为类型 <xref:System.String> ，则返回的对象必须能够强制转换为 <xref:System.String> 。</span><span class="sxs-lookup"><span data-stu-id="51ffe-185">When the `destinationType` parameter is the type <xref:System.String>, then the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="51ffe-186">返回字符串必须表示 `value` 的序列化值。</span><span class="sxs-lookup"><span data-stu-id="51ffe-186">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="51ffe-187">理想情况下，如果您选择的序列化格式应能够生成相同的值，则它应能够生成相同的值 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> ，而不会显著丢失信息。</span><span class="sxs-lookup"><span data-stu-id="51ffe-187">Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>  
  
 <span data-ttu-id="51ffe-188">如果值无法进行序列化，或转换器不支持序列化，则 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 实现必须返回 `null` ，并且在此情况下允许引发异常。</span><span class="sxs-lookup"><span data-stu-id="51ffe-188">If the value cannot be serialized, or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null`, and is permitted to throw an exception in this case.</span></span> <span data-ttu-id="51ffe-189">但是，如果确实引发了异常，则应报告无法使用该转换作为实现的一部分， <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 以便 <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 支持首先检查以避免异常的最佳做法。</span><span class="sxs-lookup"><span data-stu-id="51ffe-189">But if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>  
  
 <span data-ttu-id="51ffe-190">如果 `destinationType` 参数不属于类型 <xref:System.String> ，则可以选择自己的转换器处理。</span><span class="sxs-lookup"><span data-stu-id="51ffe-190">If `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="51ffe-191">通常，会恢复为基实现处理，在方法中将 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 引发特定异常。</span><span class="sxs-lookup"><span data-stu-id="51ffe-191">Typically, you would revert to base implementation handling, which in the basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>  
  
### <a name="implementing-canconvertto"></a><span data-ttu-id="51ffe-192">实现 CanConvertTo</span><span class="sxs-lookup"><span data-stu-id="51ffe-192">Implementing CanConvertTo</span></span>  
 <span data-ttu-id="51ffe-193">对于 <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 类型的 `true` ， `destinationType` 实现应返回 <xref:System.String>，否则遵从基实现。</span><span class="sxs-lookup"><span data-stu-id="51ffe-193">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
### <a name="implementing-canconvertfrom"></a><span data-ttu-id="51ffe-194">实现 CanConvertFrom</span><span class="sxs-lookup"><span data-stu-id="51ffe-194">Implementing CanConvertFrom</span></span>  
 <span data-ttu-id="51ffe-195">对于 <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> 类型的 `true` ， `sourceType` 实现应返回 <xref:System.String>，否则遵从基实现。</span><span class="sxs-lookup"><span data-stu-id="51ffe-195">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
<a name="Applying_the_TypeConverterAttribute"></a>
## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="51ffe-196">应用 TypeConverterAttribute</span><span class="sxs-lookup"><span data-stu-id="51ffe-196">Applying the TypeConverterAttribute</span></span>  
 <span data-ttu-id="51ffe-197">为了使自定义类型转换器被 XAML 处理器用作自定义类的操作类型转换器，必须将应用于 <xref:System.ComponentModel.TypeConverterAttribute> 类定义。</span><span class="sxs-lookup"><span data-stu-id="51ffe-197">In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="51ffe-198">通过特性指定的 <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> 必须是自定义类型转换器的类型名。</span><span class="sxs-lookup"><span data-stu-id="51ffe-198">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="51ffe-199">应用此特性后，当 XAML 处理器处理属性类型使用自定义类类型的值时，它可以输入字符串并返回对象实例。</span><span class="sxs-lookup"><span data-stu-id="51ffe-199">With this attribute applied, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>  
  
 <span data-ttu-id="51ffe-200">还可以基于每个属性提供类型转换器。</span><span class="sxs-lookup"><span data-stu-id="51ffe-200">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="51ffe-201">不是将应用于 <xref:System.ComponentModel.TypeConverterAttribute> 类定义，而是将其应用于主定义 (属性定义，而不是 `get` / `set`) 中的实现。</span><span class="sxs-lookup"><span data-stu-id="51ffe-201">Instead of applying a <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="51ffe-202">属性的类型必须与自定义类型转换器处理的类型匹配。</span><span class="sxs-lookup"><span data-stu-id="51ffe-202">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="51ffe-203">应用此特性时，当 XAML 处理器处理该属性的值时，它可以处理输入字符串并返回对象实例。</span><span class="sxs-lookup"><span data-stu-id="51ffe-203">With this attribute applied, when a XAML processor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="51ffe-204">如果选择使用 Microsoft .NET 框架中的属性类型或不能控制类定义并且无法应用此类定义的其他库，则每属性类型转换器方法特别有用 <xref:System.ComponentModel.TypeConverterAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="51ffe-204">The per-property type converter technique is particularly useful if you choose to use a property type from Microsoft .NET Framework or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="51ffe-205">请参阅</span><span class="sxs-lookup"><span data-stu-id="51ffe-205">See also</span></span>

- <xref:System.ComponentModel.TypeConverter>
- [<span data-ttu-id="51ffe-206">XAML 概述 (WPF)</span><span class="sxs-lookup"><span data-stu-id="51ffe-206">XAML Overview (WPF)</span></span>](/dotnet/desktop-wpf/fundamentals/xaml)
- [<span data-ttu-id="51ffe-207">标记扩展和 WPF XAML</span><span class="sxs-lookup"><span data-stu-id="51ffe-207">Markup Extensions and WPF XAML</span></span>](markup-extensions-and-wpf-xaml.md)
- [<span data-ttu-id="51ffe-208">XAML 语法详述</span><span class="sxs-lookup"><span data-stu-id="51ffe-208">XAML Syntax In Detail</span></span>](xaml-syntax-in-detail.md)
