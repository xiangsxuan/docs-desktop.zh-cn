---
title: 属性更改事件
ms.date: 03/30/2017
helpviewer_keywords:
- dependency properties [WPF], change events
- property value changes [WPF]
- change events [WPF], property
- events [WPF], change in property values
- creating property triggers [WPF]
- property change events [WPF], types of
- property change events [WPF]
- property triggers [WPF]
- identifying changed property events [WPF]
- property triggers [WPF], definition of
ms.assetid: 0a7989df-9674-4cc1-bc50-5d8ef5d9c055
ms.openlocfilehash: 9b3bfce4765d849e8c3260ac17397d34dac3f1c8
ms.sourcegitcommit: 069786bcadbf9cd931d7dc3d892262cd852d2ffb
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/19/2021
ms.locfileid: "104667117"
---
# <a name="property-change-events"></a><span data-ttu-id="492bd-102">属性更改事件</span><span class="sxs-lookup"><span data-stu-id="492bd-102">Property Change Events</span></span>
[!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] <span data-ttu-id="492bd-103">定义几个为响应属性值的更改而引发的事件。</span><span class="sxs-lookup"><span data-stu-id="492bd-103">defines several events that are raised in response to a change in the value of a property.</span></span> <span data-ttu-id="492bd-104">该属性通常是依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="492bd-104">Often the property is a dependency property.</span></span> <span data-ttu-id="492bd-105">事件本身有时是路由事件，有时是标准公共语言运行时 (CLR) 事件。</span><span class="sxs-lookup"><span data-stu-id="492bd-105">The event itself is sometimes a routed event and is sometimes a standard common language runtime (CLR) event.</span></span> <span data-ttu-id="492bd-106">事件的定义因具体情况而异，因为有些属性更改更适于通过元素树路由，而其他属性更改则通常只与属性发生更改的对象有关。</span><span class="sxs-lookup"><span data-stu-id="492bd-106">The definition of the event varies depending on the scenario, because some property changes are more appropriately routed through an element tree, whereas other property changes are generally only of concern to the object where the property changed.</span></span>  
  
## <a name="identifying-a-property-change-event"></a><span data-ttu-id="492bd-107">标识属性更改事件</span><span class="sxs-lookup"><span data-stu-id="492bd-107">Identifying a Property Change Event</span></span>  
 <span data-ttu-id="492bd-108">并非所有报告属性更改的事件都通过签名模式或命名模式显式地标识为属性更改事件。</span><span class="sxs-lookup"><span data-stu-id="492bd-108">Not all events that report a property change are explicitly identified as a property changed event, either by virtue of a signature pattern or a naming pattern.</span></span> <span data-ttu-id="492bd-109">通常，SDK 文档中的事件说明指示事件是否直接绑定到属性值更改，并在属性和事件之间提供交叉引用。</span><span class="sxs-lookup"><span data-stu-id="492bd-109">Generally, the description of the event in the SDK documentation indicates whether the event is directly tied to a property value change and provides cross-references between the property and event.</span></span>  
  
### <a name="routedpropertychanged-events"></a><span data-ttu-id="492bd-110">RoutedPropertyChanged 事件</span><span class="sxs-lookup"><span data-stu-id="492bd-110">RoutedPropertyChanged Events</span></span>  
 <span data-ttu-id="492bd-111">某些事件使用显式用于属性更改事件的事件数据类型和委托。</span><span class="sxs-lookup"><span data-stu-id="492bd-111">Certain events use an event data type and delegate that are explicitly used for property change events.</span></span> <span data-ttu-id="492bd-112">事件数据类型为 <xref:System.Windows.RoutedPropertyChangedEventArgs%601> ，委托为 <xref:System.Windows.RoutedPropertyChangedEventHandler%601> 。</span><span class="sxs-lookup"><span data-stu-id="492bd-112">The event data type is <xref:System.Windows.RoutedPropertyChangedEventArgs%601>, and the delegate is <xref:System.Windows.RoutedPropertyChangedEventHandler%601>.</span></span> <span data-ttu-id="492bd-113">事件数据和委托都具有用于在定义处理程序时指定更改属性实际类型的泛型类型参数。</span><span class="sxs-lookup"><span data-stu-id="492bd-113">The event data and delegate both have a generic type parameter that is used to specify the actual type of the changing property when you define the handler.</span></span> <span data-ttu-id="492bd-114">事件数据包含两个属性： <xref:System.Windows.RoutedPropertyChangedEventArgs%601.OldValue%2A> 和 <xref:System.Windows.RoutedPropertyChangedEventArgs%601.NewValue%2A> ，它们随后作为事件数据中的类型参数进行传递。</span><span class="sxs-lookup"><span data-stu-id="492bd-114">The event data contains two properties, <xref:System.Windows.RoutedPropertyChangedEventArgs%601.OldValue%2A> and <xref:System.Windows.RoutedPropertyChangedEventArgs%601.NewValue%2A>, which are both then passed as the type argument in the event data.</span></span>  
  
 <span data-ttu-id="492bd-115">名称中的“Routed”部分表示属性更改事件注册为路由事件。</span><span class="sxs-lookup"><span data-stu-id="492bd-115">The "Routed" part of the name indicates that the property changed event is registered as a routed event.</span></span> <span data-ttu-id="492bd-116">路由属性更改事件的好处是，如果子元素（控件的复合部分）上的属性更改了值，控件的顶层可以接收到属性更改事件。</span><span class="sxs-lookup"><span data-stu-id="492bd-116">The advantage of routing a property changed event is that the top level of a control can receive property changed events if properties on the child elements (the control's composite parts) change values.</span></span> <span data-ttu-id="492bd-117">例如，可以创建一个包含控件的控件， <xref:System.Windows.Controls.Primitives.RangeBase> 例如 <xref:System.Windows.Controls.Slider> 。</span><span class="sxs-lookup"><span data-stu-id="492bd-117">For instance, you might create a control that incorporates a <xref:System.Windows.Controls.Primitives.RangeBase> control such as a <xref:System.Windows.Controls.Slider>.</span></span> <span data-ttu-id="492bd-118">如果属性的值 <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> 在滑块部分发生更改，则您可能希望在父控件而不是在部件上处理此更改。</span><span class="sxs-lookup"><span data-stu-id="492bd-118">If the value of the <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> property changes on the slider part, you might want to handle that change on the parent control rather than on the part.</span></span>  
  
 <span data-ttu-id="492bd-119">因为有一个旧值和一个新值，所以很可能使用此事件处理程序作为属性值的验证程序。</span><span class="sxs-lookup"><span data-stu-id="492bd-119">Because you have an old value and a new value, it might be tempting to use this event handler as a validator for the property value.</span></span> <span data-ttu-id="492bd-120">但是，这不是大多数属性更改事件的设计意图。</span><span class="sxs-lookup"><span data-stu-id="492bd-120">However, that is not the design intention of most property changed events.</span></span> <span data-ttu-id="492bd-121">通常，提供这些值是为了能够在代码的其他逻辑领域处理这些值，但实际上，在事件处理程序内更改值并不明智，并且可能导致意外的递归，具体取决于处理程序的实现方式。</span><span class="sxs-lookup"><span data-stu-id="492bd-121">Generally, the values are provided so that you can act on those values in other logic areas of your code, but actually changing the values from within the event handler is not advisable, and may cause unintentional recursion depending on how your handler is implemented.</span></span>  
  
 <span data-ttu-id="492bd-122">如果您的属性是自定义依赖属性，或者您使用的是您在其中定义了实例化代码的派生类，则可以使用更好的机制来跟踪属性系统中内置的属性更改 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] ：属性系统回调 <xref:System.Windows.CoerceValueCallback> 和 <xref:System.Windows.PropertyChangedCallback> 。</span><span class="sxs-lookup"><span data-stu-id="492bd-122">If your property is a custom dependency property, or if you are working with a derived class where you have defined the instantiation code, there is a much better mechanism for tracking property changes that is built in to the [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] property system: the property system callbacks <xref:System.Windows.CoerceValueCallback> and <xref:System.Windows.PropertyChangedCallback>.</span></span> <span data-ttu-id="492bd-123">若要深入了解如何使用 [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] 属性系统进行验证和强制转换，请参阅[依赖属性回调和验证](dependency-property-callbacks-and-validation.md)和[自定义依赖属性](custom-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="492bd-123">For more details about how you can use the [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] property system for validation and coercion, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md) and [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
### <a name="dependencypropertychanged-events"></a><span data-ttu-id="492bd-124">DependencyPropertyChanged 事件</span><span class="sxs-lookup"><span data-stu-id="492bd-124">DependencyPropertyChanged Events</span></span>  
 <span data-ttu-id="492bd-125">作为属性更改事件方案的一部分的另一对类型是 <xref:System.Windows.DependencyPropertyChangedEventArgs> 和 <xref:System.Windows.DependencyPropertyChangedEventHandler> 。</span><span class="sxs-lookup"><span data-stu-id="492bd-125">Another pair of types that are part of a property changed event scenario is <xref:System.Windows.DependencyPropertyChangedEventArgs> and <xref:System.Windows.DependencyPropertyChangedEventHandler>.</span></span> <span data-ttu-id="492bd-126">不会路由这些属性更改的事件;它们是标准 CLR 事件。</span><span class="sxs-lookup"><span data-stu-id="492bd-126">Events for these property changes are not routed; they are standard CLR events.</span></span> <span data-ttu-id="492bd-127"><xref:System.Windows.DependencyPropertyChangedEventArgs> 是异常的事件数据报告类型，因为它不是从派生的 <xref:System.EventArgs> <xref:System.Windows.DependencyPropertyChangedEventArgs> ，而是结构，而不是类。</span><span class="sxs-lookup"><span data-stu-id="492bd-127"><xref:System.Windows.DependencyPropertyChangedEventArgs> is an unusual event data reporting type because it does not derive from <xref:System.EventArgs>; <xref:System.Windows.DependencyPropertyChangedEventArgs> is a structure, not a class.</span></span>  
  
 <span data-ttu-id="492bd-128">使用 <xref:System.Windows.DependencyPropertyChangedEventArgs> 和的事件 <xref:System.Windows.DependencyPropertyChangedEventHandler> 比事件略有不同 `RoutedPropertyChanged` 。</span><span class="sxs-lookup"><span data-stu-id="492bd-128">Events that use <xref:System.Windows.DependencyPropertyChangedEventArgs> and <xref:System.Windows.DependencyPropertyChangedEventHandler> are slightly more common than `RoutedPropertyChanged` events.</span></span> <span data-ttu-id="492bd-129">使用这些类型的事件的一个示例是 <xref:System.Windows.UIElement.IsMouseCapturedChanged> 。</span><span class="sxs-lookup"><span data-stu-id="492bd-129">An example of an event that uses these types is <xref:System.Windows.UIElement.IsMouseCapturedChanged>.</span></span>  
  
 <span data-ttu-id="492bd-130">与类似 <xref:System.Windows.RoutedPropertyChangedEventArgs%601> ， <xref:System.Windows.DependencyPropertyChangedEventArgs> 还报告属性的新旧值。</span><span class="sxs-lookup"><span data-stu-id="492bd-130">Like <xref:System.Windows.RoutedPropertyChangedEventArgs%601>, <xref:System.Windows.DependencyPropertyChangedEventArgs> also reports an old and new value for the property.</span></span> <span data-ttu-id="492bd-131">此外，关于如何处理这些值的注意事项也同样适用；通常不建议为响应事件而尝试在发送方再次更改值。</span><span class="sxs-lookup"><span data-stu-id="492bd-131">Also, the same considerations about what you can do with the values apply; it is generally not recommended that you attempt to change the values again on the sender in response to the event.</span></span>  
  
## <a name="property-triggers"></a><span data-ttu-id="492bd-132">属性触发器</span><span class="sxs-lookup"><span data-stu-id="492bd-132">Property Triggers</span></span>  
 <span data-ttu-id="492bd-133">与属性更改事件密切相关的一个概念是属性触发器。</span><span class="sxs-lookup"><span data-stu-id="492bd-133">A closely related concept to a property changed event is a property trigger.</span></span> <span data-ttu-id="492bd-134">属性触发器是在样式或模板内创建的，通过它可以创建基于分配了属性触发器的属性的值的条件行为。</span><span class="sxs-lookup"><span data-stu-id="492bd-134">A property trigger is created within a style or template and enables you to create a conditional behavior based on the value of the property where the property trigger is assigned.</span></span>  
  
 <span data-ttu-id="492bd-135">属性触发器的属性必须是依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="492bd-135">The property for a property trigger must be a dependency property.</span></span> <span data-ttu-id="492bd-136">它可以是（且通常是）只读依赖项属性。</span><span class="sxs-lookup"><span data-stu-id="492bd-136">It can be (and frequently is) a read-only dependency property.</span></span> <span data-ttu-id="492bd-137">判断控件公开的依赖项属性是否至少部分设计为属性触发器的一个好方法是查看属性名称是否以“Is”开头。</span><span class="sxs-lookup"><span data-stu-id="492bd-137">A good indicator for when a dependency property exposed by a control is at least partially designed to be a property trigger is if the property name begins with "Is".</span></span> <span data-ttu-id="492bd-138">采用此命名规则的属性通常是只读的布尔依赖项属性，其属性的主要作用是报告可能与实时 UI 具有因果关系的控件状态，因此它是一个属性触发器候选。</span><span class="sxs-lookup"><span data-stu-id="492bd-138">Properties that have this naming are often a read-only Boolean dependency property where the primary scenario for the property is reporting control state that might have consequences to the real-time UI and is thus a property trigger candidate.</span></span>  
  
 <span data-ttu-id="492bd-139">其中一些属性还具有专用属性更改事件。</span><span class="sxs-lookup"><span data-stu-id="492bd-139">Some of these properties also have a dedicated property changed event.</span></span> <span data-ttu-id="492bd-140">例如，属性 <xref:System.Windows.UIElement.IsMouseCaptured%2A> 具有属性 changed 事件 <xref:System.Windows.UIElement.IsMouseCapturedChanged> 。</span><span class="sxs-lookup"><span data-stu-id="492bd-140">For instance, the property <xref:System.Windows.UIElement.IsMouseCaptured%2A> has a property changed event <xref:System.Windows.UIElement.IsMouseCapturedChanged>.</span></span> <span data-ttu-id="492bd-141">属性本身是只读的，它的值由输入系统调整，并且输入系统 <xref:System.Windows.UIElement.IsMouseCapturedChanged> 在每次实时更改时引发。</span><span class="sxs-lookup"><span data-stu-id="492bd-141">The property itself is read-only, with its value adjusted by the input system, and the input system raises <xref:System.Windows.UIElement.IsMouseCapturedChanged> on each real-time change.</span></span>  
  
 <span data-ttu-id="492bd-142">与真正的属性更改事件相比，使用属性触发器来处理属性更改具有一些限制。</span><span class="sxs-lookup"><span data-stu-id="492bd-142">Compared to a true property changed event, using a property trigger to act on a property change has some limitations.</span></span>  
  
 <span data-ttu-id="492bd-143">属性触发器通过完全匹配逻辑来工作。</span><span class="sxs-lookup"><span data-stu-id="492bd-143">Property triggers work through an exact match logic.</span></span> <span data-ttu-id="492bd-144">指定一个属性和一个值，该值指示触发器将作用于的特定值。例如： `<Setter Property="IsMouseCaptured" Value="true"> ... </Setter>` 。</span><span class="sxs-lookup"><span data-stu-id="492bd-144">You specify a property and a value that indicates the specific value for which the trigger will act. For instance: `<Setter Property="IsMouseCaptured" Value="true"> ... </Setter>`.</span></span> <span data-ttu-id="492bd-145">由于此限制，大多数属性触发器用法都将针对布尔属性或者采用专用枚举值的属性，其可能值范围是可管理的，足以为每种情况定义一个触发器。</span><span class="sxs-lookup"><span data-stu-id="492bd-145">Because of this limitation, the majority of property trigger usages will be for Boolean properties, or properties that take a dedicated enumeration value, where the possible value range is manageable enough to define a trigger for each case.</span></span> <span data-ttu-id="492bd-146">或者属性触发器可能仅仅用于特殊值，例如，当项计数达到零，却没有触发器来处理当属性值再次从零变为其他值（此处可能需要代码事件处理程序，或者当值不为零时再次从触发器状态切换回来的默认行为，而非针对所有情况的触发器）。</span><span class="sxs-lookup"><span data-stu-id="492bd-146">Or property triggers might exist only for special values, such as when an items count reaches zero, and there would be no trigger that accounts for the cases when the property value changes away from zero again (instead of triggers for all cases, you might need a code event handler here, or a default behavior that toggles back from the trigger state again when the value is nonzero).</span></span>  
  
 <span data-ttu-id="492bd-147">属性触发器语法与编程中的“if”语句类似。</span><span class="sxs-lookup"><span data-stu-id="492bd-147">The property trigger syntax is analogous to an "if" statement in programming.</span></span> <span data-ttu-id="492bd-148">如果触发器条件为 true，将“执行”属性触发器的“主体”。</span><span class="sxs-lookup"><span data-stu-id="492bd-148">If the trigger condition is true, then the "body" of the property trigger is "executed".</span></span> <span data-ttu-id="492bd-149">属性触发器的“主体”是标记，而不是代码。</span><span class="sxs-lookup"><span data-stu-id="492bd-149">The "body" of a property trigger is not code, it is markup.</span></span> <span data-ttu-id="492bd-150">此标记限制为使用一个或多个 <xref:System.Windows.Setter> 元素设置要应用样式或模板的对象的其他属性。</span><span class="sxs-lookup"><span data-stu-id="492bd-150">That markup is limited to using one or more <xref:System.Windows.Setter> elements to set other properties of the object where the style or template is being applied.</span></span>  
  
 <span data-ttu-id="492bd-151">若要偏移具有各种可能值的属性触发器的 "if" 条件，通常建议使用将该属性值设置为默认值 <xref:System.Windows.Setter> 。</span><span class="sxs-lookup"><span data-stu-id="492bd-151">To offset the "if" condition of a property trigger that has a wide variety of possible values, it is generally advisable to set that same property value to a default by using a <xref:System.Windows.Setter>.</span></span> <span data-ttu-id="492bd-152">这样一来， <xref:System.Windows.Trigger> 当触发器条件为 true 时，所包含的资源库将具有优先级，并且 <xref:System.Windows.Setter> <xref:System.Windows.Trigger> 当触发器条件为 false 时，不在中的将优先。</span><span class="sxs-lookup"><span data-stu-id="492bd-152">This way, the <xref:System.Windows.Trigger> contained setter will have precedence when the trigger condition is true, and the <xref:System.Windows.Setter> that is not within a <xref:System.Windows.Trigger> will have precedence whenever the trigger condition is false.</span></span>  
  
 <span data-ttu-id="492bd-153">属性触发器通常适合于一个或多个外观属性应基于同一元素的其他属性的状态而更改的情况。</span><span class="sxs-lookup"><span data-stu-id="492bd-153">Property triggers are generally appropriate for scenarios where one or more appearance properties should change, based on the state of another property on the same element.</span></span>  
  
 <span data-ttu-id="492bd-154">若要深入了解属性触发器，请参阅[样式设置和模板化](/dotnet/desktop-wpf/fundamentals/styles-templates-overview)。</span><span class="sxs-lookup"><span data-stu-id="492bd-154">To learn more about property triggers, see [Styling and Templating](/dotnet/desktop-wpf/fundamentals/styles-templates-overview).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="492bd-155">请参阅</span><span class="sxs-lookup"><span data-stu-id="492bd-155">See also</span></span>

- [<span data-ttu-id="492bd-156">路由事件概述</span><span class="sxs-lookup"><span data-stu-id="492bd-156">Routed Events Overview</span></span>](routed-events-overview.md)
- [<span data-ttu-id="492bd-157">依赖项属性概述</span><span class="sxs-lookup"><span data-stu-id="492bd-157">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
