---
title: 默认 XAML 架构上下文和 WPF XAML 架构上下文
ms.date: 03/30/2017
ms.assetid: 04e06a15-09b3-4210-9bdf-9a64c2eccb83
ms.openlocfilehash: 2e92372de61230a98a02282cc28fc3f479cd94eb
ms.sourcegitcommit: 9f6df084c53a3da0ea657ed0d708a72213683084
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/09/2020
ms.locfileid: "96974023"
---
# <a name="default-xaml-schema-context-and-wpf-xaml-schema-context"></a><span data-ttu-id="cadf1-102">默认 XAML 架构上下文和 WPF XAML 架构上下文</span><span class="sxs-lookup"><span data-stu-id="cadf1-102">Default XAML Schema Context and WPF XAML Schema Context</span></span>
<span data-ttu-id="cadf1-103">XAML 架构上下文是一种概念性实体，它限定了使用特定 XAML 词汇的 XAML 生产如何与对象写入行为交互，包括如何解析类型映射、如何加载程序集、如何解释某些读取器和编写器设置。</span><span class="sxs-lookup"><span data-stu-id="cadf1-103">A XAML schema context is a conceptual entity that qualifies how a XAML production that uses a particular XAML vocabulary interacts with the object writing behavior, including how type mapping resolves, how assemblies are loaded, how certain reader and writer settings are interpreted.</span></span> <span data-ttu-id="cadf1-104">本主题介绍 .NET XAML 服务的功能和关联的默认 XAML 架构上下文，该上下文基于 CLR 类型系统。</span><span class="sxs-lookup"><span data-stu-id="cadf1-104">This topic describes the features of .NET XAML Services and the associated default XAML schema context, which is based on the CLR type system.</span></span> <span data-ttu-id="cadf1-105">本主题还介绍用于 WPF 的 XAML 架构上下文。</span><span class="sxs-lookup"><span data-stu-id="cadf1-105">This topic also describes the XAML schema context that is used for WPF.</span></span>

## <a name="default-xaml-schema-context"></a><span data-ttu-id="cadf1-106">默认 XAML 架构上下文</span><span class="sxs-lookup"><span data-stu-id="cadf1-106">Default XAML Schema Context</span></span>

<span data-ttu-id="cadf1-107">.NET XAML 服务都实现并使用默认 XAML 架构上下文。</span><span class="sxs-lookup"><span data-stu-id="cadf1-107">.NET XAML Services both implements and uses a default XAML schema context.</span></span> <span data-ttu-id="cadf1-108">默认 XAML 架构上下文行为并非始终在类的 API 中完全可见 <xref:System.Xaml.XamlSchemaContext> 。</span><span class="sxs-lookup"><span data-stu-id="cadf1-108">The default XAML schema context behavior is not always fully visible in the API of the <xref:System.Xaml.XamlSchemaContext> class.</span></span> <span data-ttu-id="cadf1-109">但是，在许多情况下，默认 XAML 架构上下文影响的行为可通过 XAML 类型系统的公共 API （如或的成员） <xref:System.Xaml.XamlMember> <xref:System.Xaml.XamlType> 或使用默认 xaml 架构上下文的 xaml 读取器和 xaml 编写器中公开的 api 来观察。</span><span class="sxs-lookup"><span data-stu-id="cadf1-109">However, in many cases the behavior that the default XAML schema context influences is observable through common API of the XAML type system, such as members of <xref:System.Xaml.XamlMember> or <xref:System.Xaml.XamlType>, or through APIs exposed on XAML readers and XAML writers that are using the default XAML schema context.</span></span>

<span data-ttu-id="cadf1-110">可以 <xref:System.Xaml.XamlSchemaContext> 通过调用构造函数来创建封装默认行为的 <xref:System.Xaml.XamlSchemaContext> 。</span><span class="sxs-lookup"><span data-stu-id="cadf1-110">You can create a <xref:System.Xaml.XamlSchemaContext> that encapsulates the default behavior by calling the <xref:System.Xaml.XamlSchemaContext> constructor.</span></span> <span data-ttu-id="cadf1-111">这会显式创建默认的 XAML 架构上下文。</span><span class="sxs-lookup"><span data-stu-id="cadf1-111">This explicitly creates the default XAML schema context.</span></span> <span data-ttu-id="cadf1-112">如果使用未显式采用输入参数的 Api 初始化 XAML 读取器或 XAML 编写器，则将隐式创建相同的默认 XAML 架构上下文 <xref:System.Xaml.XamlSchemaContext> 。</span><span class="sxs-lookup"><span data-stu-id="cadf1-112">The same default XAML schema context is created implicitly, if you initialize a XAML reader or XAML writer using APIs that do not explicitly take a <xref:System.Xaml.XamlSchemaContext> input parameter.</span></span>

<span data-ttu-id="cadf1-113">默认 XAML 架构上下文依赖 CLR 反射来实现其类型映射行为。</span><span class="sxs-lookup"><span data-stu-id="cadf1-113">The default XAML schema context relies on CLR reflection for its type mapping behavior.</span></span> <span data-ttu-id="cadf1-114">这包括检查定义 CLR 以及 <xref:System.Type> 相关的 <xref:System.Reflection.PropertyInfo> 或 <xref:System.Reflection.MethodInfo> 。</span><span class="sxs-lookup"><span data-stu-id="cadf1-114">This includes examining the defining CLR <xref:System.Type>, and related <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.MethodInfo>.</span></span> <span data-ttu-id="cadf1-115">此外，还使用类型或成员上的 CLR 特性来填写使用 CLR 支持类型的 XAML 类型或 XAML 成员信息的详细信息。</span><span class="sxs-lookup"><span data-stu-id="cadf1-115">Also, CLR attribution on types or members is used in order to fill in the specifics for XAML type or XAML member information that uses the CLR backing type.</span></span> <span data-ttu-id="cadf1-116">默认 XAML 架构上下文不需要类型系统扩展技术（如 `Invoker` 模式），因为 CLR 类型系统中提供了必需的信息。</span><span class="sxs-lookup"><span data-stu-id="cadf1-116">The default XAML schema context does not require type system extension techniques such as the `Invoker` pattern, because the necessary information is available from the CLR type system.</span></span>

<span data-ttu-id="cadf1-117">对于程序集加载逻辑，默认的 XAML 架构上下文主要依赖于 XAML 命名空间映射中提供的任何程序集值。</span><span class="sxs-lookup"><span data-stu-id="cadf1-117">For assembly loading logic, the default XAML schema context relies mainly on any assembly values provided in XAML namespace mappings.</span></span> <span data-ttu-id="cadf1-118">此外，还 <xref:System.Xaml.XamlReaderSettings.LocalAssembly%2A> 可以提示要加载的程序集，对于诸如加载内部类型之类的方案。</span><span class="sxs-lookup"><span data-stu-id="cadf1-118">Also, <xref:System.Xaml.XamlReaderSettings.LocalAssembly%2A> can hint an assembly to load, for scenarios such as loading internal types.</span></span>

## <a name="wpf-xaml-schema-context"></a><span data-ttu-id="cadf1-119">WPF XAML 架构上下文</span><span class="sxs-lookup"><span data-stu-id="cadf1-119">WPF XAML Schema Context</span></span>

<span data-ttu-id="cadf1-120">本主题介绍了 WPF XAML 架构上下文，因为 WPF 实现提供了可通过实现非默认 XAML 架构上下文而引入的功能类型的有趣说明。</span><span class="sxs-lookup"><span data-stu-id="cadf1-120">The WPF XAML schema context is described in this topic because the WPF implementation provides an interesting illustration of the kinds of features that can be introduced by implementing a non-default XAML schema context.</span></span> <span data-ttu-id="cadf1-121">此外，在对 WPF XAML 进行寻址的 WPF 文档中，XAML 架构上下文概念并不太广泛地讨论;如果与默认 XAML 架构上下文的工作原理进行了集成，则 XAML 架构上下文启用的行为可能会完全理解。</span><span class="sxs-lookup"><span data-stu-id="cadf1-121">Also, the XAML schema context concept is not discussed very much in the WPF documentation that addresses WPF XAML; the behavior that the XAML schema context enables might only be fully understandable if integrated with a discussion of how the default XAML schema context works.</span></span> <span data-ttu-id="cadf1-122">WPF XAML 架构上下文实现以下行为。</span><span class="sxs-lookup"><span data-stu-id="cadf1-122">The WPF XAML schema context implements the following behavior.</span></span>

<span data-ttu-id="cadf1-123">**查找替代：** WPF 具有一些 XAML 内容模型，其中有一些 XAML 内容属性在未进行属性化的情况下运行 <xref:System.Windows.Markup.ContentPropertyAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="cadf1-123">**Lookup overrides:** WPF has a few content models for XAML where there are XAML content properties that function without being <xref:System.Windows.Markup.ContentPropertyAttribute> attributed.</span></span> <span data-ttu-id="cadf1-124"><xref:System.Xaml.XamlType.LookupContentProperty%2A> WPF 的替代实现了此行为。</span><span class="sxs-lookup"><span data-stu-id="cadf1-124"><xref:System.Xaml.XamlType.LookupContentProperty%2A> overrides for WPF implement this behavior.</span></span>

<span data-ttu-id="cadf1-125">**延迟 WPF 表达式：** WPF 具有几个延迟某个值的表达式类，直至运行时上下文可用。</span><span class="sxs-lookup"><span data-stu-id="cadf1-125">**Deferral for WPF expressions:** WPF features several expression classes that defer a value until a runtime context is available.</span></span> <span data-ttu-id="cadf1-126">此外，模板扩展是依赖于延迟技术的运行时行为。</span><span class="sxs-lookup"><span data-stu-id="cadf1-126">Also, template expansion is a runtime behavior that relies on deferral techniques.</span></span>

<span data-ttu-id="cadf1-127">**类型系统查找优化：** WPF 具有广泛的 XAML 词汇和对象模型，包括继承到数百个 WPF 定义的类的基类成员定义。</span><span class="sxs-lookup"><span data-stu-id="cadf1-127">**Type system lookup optimizations:** WPF has an extensive XAML vocabulary and object model, including base class member definitions that inherit to literally hundreds of WPF-defined classes.</span></span> <span data-ttu-id="cadf1-128">而且，WPF 本身分散在多个程序集中。</span><span class="sxs-lookup"><span data-stu-id="cadf1-128">Also, WPF itself is spread across several assemblies.</span></span> <span data-ttu-id="cadf1-129">WPF 使用查找表和其他方法优化其类型查找。</span><span class="sxs-lookup"><span data-stu-id="cadf1-129">WPF optimizes its type lookup using lookup tables and other techniques.</span></span> <span data-ttu-id="cadf1-130">这为默认 XAML 架构上下文及其基于 CLR 的类型查找提供了性能改进。</span><span class="sxs-lookup"><span data-stu-id="cadf1-130">This provides performance improvements over the default XAML schema context and its CLR-based type lookup.</span></span> <span data-ttu-id="cadf1-131">如果查找表中不存在类型，则行为将使用类似于默认 XAML 架构上下文的 XAML 架构上下文技术。</span><span class="sxs-lookup"><span data-stu-id="cadf1-131">In cases where types do not exist in a lookup table, the behavior uses XAML schema context techniques that are similar to the default XAML schema context.</span></span>

<span data-ttu-id="cadf1-132">**XamlType 和 XamlMember 扩展：** WPF 利用依赖属性扩展属性概念，并扩展带有路由事件的事件概念。</span><span class="sxs-lookup"><span data-stu-id="cadf1-132">**XamlType and XamlMember extension:** WPF extends property concepts with dependency properties, and event concepts with routed events.</span></span> <span data-ttu-id="cadf1-133">为了更好地为这些概念提供 XAML 处理操作的可见性，WPF 扩展 <xref:System.Xaml.XamlType> <xref:System.Xaml.XamlMember> 了和，并添加了报表依赖属性和路由事件特征的内部属性。</span><span class="sxs-lookup"><span data-stu-id="cadf1-133">To give these concepts greater visibility for XAML processing operations, WPF extends <xref:System.Xaml.XamlType> and <xref:System.Xaml.XamlMember>, and adds internal properties that report dependency property and routed event characteristics.</span></span>

### <a name="accessing-the-wpf-xaml-schema-context"></a><span data-ttu-id="cadf1-134">访问 WPF XAML 架构上下文</span><span class="sxs-lookup"><span data-stu-id="cadf1-134">Accessing the WPF XAML Schema Context</span></span>

<span data-ttu-id="cadf1-135">如果你使用的是基于 WPF 或的 XAML 方法 <xref:System.Windows.Markup.XamlReader?displayProperty=nameWithType> <xref:System.Windows.Markup.XamlWriter?displayProperty=nameWithType> ，则这些 xaml 读取器和 xaml 编写器实现已在使用 wpf XAML 架构上下文。</span><span class="sxs-lookup"><span data-stu-id="cadf1-135">If you are using XAML techniques that are based on the WPF <xref:System.Windows.Markup.XamlReader?displayProperty=nameWithType> or <xref:System.Windows.Markup.XamlWriter?displayProperty=nameWithType>, the WPF XAML schema context is already in use on those XAML reader and XAML writer implementations.</span></span>

<span data-ttu-id="cadf1-136">如果使用的是未使用 WPF XAML 架构上下文初始化的其他 XAML 读取器或 XAML 编写器实现，则可以从获取工作的 WPF XAML 架构上下文 <xref:System.Windows.Markup.XamlReader.GetWpfSchemaContext%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="cadf1-136">If you are using other XAML reader or XAML writer implementations that do not initialize with the WPF XAML schema context, you may be able to get a working WPF XAML schema context from <xref:System.Windows.Markup.XamlReader.GetWpfSchemaContext%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="cadf1-137">然后，可以将此值用作使用的其他 API 的初始化 <xref:System.Xaml.XamlSchemaContext> 。</span><span class="sxs-lookup"><span data-stu-id="cadf1-137">You can then use this value as initialization for other API that use a <xref:System.Xaml.XamlSchemaContext>.</span></span> <span data-ttu-id="cadf1-138">例如，可以调用 <xref:System.Xaml.XamlXmlReader.%23ctor%2A> 初始化并传递 WPF XAML 架构上下文。</span><span class="sxs-lookup"><span data-stu-id="cadf1-138">For example, you could call <xref:System.Xaml.XamlXmlReader.%23ctor%2A> for initialization and pass the WPF XAML schema context.</span></span> <span data-ttu-id="cadf1-139">或者，您可以使用 XAML 类型系统操作的 WPF XAML 架构上下文。</span><span class="sxs-lookup"><span data-stu-id="cadf1-139">Or you could use the WPF XAML schema context for XAML type system operations.</span></span> <span data-ttu-id="cadf1-140">这可能包括 <xref:System.Xaml.XamlType> 、或调用的构造初始化 <xref:System.Xaml.XamlMember> <xref:System.Xaml.XamlSchemaContext.GetXamlType%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="cadf1-140">This might include construction initialization of a <xref:System.Xaml.XamlType> or <xref:System.Xaml.XamlMember>, or calling <xref:System.Xaml.XamlSchemaContext.GetXamlType%2A?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="cadf1-141">请注意，如果从纯 XAML 节点流角度访问 WPF XAML 的某些方面，某些 WPF 框架功能可能尚未操作。</span><span class="sxs-lookup"><span data-stu-id="cadf1-141">Note that if you access certain aspects of WPF XAML from a pure XAML node stream perspectives, some of the WPF framework capabilities may not have acted yet.</span></span> <span data-ttu-id="cadf1-142">例如，控件的 WPF 模板尚未应用。</span><span class="sxs-lookup"><span data-stu-id="cadf1-142">For example, WPF templates for controls are not yet applied.</span></span> <span data-ttu-id="cadf1-143">因此，如果您访问的属性在运行时可能使用完整的可视化树进行填充，则您可能只能看到引用模板的属性值。</span><span class="sxs-lookup"><span data-stu-id="cadf1-143">Thus if you access a property that at run time might be populated with a full visual tree, you might only see a property value that references a template.</span></span> <span data-ttu-id="cadf1-144">如果在非运行时情况下提供给 WPF 标记扩展提供的服务上下文可能也不准确，并且在尝试编写对象图时可能会导致异常。</span><span class="sxs-lookup"><span data-stu-id="cadf1-144">The service context provided for WPF markup extensions might also not be accurate if provided from a non-runtime situation, and can result in exceptions when attempting to write an object graph.</span></span>

## <a name="xaml-and-assembly-loading"></a><span data-ttu-id="cadf1-145">XAML 和程序集加载</span><span class="sxs-lookup"><span data-stu-id="cadf1-145">XAML and Assembly Loading</span></span>

<span data-ttu-id="cadf1-146">XAML 和 .NET XAML 服务的程序集加载与 CLR 定义的概念集成 <xref:System.AppDomain> 。</span><span class="sxs-lookup"><span data-stu-id="cadf1-146">Assembly loading for XAML and .NET XAML Services integrates with the CLR-defined concept of <xref:System.AppDomain>.</span></span> <span data-ttu-id="cadf1-147">XAML 架构上下文解释如何在运行时或设计时加载程序集或查找类型，具体取决于 <xref:System.AppDomain> 和其他因素。</span><span class="sxs-lookup"><span data-stu-id="cadf1-147">A XAML schema context interprets how to either load assemblies or find types at run time or design time, based on the use of <xref:System.AppDomain> and other factors.</span></span> <span data-ttu-id="cadf1-148">此逻辑略有不同，具体取决于 xaml 是否为 XAML 读取器的稀疏 XAML、是否通过 XAML 编译为 DLL `XamlBuildTask` ，或由 WPF 的生成的 BAML `PresentationBuildTask` 。</span><span class="sxs-lookup"><span data-stu-id="cadf1-148">The logic is slightly different depending on whether the XAML is loose XAML for a XAML reader, is XAML compiled into a DLL by `XamlBuildTask`, or is BAML generated by WPF's `PresentationBuildTask`.</span></span>

<span data-ttu-id="cadf1-149">WPF 的 XAML 架构上下文与 WPF 应用程序模型集成，后者又使用 <xref:System.AppDomain> wpf 实现的详细信息和其他因素。</span><span class="sxs-lookup"><span data-stu-id="cadf1-149">The XAML schema context for WPF integrates with the WPF application model, which in turn uses <xref:System.AppDomain> as well as other factors that are WPF implementation details.</span></span>

#### <a name="xaml-reader-input-loose-xaml"></a><span data-ttu-id="cadf1-150">XAML 读取器输入 (松散 XAML) </span><span class="sxs-lookup"><span data-stu-id="cadf1-150">XAML reader input (loose XAML)</span></span>

01. <span data-ttu-id="cadf1-151">XAML 架构上下文循环访问 <xref:System.AppDomain> 应用程序的，并从最近加载的程序集开始，查找与名称的所有方面相匹配的已加载程序集。</span><span class="sxs-lookup"><span data-stu-id="cadf1-151">The XAML schema context iterates through the <xref:System.AppDomain> of the application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</span></span> <span data-ttu-id="cadf1-152">如果找到匹配项，则使用该程序集进行解析。</span><span class="sxs-lookup"><span data-stu-id="cadf1-152">If a match is found, that assembly is used for resolution.</span></span>

02. <span data-ttu-id="cadf1-153">否则，将使用基于 CLR API 的以下技术之一 <xref:System.Reflection.Assembly> 加载程序集：</span><span class="sxs-lookup"><span data-stu-id="cadf1-153">Otherwise, one of the following techniques based on CLR <xref:System.Reflection.Assembly> API are used to load an assembly:</span></span>

    - <span data-ttu-id="cadf1-154">如果在映射中限定名称，请 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> 对限定名称调用。</span><span class="sxs-lookup"><span data-stu-id="cadf1-154">If the name is qualified in the mapping, call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> on the qualified name.</span></span>

    - <span data-ttu-id="cadf1-155">如果前面的步骤失败，请使用短名称 (和公钥标记（如果) 存在）以调用 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="cadf1-155">If the previous step fails, use the short name (and public key token if present) to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>

    - <span data-ttu-id="cadf1-156">如果名称在映射中不合格，请调用 <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="cadf1-156">If the name is unqualified in the mapping, call <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>.</span></span>

#### <a name="xamlbuildtask"></a><span data-ttu-id="cadf1-157">XamlBuildTask</span><span class="sxs-lookup"><span data-stu-id="cadf1-157">XamlBuildTask</span></span>

<span data-ttu-id="cadf1-158">`XamlBuildTask` 用于 Windows Communication Foundation (WCF) 和 Windows Workflow Foundation。</span><span class="sxs-lookup"><span data-stu-id="cadf1-158">`XamlBuildTask` is used for Windows Communication Foundation (WCF) and Windows Workflow Foundation.</span></span>

<span data-ttu-id="cadf1-159">请注意，通过进行的程序集引用 `XamlBuildTask` 始终是完全限定的。</span><span class="sxs-lookup"><span data-stu-id="cadf1-159">Note that assembly references through `XamlBuildTask` are always fully qualified.</span></span>

1. <span data-ttu-id="cadf1-160">对 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> 限定名称调用。</span><span class="sxs-lookup"><span data-stu-id="cadf1-160">Call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> on the qualified name.</span></span>

2. <span data-ttu-id="cadf1-161">如果前面的步骤失败，请使用短名称 (和公钥标记（如果) 存在）以调用 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="cadf1-161">If the previous step fails, use the short name (and public key token if present) to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>

#### <a name="baml-presentationbuildtask"></a><span data-ttu-id="cadf1-162">BAML (PresentationBuildTask) </span><span class="sxs-lookup"><span data-stu-id="cadf1-162">BAML (PresentationBuildTask)</span></span>

<span data-ttu-id="cadf1-163">BAML 的程序集加载有两个方面：加载作为组件包含 BAML 的初始程序集，并为 BAML 生产所引用的任何类型加载支持类型的程序集。</span><span class="sxs-lookup"><span data-stu-id="cadf1-163">There are two aspects to assembly-loading for BAML: loading the initial assembly that contains the BAML as a component, and loading the type-backing assemblies for any types referenced by the BAML production.</span></span>

##### <a name="assembly-load-for-initial-markup"></a><span data-ttu-id="cadf1-164">初始标记的程序集加载：</span><span class="sxs-lookup"><span data-stu-id="cadf1-164">Assembly load for initial markup:</span></span>

<span data-ttu-id="cadf1-165">对从中加载标记的程序集的引用始终是非限定的。</span><span class="sxs-lookup"><span data-stu-id="cadf1-165">The reference to the assembly to load the markup from is always unqualified.</span></span>

1. <span data-ttu-id="cadf1-166">WPF XAML 架构上下文遍历 <xref:System.AppDomain> wpf 应用程序的，并从最近加载的程序集开始，查找与名称的所有方面相匹配的已加载程序集。</span><span class="sxs-lookup"><span data-stu-id="cadf1-166">The WPF XAML schema context iterates through the <xref:System.AppDomain> of the WPF application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</span></span> <span data-ttu-id="cadf1-167">如果找到匹配项，则使用该程序集进行解析。</span><span class="sxs-lookup"><span data-stu-id="cadf1-167">If a match is found, that assembly is used for resolution.</span></span>

2. <span data-ttu-id="cadf1-168">如果前面的步骤失败，请使用短名称 (和公钥标记（如果) 存在）以调用 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="cadf1-168">If the previous step fails, use the short name (and public key token if present) to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>

##### <a name="assembly-references-by-baml-types"></a><span data-ttu-id="cadf1-169">BAML 类型的程序集引用：</span><span class="sxs-lookup"><span data-stu-id="cadf1-169">Assembly references by BAML types:</span></span>

<span data-ttu-id="cadf1-170">BAML 生产中使用的类型的程序集引用始终是完全限定的，作为生成任务的输出。</span><span class="sxs-lookup"><span data-stu-id="cadf1-170">Assembly references for types used in the BAML production are always fully qualified, as an output of the build task.</span></span>

01. <span data-ttu-id="cadf1-171">WPF XAML 架构上下文遍历 <xref:System.AppDomain> wpf 应用程序的，并从最近加载的程序集开始，查找与名称的所有方面相匹配的已加载程序集。</span><span class="sxs-lookup"><span data-stu-id="cadf1-171">The WPF XAML schema context iterates through the <xref:System.AppDomain> of the WPF application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</span></span> <span data-ttu-id="cadf1-172">如果找到匹配项，则使用该程序集进行解析。</span><span class="sxs-lookup"><span data-stu-id="cadf1-172">If a match is found, that assembly is used for resolution.</span></span>

02. <span data-ttu-id="cadf1-173">否则，将使用以下方法之一来加载程序集：</span><span class="sxs-lookup"><span data-stu-id="cadf1-173">Otherwise, one of the following techniques is used to load an assembly:</span></span>

    - <span data-ttu-id="cadf1-174">对 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> 限定名称调用。</span><span class="sxs-lookup"><span data-stu-id="cadf1-174">Call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> on the qualified name.</span></span>
  
    - <span data-ttu-id="cadf1-175">如果短名称 + 公钥标记组合与从其加载 BAML 的程序集相匹配，则使用该程序集。</span><span class="sxs-lookup"><span data-stu-id="cadf1-175">If a short name + public key token combination match the assembly that the BAML was loaded from, use that assembly.</span></span>

    - <span data-ttu-id="cadf1-176">使用短名称 + 公钥标记调用 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="cadf1-176">Use short name + public key token to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>

## <a name="see-also"></a><span data-ttu-id="cadf1-177">另请参阅</span><span class="sxs-lookup"><span data-stu-id="cadf1-177">See also</span></span>

- [<span data-ttu-id="cadf1-178">了解 XAML 节点流结构和概念</span><span class="sxs-lookup"><span data-stu-id="cadf1-178">Understanding XAML Node Stream Structures and Concepts</span></span>](understanding-xaml-node-stream-structures-and-concepts.md)
