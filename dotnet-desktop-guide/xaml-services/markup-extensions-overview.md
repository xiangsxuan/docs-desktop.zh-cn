---
title: XAML 的标记扩展概述
ms.date: 03/30/2017
helpviewer_keywords:
- markup extensions [XAML Services], custom
- XAML [XAML Services], markup extensions
ms.assetid: 261b2b11-2dc0-462f-8c66-55b8c9c6e436
ms.openlocfilehash: 69f9d899b9a33d3de2fd7762990925138a47767c
ms.sourcegitcommit: 9f6df084c53a3da0ea657ed0d708a72213683084
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/09/2020
ms.locfileid: "96972872"
---
# <a name="overview-of-markup-extensions-for-xaml"></a><span data-ttu-id="d1fce-102">XAML 的标记扩展概述</span><span class="sxs-lookup"><span data-stu-id="d1fce-102">Overview of markup extensions for XAML</span></span>

<span data-ttu-id="d1fce-103">标记扩展是一种用于获取非基元或特定 XAML 类型的值的 XAML 方法。</span><span class="sxs-lookup"><span data-stu-id="d1fce-103">Markup extensions are a XAML technique for obtaining a value that's not a primitive or a specific XAML type.</span></span> <span data-ttu-id="d1fce-104">对于特性用法，标记扩展使用已知的左大括号 `{` 字符序列输入标记扩展范围，并使用右大括号 `}` 退出。</span><span class="sxs-lookup"><span data-stu-id="d1fce-104">For attribute usage, markup extensions use the known character sequence of an opening curly brace `{` to enter the markup extension scope, and a closing curly brace `}` to exit.</span></span> <span data-ttu-id="d1fce-105">使用 .NET XAML 服务时，可以使用来自 system.exception 程序集的某些预定义 XAML 语言标记扩展。</span><span class="sxs-lookup"><span data-stu-id="d1fce-105">When using .NET XAML Services, you can use some of the predefined XAML language markup extensions from the System.Xaml assembly.</span></span> <span data-ttu-id="d1fce-106">还可以使用 <xref:System.Windows.Markup.MarkupExtension> 类（在 System.Xaml 中定义）的子类，并定义自己的标记扩展。</span><span class="sxs-lookup"><span data-stu-id="d1fce-106">You can also subclass from the <xref:System.Windows.Markup.MarkupExtension> class, defined in System.Xaml, and define your own markup extensions.</span></span> <span data-ttu-id="d1fce-107">或者，如果您已在引用框架，则可以使用由特定框架定义的标记扩展。</span><span class="sxs-lookup"><span data-stu-id="d1fce-107">Or you can use markup extensions defined by a particular framework if you are already referencing that framework.</span></span>

<span data-ttu-id="d1fce-108">访问标记扩展用法时，XAML 对象编写器可以通过 <xref:System.Windows.Markup.MarkupExtension> 重写中的服务连接点向自定义 <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A?displayProperty=nameWithType> 类提供服务。</span><span class="sxs-lookup"><span data-stu-id="d1fce-108">When a markup extension usage is accessed, the XAML object writer can provide services to a custom <xref:System.Windows.Markup.MarkupExtension> class through a service connection point in the <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="d1fce-109">服务可以用于获取有关用法的上下文、对象编写器的特定功能、XAML 架构上下文等。</span><span class="sxs-lookup"><span data-stu-id="d1fce-109">The services can be used to obtain context about the usage, specific capabilities of the object writer, XAML schema context, and so on.</span></span>

## <a name="xaml-defined-markup-extensions"></a><span data-ttu-id="d1fce-110">XAML 定义的标记扩展</span><span class="sxs-lookup"><span data-stu-id="d1fce-110">XAML-defined markup extensions</span></span>

<span data-ttu-id="d1fce-111">.NET XAML 服务为 XAML 语言支持实现了几个标记扩展。</span><span class="sxs-lookup"><span data-stu-id="d1fce-111">Several markup extensions are implemented by .NET XAML Services for XAML language support.</span></span> <span data-ttu-id="d1fce-112">这些标记扩展与作为一种语言的 XAML 规范各部分相对应。</span><span class="sxs-lookup"><span data-stu-id="d1fce-112">These markup extensions correspond to parts of the specification of XAML as a language.</span></span> <span data-ttu-id="d1fce-113">这些扩展通常在语法中可由 `x:` 前缀进行标识（如常见用法中所见）。</span><span class="sxs-lookup"><span data-stu-id="d1fce-113">These are typically identifiable by the `x:` prefix in the syntax as seen in common usage.</span></span> <span data-ttu-id="d1fce-114">这些 XAML 语言元素的 .NET XAML 服务实现都派生自  <xref:System.Windows.Markup.MarkupExtension> 基类。</span><span class="sxs-lookup"><span data-stu-id="d1fce-114">.NET XAML Services implementations for these XAML language elements all derive from the  <xref:System.Windows.Markup.MarkupExtension> base class.</span></span>

> [!NOTE]
> <span data-ttu-id="d1fce-115">`x:` 前缀用于 XAML 语言命名空间中的典型 XAML 命名空间映射（在 XAML 生成的根元素中）。</span><span class="sxs-lookup"><span data-stu-id="d1fce-115">The `x:` prefix is used for the typical XAML namespace mapping of the XAML language namespace, in the root element of a XAML production.</span></span> <span data-ttu-id="d1fce-116">例如，用于各种特定框架的 Visual Studio 项目和页面模板会使用此映射启动一个 XAML 文件 `x:` 。</span><span class="sxs-lookup"><span data-stu-id="d1fce-116">For example, the Visual Studio project and page templates for various specific frameworks initiate a XAML file using this `x:` mapping.</span></span> <span data-ttu-id="d1fce-117">可以在自己的 XAML 命名空间映射中选择不同的前缀标记，但是本文档采用默认值 `x:` 映射来标识作为 XAML 语言 XAML 命名空间的已定义部分的实体，而不是采用特定框架的默认 XAML 命名空间或其他任意 CLR 或 XML 命名空间。</span><span class="sxs-lookup"><span data-stu-id="d1fce-117">You could choose a different prefix token in your own XAML namespace mapping, but this documentation will assume the default `x:` mapping as a means of identifying those entities that are a defined part of the XAML language XAML namespace, as opposed to a specific framework's default XAML namespace or other arbitrary CLR or XML namespaces.</span></span>

### <a name="xtype"></a><span data-ttu-id="d1fce-118">x:Type</span><span class="sxs-lookup"><span data-stu-id="d1fce-118">x:Type</span></span>

<span data-ttu-id="d1fce-119">`x:Type` 为命名类型提供 <xref:System.Type> 对象。</span><span class="sxs-lookup"><span data-stu-id="d1fce-119">`x:Type` supplies the <xref:System.Type> object for the named type.</span></span> <span data-ttu-id="d1fce-120">此功能最常在使用基础 CLR 类型和类型派生作为分组名字对象或标识符的延迟机制中使用。</span><span class="sxs-lookup"><span data-stu-id="d1fce-120">This functionality is used most frequently in deferral mechanisms that use underlying CLR type and type derivation as a grouping moniker or identifier.</span></span> <span data-ttu-id="d1fce-121">WPF 样式和模板以及其 `TargetType` 属性的用法是一个具体示例。</span><span class="sxs-lookup"><span data-stu-id="d1fce-121">WPF styles and templates, and their usage of `TargetType` properties, are a specific example.</span></span> <span data-ttu-id="d1fce-122">有关详细信息，请参阅 [x:Type Markup Extension](xtype-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="d1fce-122">For more information, see [x:Type Markup Extension](xtype-markup-extension.md).</span></span>

### <a name="xstatic"></a><span data-ttu-id="d1fce-123">x:Static</span><span class="sxs-lookup"><span data-stu-id="d1fce-123">x:Static</span></span>

<span data-ttu-id="d1fce-124">`x:Static` 从值-类型代码实体生成静态值，它们不直接是属性值的类型，但可以计算为该类型。</span><span class="sxs-lookup"><span data-stu-id="d1fce-124">`x:Static` produces static values from value-type code entities that are not directly the type of a property's value, but can be evaluated to that type.</span></span> <span data-ttu-id="d1fce-125">这可用于将已存在的值指定为类型定义中的已知常量。</span><span class="sxs-lookup"><span data-stu-id="d1fce-125">This is useful for specifying values that already exist as well-known constants in a type definition.</span></span> <span data-ttu-id="d1fce-126">有关详细信息，请参阅 [x:Static Markup Extension](xstatic-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="d1fce-126">For more information, see [x:Static Markup Extension](xstatic-markup-extension.md).</span></span>

### <a name="xnull"></a><span data-ttu-id="d1fce-127">x:Null</span><span class="sxs-lookup"><span data-stu-id="d1fce-127">x:Null</span></span>

<span data-ttu-id="d1fce-128">`x:Null` 指定 `null` 作为 XAML 成员的值。</span><span class="sxs-lookup"><span data-stu-id="d1fce-128">`x:Null` specifies `null` as a value for a XAML member.</span></span> <span data-ttu-id="d1fce-129">根据特定类型的设计或更大框架概念， `null` 并不总是属性的默认值，或是空字符串特性的隐式值。</span><span class="sxs-lookup"><span data-stu-id="d1fce-129">Depending on the design of specific types or on larger framework concepts, `null` is not always a default value for a property, or the implied value of an empty string attribute.</span></span> <span data-ttu-id="d1fce-130">有关详细信息，请参阅 [x:Null Markup Extension](xnull-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="d1fce-130">For more information, see [x:Null Markup Extension](xnull-markup-extension.md).</span></span>

### <a name="xarray"></a><span data-ttu-id="d1fce-131">x:Array</span><span class="sxs-lookup"><span data-stu-id="d1fce-131">x:Array</span></span>

<span data-ttu-id="d1fce-132">`x:Array` 支持采用 XAML 语法创建常规数组，以防出现故意不使用由基元素和控件模型提供的集合支持的情况。</span><span class="sxs-lookup"><span data-stu-id="d1fce-132">`x:Array` supports creation of general arrays in XAML syntax in cases where the collection support that is provided by base elements and control models is deliberately not used.</span></span> <span data-ttu-id="d1fce-133">有关更多信息，请参见 [x:Array Markup Extension](xarray-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="d1fce-133">For more information, see [x:Array Markup Extension](xarray-markup-extension.md).</span></span> <span data-ttu-id="d1fce-134">具体而言，在 XAML 2009 中，数组是作为语言基元而不是作为扩展进行访问。</span><span class="sxs-lookup"><span data-stu-id="d1fce-134">In XAML 2009 specifically, arrays are accessed as language primitives instead of as an extension.</span></span> <span data-ttu-id="d1fce-135">有关更多信息，请参见 [XAML 2009 Language Features](xaml-2009-language-features.md)。</span><span class="sxs-lookup"><span data-stu-id="d1fce-135">For more information, see [XAML 2009 Language Features](xaml-2009-language-features.md).</span></span>

### <a name="xreference"></a><span data-ttu-id="d1fce-136">x:Reference</span><span class="sxs-lookup"><span data-stu-id="d1fce-136">x:Reference</span></span>

<span data-ttu-id="d1fce-137">`x:Reference` 属于 XAML 2009（原始 (2006) 语言集的扩展）。</span><span class="sxs-lookup"><span data-stu-id="d1fce-137">`x:Reference` is part of XAML 2009, an extension of the original (2006) language set.</span></span> <span data-ttu-id="d1fce-138">`x:Reference` 表示对对象图中另一个现有对象的引用。</span><span class="sxs-lookup"><span data-stu-id="d1fce-138">`x:Reference` represents a reference to another existing object in an object graph.</span></span> <span data-ttu-id="d1fce-139">该对象由其 `x:Name`进行标识。</span><span class="sxs-lookup"><span data-stu-id="d1fce-139">That object is identified by its `x:Name`.</span></span> <span data-ttu-id="d1fce-140">有关详细信息，请参阅 [x:Reference Markup Extension](xreference-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="d1fce-140">For more information, see [x:Reference Markup Extension](xreference-markup-extension.md).</span></span>

### <a name="other-x-constructs"></a><span data-ttu-id="d1fce-141">其他 x: 构造</span><span class="sxs-lookup"><span data-stu-id="d1fce-141">Other x: Constructs</span></span>

<span data-ttu-id="d1fce-142">还有其他用于支持 XAML 语言功能的 `x:` 构造，不过这些构造并不作为标记扩展而实现。</span><span class="sxs-lookup"><span data-stu-id="d1fce-142">Other `x:` constructs to support XAML language features exist, but these are not implemented as markup extensions.</span></span> <span data-ttu-id="d1fce-143">有关详细信息，请参阅 [XAML 命名空间 (x:)语言功能](namespace-language-features.md)。</span><span class="sxs-lookup"><span data-stu-id="d1fce-143">For more information, see [XAML Namespace (x:) Language Features](namespace-language-features.md).</span></span>

## <a name="the-markupextension-base-class"></a><span data-ttu-id="d1fce-144">MarkupExtension 基类</span><span class="sxs-lookup"><span data-stu-id="d1fce-144">The MarkupExtension Base Class</span></span>

<span data-ttu-id="d1fce-145">若要定义可以与 System.Xaml 中 XAML 读取器和 XAML 编写器的默认实现进行交互的自定义标记扩展，可从抽象 <xref:System.Windows.Markup.MarkupExtension> 类派生类。</span><span class="sxs-lookup"><span data-stu-id="d1fce-145">To define a custom markup extension that can interact with the default implementations of XAML readers and XAML writers in System.Xaml, you derive a class from the abstract <xref:System.Windows.Markup.MarkupExtension> class.</span></span> <span data-ttu-id="d1fce-146">该类具有一个用于重写的方法，即 <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>。</span><span class="sxs-lookup"><span data-stu-id="d1fce-146">That class has one method to override, which is <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>.</span></span> <span data-ttu-id="d1fce-147">可能还需要定义其他构造函数来支持用于标记扩展用法和匹配可设置属性的参数。</span><span class="sxs-lookup"><span data-stu-id="d1fce-147">You might also need to define additional constructors to support arguments to the markup extension usage, and matching settable properties.</span></span>

<span data-ttu-id="d1fce-148">通过 <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A> ，自定义标记扩展有权访问一个服务上下文，该服务上下文报告 XAML 处理器调用标记扩展的环境。</span><span class="sxs-lookup"><span data-stu-id="d1fce-148">Through <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>, a custom markup extension has access to a service context that reports the environment where the markup extension is invoked by a XAML processor.</span></span> <span data-ttu-id="d1fce-149">在加载路径中，这通常是 <xref:System.Xaml.XamlObjectWriter> 。</span><span class="sxs-lookup"><span data-stu-id="d1fce-149">In the load path, this is typically a <xref:System.Xaml.XamlObjectWriter>.</span></span> <span data-ttu-id="d1fce-150">在保存路径中，这通常是 <xref:System.Xaml.XamlXmlWriter>。</span><span class="sxs-lookup"><span data-stu-id="d1fce-150">In the save path this is typically a <xref:System.Xaml.XamlXmlWriter>.</span></span> <span data-ttu-id="d1fce-151">每项都将服务上下文报告为内部 XAML 服务提供程序上下文类，该类可实现一种服务提供程序模式。</span><span class="sxs-lookup"><span data-stu-id="d1fce-151">Each report the service context as an internal XAML service provider context class that implements a service provider pattern.</span></span> <span data-ttu-id="d1fce-152">有关可用服务以及它们所表示的含义的详细信息，请参阅 [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md)。</span><span class="sxs-lookup"><span data-stu-id="d1fce-152">For more information about the available services and what they represent, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="d1fce-153">标记扩展类必须使用公共访问级别；XAML 处理器必须始终能够实例化标记扩展的支持类，以便使用其服务。</span><span class="sxs-lookup"><span data-stu-id="d1fce-153">Your markup extension class must use a public access level; XAML processors must always be able to instantiate the markup extension's support class in order to use its services.</span></span>

## <a name="defining-the-support-type-for-a-custom-markup-extension"></a><span data-ttu-id="d1fce-154">为自定义标记扩展定义支持类型</span><span class="sxs-lookup"><span data-stu-id="d1fce-154">Defining the Support Type for a Custom Markup Extension</span></span>

<span data-ttu-id="d1fce-155">使用 .net xaml 服务或在 .NET XAML 服务上构建的框架时，对于如何命名标记扩展支持类型有两种选择。</span><span class="sxs-lookup"><span data-stu-id="d1fce-155">When you use .NET XAML Services or frameworks that build on .NET XAML Services, you have two choices for how to name the markup extension support type.</span></span> <span data-ttu-id="d1fce-156">类型名与 XAML 对象编写器在 XAML 中遇到标记扩展用法时如何尝试访问并调用标记扩展支持类型相关。</span><span class="sxs-lookup"><span data-stu-id="d1fce-156">The type name is relevant to how XAML object writers attempt to access and invoke a markup extension support type when they encounter a markup extension usage in XAML.</span></span> <span data-ttu-id="d1fce-157">使用以下命名策略之一：</span><span class="sxs-lookup"><span data-stu-id="d1fce-157">Use one of the following naming strategies:</span></span>

- <span data-ttu-id="d1fce-158">将类型名命名为与 XAML 标记用法标记完全匹配。</span><span class="sxs-lookup"><span data-stu-id="d1fce-158">Name the type name to be an exact match to the XAML markup usage token.</span></span> <span data-ttu-id="d1fce-159">例如，若要支持 `{Collate ...}` 扩展用法，请将支持类型命名为 `Collate`。</span><span class="sxs-lookup"><span data-stu-id="d1fce-159">For example, to support a `{Collate ...}` extension usage, name the support type `Collate`.</span></span>
- <span data-ttu-id="d1fce-160">将类型名命名为用法字符串标记加上后缀 `Extension`。</span><span class="sxs-lookup"><span data-stu-id="d1fce-160">Name the type name to be the usage string token plus the suffix `Extension`.</span></span> <span data-ttu-id="d1fce-161">例如，若要支持 `{Collate ...}` 扩展用法，请将支持类型命名为 `CollateExtension`。</span><span class="sxs-lookup"><span data-stu-id="d1fce-161">For example, to support a `{Collate ...}` extension usage, name the support type `CollateExtension`.</span></span>

<span data-ttu-id="d1fce-162">查找顺序是首先查找带 `Extension`后缀的类名，然后查找不带 `Extension` 后缀的类名。</span><span class="sxs-lookup"><span data-stu-id="d1fce-162">The order of lookup is to look for the `Extension`-suffixed class name first and then look for the class name without the `Extension` suffix.</span></span>

<span data-ttu-id="d1fce-163">从标记用法的角度来看，在用法中包含 `Extension` 后缀是有效的。</span><span class="sxs-lookup"><span data-stu-id="d1fce-163">From the markup usage perspective, including the `Extension` suffix as part of the usage is valid.</span></span> <span data-ttu-id="d1fce-164">但是，这种方法的行为如同 `Extension` 真正是类名的一部分，如果标记扩展支持类没有 `Extension` 后缀，XAML 对象编写器会无法针对该用法解析支持类。</span><span class="sxs-lookup"><span data-stu-id="d1fce-164">However, this behaves as if `Extension` is truly part of the class name, and XAML object writers would fail to resolve a markup extension support class for that usage if the support class did not have the `Extension` suffix.</span></span>

### <a name="the-parameterless-constructor"></a><span data-ttu-id="d1fce-165">无参数构造函数</span><span class="sxs-lookup"><span data-stu-id="d1fce-165">The parameterless constructor</span></span>

<span data-ttu-id="d1fce-166">对于所有标记扩展支持类型，应公开一个公共的无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="d1fce-166">For all markup extension support types, you should expose a public parameterless constructor.</span></span> <span data-ttu-id="d1fce-167">对于 XAML 对象编写器从对象元素用法实例化标记扩展的任何情况，都需要一个无参数的构造函数。</span><span class="sxs-lookup"><span data-stu-id="d1fce-167">A parameterless constructor is required for any case where a XAML object writer instantiates the markup extension from an object element usage.</span></span> <span data-ttu-id="d1fce-168">支持对象元素用法对于标记扩展是合理预期（特别是对于序列化）。</span><span class="sxs-lookup"><span data-stu-id="d1fce-168">Supporting object element usage is a fair expectation for a markup extension, particularly for serialization.</span></span> <span data-ttu-id="d1fce-169">但是，如果只想支持标记扩展的特性用法，则可以在没有公共构造函数的情况下实现标记扩展。</span><span class="sxs-lookup"><span data-stu-id="d1fce-169">However, you can implement a markup extension without a public constructor if you only intend to support attribute usages of the markup extension.</span></span>

<span data-ttu-id="d1fce-170">如果标记扩展用法没有参数，则需要使用无参数构造函数来支持使用。</span><span class="sxs-lookup"><span data-stu-id="d1fce-170">If your markup extension usage has no arguments, the parameterless constructor is required to support usage.</span></span>

## <a name="constructor-patterns-and-positional-arguments-for-a-custom-markup-extension"></a><span data-ttu-id="d1fce-171">自定义标记扩展的构造函数模式和位置参数</span><span class="sxs-lookup"><span data-stu-id="d1fce-171">Constructor Patterns and Positional Arguments for a Custom Markup Extension</span></span>

<span data-ttu-id="d1fce-172">对于具有预期参数用法的标记扩展，公共构造函数必须对应于预期用法的模式。</span><span class="sxs-lookup"><span data-stu-id="d1fce-172">For a markup extension with intended argument usage, the public constructors must correspond to the modes of the intended usage.</span></span> <span data-ttu-id="d1fce-173">换句话说，如果标记扩展设计为需要一个位置参数作为有效用法，则应支持一个输入参数采用位置参数的公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="d1fce-173">In other words, if your markup extension is designed to require one positional argument as a valid usage, you should support a public constructor with one input parameter that takes the positional argument.</span></span>

<span data-ttu-id="d1fce-174">例如，假设 `Collate` 标记扩展旨在仅支持以下模式：有一个表示其模式的位置参数，指定为 `CollationMode` 枚举常量。</span><span class="sxs-lookup"><span data-stu-id="d1fce-174">For example, suppose the `Collate` markup extension is intended to support only a mode where there is one positional argument that represents its mode, specified as a `CollationMode` enumeration constant.</span></span> <span data-ttu-id="d1fce-175">在这种情况下，应存在具有以下形式的构造函数：</span><span class="sxs-lookup"><span data-stu-id="d1fce-175">In this case, there should be a constructor with the following form:</span></span>

```csharp
public Collate(CollationMode collationMode) {...}
```

<span data-ttu-id="d1fce-176">在基本级别，传递到标记扩展的参数是字符串，因为它们从标记的特性值进行转发。</span><span class="sxs-lookup"><span data-stu-id="d1fce-176">At a basic level, the arguments passed to a markup extension are a string because they are being forwarded from the markup's attribute values.</span></span> <span data-ttu-id="d1fce-177">可以在该级别创建所有参数字符串并处理输入。</span><span class="sxs-lookup"><span data-stu-id="d1fce-177">You can make all of your arguments strings and work with input at that level.</span></span> <span data-ttu-id="d1fce-178">但是，的确可以访问在标记扩展参数传递到支持类之前发生的某些处理。</span><span class="sxs-lookup"><span data-stu-id="d1fce-178">However, you do have access to certain processing that occurs before the markup extension arguments are passed to the support class.</span></span>

<span data-ttu-id="d1fce-179">处理的工作原理在概念上如同标记扩展是要创建的对象，然后设置其成员值。</span><span class="sxs-lookup"><span data-stu-id="d1fce-179">The processing works conceptually as if the markup extension is an object to be created, and then its member values are set.</span></span> <span data-ttu-id="d1fce-180">要设置的每个指定属性的计算方式都类似于如何在分析 XAML 时对创建的对象设置指定成员。</span><span class="sxs-lookup"><span data-stu-id="d1fce-180">Each specified property to set is evaluated similar to how a specified member can be set on a created object when XAML is parsed.</span></span> <span data-ttu-id="d1fce-181">有两个重要的差异：</span><span class="sxs-lookup"><span data-stu-id="d1fce-181">There are two important differences:</span></span>

- <span data-ttu-id="d1fce-182">如前所述，标记扩展支持类型不需要具有无参数的构造函数即可在 XAML 中进行实例化。</span><span class="sxs-lookup"><span data-stu-id="d1fce-182">As noted previously, a markup extension support type does not need to have a parameterless constructor in order to be instantiated in XAML.</span></span> <span data-ttu-id="d1fce-183">其对象构造会推迟到文本语法中的可能参数进行词汇切分并计算为位置或命名参数，会在该时间调用适当的构造函数。</span><span class="sxs-lookup"><span data-stu-id="d1fce-183">Its object construction is deferred until its possible arguments in the text syntax are tokenized and evaluated as either positional or named arguments, and the appropriate constructor is called at that time.</span></span>
- <span data-ttu-id="d1fce-184">标记扩展用法可以进行嵌套。</span><span class="sxs-lookup"><span data-stu-id="d1fce-184">Markup extensions usages can be nested.</span></span> <span data-ttu-id="d1fce-185">首先计算最内层的标记扩展。</span><span class="sxs-lookup"><span data-stu-id="d1fce-185">The innermost markup extension is evaluated first.</span></span> <span data-ttu-id="d1fce-186">因此，可以采用这类用法，并一个构造参数声明为需要生成值转换器（如标记扩展）的类型。</span><span class="sxs-lookup"><span data-stu-id="d1fce-186">Therefore, you can assume such a usage and declare one of the construction parameters to be a type that requires a value converter (such as a markup extension) to produce.</span></span>

<span data-ttu-id="d1fce-187">前面的示例演示了对这类处理的依赖。</span><span class="sxs-lookup"><span data-stu-id="d1fce-187">A reliance on such processing was shown in the previous example.</span></span> <span data-ttu-id="d1fce-188">.NET XAML 服务 XAML 对象编写器会在本机级别将枚举常量名处理为枚举值。</span><span class="sxs-lookup"><span data-stu-id="d1fce-188">.NET XAML Services XAML object writer processes enumeration constant names into enumerated values at a native level.</span></span>

<span data-ttu-id="d1fce-189">标记扩展位置参数的文本语法处理还可以依赖于与构造参数中的类型相关联的类型转换器。</span><span class="sxs-lookup"><span data-stu-id="d1fce-189">Processing text syntax of a markup extension positional parameter can also rely on a type converter that is associated with the type that is in the construction argument.</span></span>

<span data-ttu-id="d1fce-190">这些参数称为位置参数，因为用法中的标记的出现顺序对应于将它们分配给的构造函数参数的位置顺序。</span><span class="sxs-lookup"><span data-stu-id="d1fce-190">The arguments are called positional arguments because the order in which the tokens in the usage is encountered corresponds to the positional order of the constructor parameter to which they are assigned.</span></span> <span data-ttu-id="d1fce-191">例如，请考虑以下构造函数签名：</span><span class="sxs-lookup"><span data-stu-id="d1fce-191">For example, consider the following constructor signature:</span></span>

```csharp
public Collate(CollationMode collationMode, object collateThis) {...}
```

<span data-ttu-id="d1fce-192">XAML 处理器对于此标记扩展需要两个位置参数。</span><span class="sxs-lookup"><span data-stu-id="d1fce-192">A XAML processor expects two positional arguments for this markup extension.</span></span> <span data-ttu-id="d1fce-193">如果存在用法 `{Collate AlphaUp,{x:Reference circularFile}}`，则 `AlphaUp` 标记会发送到第一个参数并计算为 `CollationMode` 枚举命名常量。</span><span class="sxs-lookup"><span data-stu-id="d1fce-193">If there was a usage `{Collate AlphaUp,{x:Reference circularFile}}`, the `AlphaUp` token is sent to the first parameter and evaluated as a `CollationMode` enumeration named constant.</span></span> <span data-ttu-id="d1fce-194">内部 `x:Reference` 的结果会发送到第二个参数并计算为一个对象。</span><span class="sxs-lookup"><span data-stu-id="d1fce-194">The result of the inner `x:Reference` is sent to the second parameter and evaluated as an object.</span></span>

<span data-ttu-id="d1fce-195">在用于标记扩展语法和处理的 XAML 指定规则中，逗号是参数之间的分隔符（无论这些参数是位置参数还是命名参数）。</span><span class="sxs-lookup"><span data-stu-id="d1fce-195">In the XAML specified rules for markup extension syntax and processing, the comma is the delimiter between arguments, whether those arguments are positional arguments or named arguments.</span></span>

### <a name="duplicate-arity-of-positional-arguments"></a><span data-ttu-id="d1fce-196">位置参数的重复 arity</span><span class="sxs-lookup"><span data-stu-id="d1fce-196">Duplicate arity of positional arguments</span></span>

<span data-ttu-id="d1fce-197">如果 XAML 对象编写器遇到具有位置参数的标记扩展用法，并且有多个采用该数量的参数（重复 Arity）的构造函数参数，则这不一定是错误。</span><span class="sxs-lookup"><span data-stu-id="d1fce-197">If a XAML object writer encounters a markup extension usage with positional arguments, and there are multiple constructor arguments that take that number of arguments (a duplicate arity), that is not necessarily an error.</span></span> <span data-ttu-id="d1fce-198">行为取决于可自定义的 XAML 架构上下文设置 <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A>。</span><span class="sxs-lookup"><span data-stu-id="d1fce-198">The behavior depends on a customizable XAML schema context setting, <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A>.</span></span> <span data-ttu-id="d1fce-199">如果 <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> 是 `true`，则 XAML 对象编写器不应仅由于重复 Arity 而引发异常。</span><span class="sxs-lookup"><span data-stu-id="d1fce-199">If <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> is `true`, a XAML object writer should not throw an exception only for reasons of duplicate arity.</span></span> <span data-ttu-id="d1fce-200">未严格定义超越该点的行为。</span><span class="sxs-lookup"><span data-stu-id="d1fce-200">Behavior beyond that point is not strictly defined.</span></span> <span data-ttu-id="d1fce-201">基本设计假设是架构上下文具有可用于特定参数的类型信息，并且可以尝试与重复候选项匹配的显式强制转换，以查看哪个签名可能是最佳匹配。</span><span class="sxs-lookup"><span data-stu-id="d1fce-201">The basic design assumption is that the schema context has type information available for the specific parameters and can attempt explicit casts that match the duplicate candidates to see which signature might be the best match.</span></span> <span data-ttu-id="d1fce-202">如果没有签名可以通过在 XAML 对象编写器上运行的该特定架构上下文施加的测试，则仍可能会引发异常。</span><span class="sxs-lookup"><span data-stu-id="d1fce-202">An exception might still be thrown if no signatures can pass the tests that are imposed by that particular schema context that is running on a XAML object writer.</span></span>

<span data-ttu-id="d1fce-203">默认情况下， <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> 位于 `false` 基于 CLR <xref:System.Xaml.XamlSchemaContext> 的 For .net XAML 服务中。</span><span class="sxs-lookup"><span data-stu-id="d1fce-203">By default, <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> is `false` in the CLR-based <xref:System.Xaml.XamlSchemaContext> for .NET XAML Services.</span></span> <span data-ttu-id="d1fce-204">因此，如果遇到在后备类型的构造函数中有重复 arity 的标记扩展用法，则默认值 <xref:System.Xaml.XamlObjectWriter> 会引发异常。</span><span class="sxs-lookup"><span data-stu-id="d1fce-204">Thus, the default <xref:System.Xaml.XamlObjectWriter> throws exceptions if it encounters a markup extension usage where there is duplicate arity in the backing type's constructors.</span></span>

## <a name="named-arguments-for-a-custom-markup-extension"></a><span data-ttu-id="d1fce-205">自定义标记扩展的命名参数</span><span class="sxs-lookup"><span data-stu-id="d1fce-205">Named arguments for a custom markup extension</span></span>

<span data-ttu-id="d1fce-206">XAML 指定的标记扩展还可以使用命名参数形式来实现用法。</span><span class="sxs-lookup"><span data-stu-id="d1fce-206">Markup extensions as specified by XAML can also use a named arguments form for usage.</span></span> <span data-ttu-id="d1fce-207">在第一个词汇切分级别上，文本语法划分为各个参数。</span><span class="sxs-lookup"><span data-stu-id="d1fce-207">At the first level of tokenization, the text syntax is divided into arguments.</span></span> <span data-ttu-id="d1fce-208">任何参数中存在等号 (=) 都会将参数标识为命名参数。</span><span class="sxs-lookup"><span data-stu-id="d1fce-208">The presence of an equals sign (=) within any argument identifies an argument as a named argument.</span></span> <span data-ttu-id="d1fce-209">这类参数还会词汇切分为名称/值对。</span><span class="sxs-lookup"><span data-stu-id="d1fce-209">Such an argument is also tokenized into a name/value pair.</span></span> <span data-ttu-id="d1fce-210">这种情况下的名称会命名标记扩展的支持类型的公共可设置属性。</span><span class="sxs-lookup"><span data-stu-id="d1fce-210">The name in this case names a public settable property of the markup extension's support type.</span></span> <span data-ttu-id="d1fce-211">如果要支持命名参数用法，则应提供这些公共可设置属性。</span><span class="sxs-lookup"><span data-stu-id="d1fce-211">If you intend to support named argument usage, you should provide these public settable properties.</span></span> <span data-ttu-id="d1fce-212">这些属性可以是继承的属性，只要它们仍然是公共属性。</span><span class="sxs-lookup"><span data-stu-id="d1fce-212">The properties can be inherited properties as long as they remain public.</span></span>

## <a name="accessing-service-provider-context-from-a-markup-extension-implementation"></a><span data-ttu-id="d1fce-213">从标记扩展实现访问服务提供程序上下文</span><span class="sxs-lookup"><span data-stu-id="d1fce-213">Accessing Service Provider Context from a Markup Extension Implementation</span></span>

<span data-ttu-id="d1fce-214">可用服务对于任何值转换器都是相同的。</span><span class="sxs-lookup"><span data-stu-id="d1fce-214">The services available are the same for any value converter.</span></span> <span data-ttu-id="d1fce-215">不同之处在于每个值转换器接收服务上下文的方式。</span><span class="sxs-lookup"><span data-stu-id="d1fce-215">The difference is in how each value converter receives the service context.</span></span> <span data-ttu-id="d1fce-216">访问服务以及可用服务在主题 [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md)中进行了说明。</span><span class="sxs-lookup"><span data-stu-id="d1fce-216">Accessing services and the services available are documented in the topic [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

## <a name="property-element-usage-of-a-markup-extension"></a><span data-ttu-id="d1fce-217">标记扩展的属性元素用法</span><span class="sxs-lookup"><span data-stu-id="d1fce-217">Property element usage of a markup extension</span></span>

<span data-ttu-id="d1fce-218">标记扩展用法方案通常是围绕在特性用法中使用标记扩展来设计的。</span><span class="sxs-lookup"><span data-stu-id="d1fce-218">The scenarios for markup extension usages are often designed around using the markup extension in attribute usage.</span></span> <span data-ttu-id="d1fce-219">但是，还可能可以定义后备类以支持属性元素用法。</span><span class="sxs-lookup"><span data-stu-id="d1fce-219">However, it is also potentially possible to define the backing class to support property element usage.</span></span>

<span data-ttu-id="d1fce-220">若要支持标记扩展的属性元素用法，请定义公共无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="d1fce-220">To support property element usage of your markup extension, define a public parameterless constructor.</span></span> <span data-ttu-id="d1fce-221">这应是实例构造函数，而不是静态构造函数。</span><span class="sxs-lookup"><span data-stu-id="d1fce-221">This should be an instance constructor not a static constructor.</span></span> <span data-ttu-id="d1fce-222">这是必需的，因为 XAML 处理器通常必须对它从标记处理的任何对象元素调用无参数的构造函数，并且这包括标记扩展类作为对象元素。</span><span class="sxs-lookup"><span data-stu-id="d1fce-222">This is required because a XAML processor must generally invoke the parameterless constructor on any object element it processes from markup, and this includes markup extension classes as object elements.</span></span> <span data-ttu-id="d1fce-223">对于高级方案，可以为类定义非默认构造路径。</span><span class="sxs-lookup"><span data-stu-id="d1fce-223">For advanced scenarios, you can define non-default construction paths for classes.</span></span> <span data-ttu-id="d1fce-224"> (有关详细信息，请参阅 [X:FactoryMethod 指令](xfactorymethod-directive.md)。 ) 不过，您不应将这些模式用于标记扩展目的，因为这使得对使用模式的发现更难，同时用于设计人员和用于原始标记的用户。</span><span class="sxs-lookup"><span data-stu-id="d1fce-224">(For more information, see [x:FactoryMethod Directive](xfactorymethod-directive.md).) However, you should not use these patterns for markup extension purposes because this makes discovery of the usage pattern much more difficult, both for designers and for users of raw markup.</span></span>

## <a name="attributing-for-a-custom-markup-extension"></a><span data-ttu-id="d1fce-225">自定义标记扩展的特性化</span><span class="sxs-lookup"><span data-stu-id="d1fce-225">Attributing for a custom markup extension</span></span>

<span data-ttu-id="d1fce-226">若要支持设计环境和特定 XAML 对象编写器方案，应将标记扩展支持类型归于多个 CLR 特性。</span><span class="sxs-lookup"><span data-stu-id="d1fce-226">To support both design environments and certain XAML object writer scenarios, you should attribute a markup extension support type with several CLR attributes.</span></span> <span data-ttu-id="d1fce-227">这些特性报告预期标记扩展用法。</span><span class="sxs-lookup"><span data-stu-id="d1fce-227">These attributes report the intended markup extension usage.</span></span>

 <span data-ttu-id="d1fce-228"><xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute> 为 <xref:System.Type> 返回的对象类型报告 <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> 信息。</span><span class="sxs-lookup"><span data-stu-id="d1fce-228"><xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute> reports the <xref:System.Type> information for the object type that <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> returns.</span></span> <span data-ttu-id="d1fce-229"><xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> 通过其纯签名返回 <xref:System.Object>。</span><span class="sxs-lookup"><span data-stu-id="d1fce-229">By its pure signature, <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> returns <xref:System.Object>.</span></span> <span data-ttu-id="d1fce-230">但各种使用者可能需要更精确的返回类型信息。</span><span class="sxs-lookup"><span data-stu-id="d1fce-230">But various consumers might want more precise return type information.</span></span> <span data-ttu-id="d1fce-231">这包括：</span><span class="sxs-lookup"><span data-stu-id="d1fce-231">This includes:</span></span>

- <span data-ttu-id="d1fce-232">设计器和 IDE，可能能够为标记扩展用法提供可识别类型的支持。</span><span class="sxs-lookup"><span data-stu-id="d1fce-232">Designers and IDEs, who might be able to provide type-aware support for markup extension usages.</span></span>
- <span data-ttu-id="d1fce-233">目标类上的 `SetMarkupExtension` 处理程序的高级实现，可能依赖于反射来确定标记扩展的返回类型，而不是按名称在特定已知 <xref:System.Windows.Markup.MarkupExtension> 实现上进行分支。</span><span class="sxs-lookup"><span data-stu-id="d1fce-233">Advanced implementations of `SetMarkupExtension` handlers on target classes, which might rely on reflection to determine a markup extension's return type instead of branching on specific known <xref:System.Windows.Markup.MarkupExtension> implementations by name.</span></span>

## <a name="serialization-of-markup-extension-usages"></a><span data-ttu-id="d1fce-234">标记扩展用法的序列化</span><span class="sxs-lookup"><span data-stu-id="d1fce-234">Serialization of markup extension usages</span></span>

<span data-ttu-id="d1fce-235">XAML 对象编写器处理标记扩展用法和调用 <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>时，它以前作为标记扩展用法的上下文仍然保持在 XAML 节点流中，但不在对象图中。</span><span class="sxs-lookup"><span data-stu-id="d1fce-235">When a XAML object writer processes a markup extension usage and calls <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>, the context for it previously being a markup extension usage persists in the XAML node stream but not in the object graph.</span></span> <span data-ttu-id="d1fce-236">在对象图中，仅保留值。</span><span class="sxs-lookup"><span data-stu-id="d1fce-236">In the object graph, only the value is preserved.</span></span> <span data-ttu-id="d1fce-237">如果有设计方案或其他原因要将原始标记扩展用法保持到序列化输出中，则必须设计自己的基础结构，用于从加载路径 XAML 节点流跟踪标记扩展用法。</span><span class="sxs-lookup"><span data-stu-id="d1fce-237">If you have design scenarios or other reasons for persisting the original markup extension usage into the serialized output, you must design your own infrastructure for tracking the markup extension usages from the load path XAML node stream.</span></span> <span data-ttu-id="d1fce-238">可以实现行为以从加载路径重新创建节点流的元素，并将它们播放回 XAML 编写器以在保存路径中进行序列化，从而取代节点流相应位置中的值。</span><span class="sxs-lookup"><span data-stu-id="d1fce-238">You can implement behavior to recreate the elements of the node stream from the load path and play them back to XAML writers for serialization in the save path, substituting for the value in the appropriate position of the node stream.</span></span>

## <a name="markup-extensions-in-the-xaml-node-stream"></a><span data-ttu-id="d1fce-239">XAML 节点流中的标记扩展</span><span class="sxs-lookup"><span data-stu-id="d1fce-239">Markup extensions in the XAML node stream</span></span>

<span data-ttu-id="d1fce-240">如果在加载路径上使用 XAML 节点流，则标记扩展用法会作为对象出现在节点流中。</span><span class="sxs-lookup"><span data-stu-id="d1fce-240">If you are working with a XAML node stream on the load path, a markup extension usage appears in the node stream as an object.</span></span>

<span data-ttu-id="d1fce-241">如果标记扩展用法使用位置参数，则它会表示为具有初始化值的起始对象。</span><span class="sxs-lookup"><span data-stu-id="d1fce-241">If the markup extension usage uses positional arguments, it is represented as a start object with an initialization value.</span></span> <span data-ttu-id="d1fce-242">作为大致的文本表示形式，节点流类似于下面这样：</span><span class="sxs-lookup"><span data-stu-id="d1fce-242">As a rough text representation, the node stream resembles the following:</span></span>

<span data-ttu-id="d1fce-243">`StartObject` （<xref:System.Xaml.XamlType> 是标记扩展的定义类型，而不是其返回类型）</span><span class="sxs-lookup"><span data-stu-id="d1fce-243">`StartObject` (<xref:System.Xaml.XamlType> is the markup extension's definition type, not its return type)</span></span>

<span data-ttu-id="d1fce-244">`StartMember` （ <xref:System.Xaml.XamlMember> 的名称是 `_InitializationText`)</span><span class="sxs-lookup"><span data-stu-id="d1fce-244">`StartMember` (name of the <xref:System.Xaml.XamlMember> is `_InitializationText`)</span></span>

<span data-ttu-id="d1fce-245">`Value` （值是字符串形式的位置参数，包括中间分隔符）</span><span class="sxs-lookup"><span data-stu-id="d1fce-245">`Value` (value is the positional arguments as a string including the intervening delimiters)</span></span>

`EndMember`

`EndObject`

<span data-ttu-id="d1fce-246">具有命名参数的标记扩展用法会表示为具有相关名称成员的对象（各自使用文本字符串值进行设置）。</span><span class="sxs-lookup"><span data-stu-id="d1fce-246">A markup extension usage with named arguments is represented as an object with members of the relevant names, each set with text string values.</span></span>

<span data-ttu-id="d1fce-247">实际调用标记扩展的 `ProvideValue` 实现需要 XAML 架构上下文，因为这需要类型映射和创建标记扩展支持类型实例。</span><span class="sxs-lookup"><span data-stu-id="d1fce-247">Actually invoking the `ProvideValue` implementation of a markup extension requires the XAML schema context because that requires type-mapping and creating a markup extension support type instance.</span></span> <span data-ttu-id="d1fce-248">这是在默认的 .NET XAML 服务节点流中以这种方式保留标记扩展用法的一个原因-加载路径的读取器部分通常不提供必需的 XAML 架构上下文。</span><span class="sxs-lookup"><span data-stu-id="d1fce-248">This is one reason why markup extension usages are preserved this way in the default .NET XAML Services node streams -  the reader part of a load path often does not have the necessary XAML schema context available.</span></span>

<span data-ttu-id="d1fce-249">如果在保存路径上使用 XAML 节点流，则对象图表示形式中通常没有任何内容可告知要序列化的对象最初由标记扩展用法和 `ProvideValue` 结果提供。</span><span class="sxs-lookup"><span data-stu-id="d1fce-249">If you are working with a XAML node stream on the save path, there generally is nothing present in an object graph representation that can inform you that the object to serialize was originally provided by a markup extension usage and a `ProvideValue` result.</span></span> <span data-ttu-id="d1fce-250">需要保持标记扩展用法以进行往返，同时还捕获对象图中的其他更改的方案必须设计自己的方法，来保留原始 XAML 输入中有关标记扩展用法的信息。</span><span class="sxs-lookup"><span data-stu-id="d1fce-250">Scenarios that need to persist markup extension usages for round-tripping while also capturing other changes in the object graph must devise their own techniques for preserving the knowledge of a markup extension usage from the original XAML input.</span></span> <span data-ttu-id="d1fce-251">例如，若要还原标记扩展用法，可能需要在保存路径上使用节点流才能还原标记扩展用法，或在原始 XAML 与往返 XAML 之间执行某种类型的合并。</span><span class="sxs-lookup"><span data-stu-id="d1fce-251">For example, to restore the markup extension usages, you may need to work with the node stream on the save path in order to restore markup extension usages, or perform some type of merge between the original XAML and the round-tripped XAML.</span></span> <span data-ttu-id="d1fce-252">某些 XAML 实现框架（如 WPF）使用中间类型（表达式）来帮助表示标记扩展用法提供值的情况。</span><span class="sxs-lookup"><span data-stu-id="d1fce-252">Some XAML-implementing frameworks such as WPF use intermediate types (expressions) to help represent cases where markup extension usages provided the values.</span></span>

## <a name="see-also"></a><span data-ttu-id="d1fce-253">另请参阅</span><span class="sxs-lookup"><span data-stu-id="d1fce-253">See also</span></span>

- <xref:System.Windows.Markup.MarkupExtension>
- [<span data-ttu-id="d1fce-254">XAML 的类型转换器和标记扩展</span><span class="sxs-lookup"><span data-stu-id="d1fce-254">Type Converters and Markup Extensions for XAML</span></span>](type-converters-and-markup-extensions.md)
- [<span data-ttu-id="d1fce-255">标记扩展和 WPF XAML</span><span class="sxs-lookup"><span data-stu-id="d1fce-255">Markup Extensions and WPF XAML</span></span>](../framework/wpf/advanced/markup-extensions-and-wpf-xaml.md)
