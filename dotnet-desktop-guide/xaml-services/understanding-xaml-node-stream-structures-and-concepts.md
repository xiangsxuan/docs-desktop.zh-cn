---
title: 了解 XAML 节点流结构和概念
ms.date: 03/30/2017
helpviewer_keywords:
- XAML node streams [XAML Services]
- nodes [XAML Services], XAML node stream
- XAML [XAML Services], XAML node streams
ms.assetid: 7c11abec-1075-474c-9d9b-778e5dab21c3
ms.openlocfilehash: b3de3dca029c5e676fc7cdebc7735cfdade0228a
ms.sourcegitcommit: 9f6df084c53a3da0ea657ed0d708a72213683084
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/09/2020
ms.locfileid: "96971711"
---
# <a name="xaml-node-stream-structures-and-concepts"></a><span data-ttu-id="8b817-102">XAML 节点流结构和概念</span><span class="sxs-lookup"><span data-stu-id="8b817-102">XAML node stream structures and concepts</span></span>

<span data-ttu-id="8b817-103">.NET XAML 服务中实现的 XAML 读取器和 XAML 编写器基于 XAML 节点流的设计概念。</span><span class="sxs-lookup"><span data-stu-id="8b817-103">XAML readers and XAML writers as implemented in .NET XAML Services are based on the design concept of a XAML node stream.</span></span> <span data-ttu-id="8b817-104">将一组 XAML 节点概念化就生成 XAML 节点流。</span><span class="sxs-lookup"><span data-stu-id="8b817-104">The XAML node stream is a conceptualization of a set of XAML nodes.</span></span> <span data-ttu-id="8b817-105">在此概念化中，XAML 处理器逐一浏览 XAML 中节点关系的结构。</span><span class="sxs-lookup"><span data-stu-id="8b817-105">In this conceptualization, a XAML processor walks through the structure of the node relationships in the XAML one at a time.</span></span> <span data-ttu-id="8b817-106">一个打开的 XAML 节点流中始终只存在一个当前记录或当前位置，并且 API 的很多方面只报告此位置提供的信息。</span><span class="sxs-lookup"><span data-stu-id="8b817-106">At any time, only one current record or current position exists in an open XAML node stream, and many aspects of the API report only the information available from that position.</span></span> <span data-ttu-id="8b817-107">XAML 节点流中的当前节点可描述为对象、成员或值。</span><span class="sxs-lookup"><span data-stu-id="8b817-107">The current node in a XAML node stream can be described as being an object, a member, or a value.</span></span> <span data-ttu-id="8b817-108">通过将 XAML 视为 XAML 节点流，XAML 读取器可与 XAML 编写器通信；并且在涉及 XAML 的加载路径或保存路径操作过程中可启用程序查看、更改 XAML 节点流的内容或与它交互。</span><span class="sxs-lookup"><span data-stu-id="8b817-108">By treating XAML as a XAML node stream, XAML readers can communicate with XAML writers and enable a program to view, interact with, or alter the contents of a XAML node stream during either a load path or a save path operation that involves XAML.</span></span> <span data-ttu-id="8b817-109">XAML 读取器和编写器 API 设计以及 XAML 节点流概念与上一个相关的读取器和编写器设计和概念（如 XML 文档对象模型 (DOM) 和 <xref:System.Xml.XmlReader> 和 <xref:System.Xml.XmlWriter> 类）类似。</span><span class="sxs-lookup"><span data-stu-id="8b817-109">XAML reader and writer API design and the XAML node stream concept are similar to previous related reader and writer designs and concepts, such as the XML Document Object Model (DOM) and the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="8b817-110">本主题阐述 XAML 节点流概念，并介绍如何编写在 XAML 节点级别上与 XAML 表示形式进行交互的例程。</span><span class="sxs-lookup"><span data-stu-id="8b817-110">This topic discusses XAML node stream concepts and describes how you can write routines that interact with XAML representations at the XAML node level.</span></span>

## <a name="loading-xaml-into-a-xaml-reader"></a><span data-ttu-id="8b817-111">将 XAML 加载到 XAML 读取器</span><span class="sxs-lookup"><span data-stu-id="8b817-111">Loading XAML into a XAML Reader</span></span>

<span data-ttu-id="8b817-112">基 <xref:System.Xaml.XamlReader> 类不会声明用于将初始 XAML 加载到 XAML 读取器的特定技术。</span><span class="sxs-lookup"><span data-stu-id="8b817-112">The base <xref:System.Xaml.XamlReader> class does not declare a particular technique for loading the initial XAML into a XAML reader.</span></span> <span data-ttu-id="8b817-113">相反，派生类声明并实现加载技术，包括用于 XAML 的输入源的常规特性和约束。</span><span class="sxs-lookup"><span data-stu-id="8b817-113">Instead, a derived class declares and implements the loading technique, including the general characteristics and constraints of its input source for XAML.</span></span> <span data-ttu-id="8b817-114">例如， <xref:System.Xaml.XamlObjectReader> 从表示根或基的单个对象的输入源开始读取对象图。</span><span class="sxs-lookup"><span data-stu-id="8b817-114">For example, a <xref:System.Xaml.XamlObjectReader> reads an object graph, starting from the input source of a single object that represents the root or base.</span></span> <span data-ttu-id="8b817-115">然后， <xref:System.Xaml.XamlObjectReader> 从对象图中生成 XAML 节点流。</span><span class="sxs-lookup"><span data-stu-id="8b817-115">The <xref:System.Xaml.XamlObjectReader> then produces a XAML node stream from the object graph.</span></span>

<span data-ttu-id="8b817-116">最突出的 .NET XAML 服务定义的 <xref:System.Xaml.XamlReader> 子类是 <xref:System.Xaml.XamlXmlReader> 。</span><span class="sxs-lookup"><span data-stu-id="8b817-116">The most prominent .NET XAML Services–defined <xref:System.Xaml.XamlReader> subclass is <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="8b817-117"><xref:System.Xaml.XamlXmlReader> 通过流或文件路径直接加载文件本件，或者通过相关的读取器类（如 <xref:System.IO.TextReader>）间接加载，从而加载初始 XAML。</span><span class="sxs-lookup"><span data-stu-id="8b817-117"><xref:System.Xaml.XamlXmlReader> loads the initial XAML, either by loading a text file directly through a stream or file path, or indirectly through a related reader class such as <xref:System.IO.TextReader>.</span></span> <span data-ttu-id="8b817-118">加载后，可认为 <xref:System.Xaml.XamlReader> 包含整个 XAML 输入源。</span><span class="sxs-lookup"><span data-stu-id="8b817-118">The <xref:System.Xaml.XamlReader> can be thought of as containing the entirety of the XAML input source after it has loaded.</span></span> <span data-ttu-id="8b817-119">但是， <xref:System.Xaml.XamlReader> 基 API 旨在使读取器与 XAML 的单节点进行交互。</span><span class="sxs-lookup"><span data-stu-id="8b817-119">However, the <xref:System.Xaml.XamlReader> base API is designed so that the reader is interacting with a single node of the XAML.</span></span> <span data-ttu-id="8b817-120">首次加载时，遇到的第一个单节点就是 XAML 的根和它的启动对象。</span><span class="sxs-lookup"><span data-stu-id="8b817-120">When first loaded, the first single node you encounter is the root of the XAML, and its start object.</span></span>

### <a name="the-xaml-node-stream-concept"></a><span data-ttu-id="8b817-121">XAML 节点流概念</span><span class="sxs-lookup"><span data-stu-id="8b817-121">The XAML Node Stream Concept</span></span>

<span data-ttu-id="8b817-122">如果更熟悉 DOM、树比喻或基于查询的方法来访问基于 XML 的技术，则有一种概念说明 XAML 节点流的方法如下所示。</span><span class="sxs-lookup"><span data-stu-id="8b817-122">If you are more familiar with a DOM, tree metaphor, or query-based approach towards accessing XML-based technologies, a helpful way to conceptualize a XAML node stream is as follows.</span></span> <span data-ttu-id="8b817-123">假设加载的 XAML 是一个 DOM 或树，其中每个可能的节点均始终展开，然后以线性方式表示。</span><span class="sxs-lookup"><span data-stu-id="8b817-123">Imagine that the loaded XAML is a DOM or a tree where every possible node is expanded all the way, and then presented linearly.</span></span> <span data-ttu-id="8b817-124">通过这些节点时，你可能遇到遍历与 DOM 相关的“输入”或“输出”级别，但 XAML 节点流不会显式跟踪，因为这些级别概念与节点流无关。</span><span class="sxs-lookup"><span data-stu-id="8b817-124">As you advance through the nodes, you might be traversing "in" or "out" of levels that would be relevant to a DOM, but the XAML node stream does not explicitly keep track because these level concepts are not relevant to a node stream.</span></span> <span data-ttu-id="8b817-125">节点流有一个“当前”位置，但当前节点位置以外的节点流的所有特性均不可见，除非你已手动将流的其他特性作为引用存储。</span><span class="sxs-lookup"><span data-stu-id="8b817-125">The node stream has a "current" position, but unless you have stored other parts of the stream yourself as references, every aspect of the node stream other than the current node position is out of view.</span></span>

<span data-ttu-id="8b817-126">XAML 节点流概念具有显著优点，如果你浏览了整个节点流，系统保证你已处理整个 XAML 表示形式；你无需担心处理信息的查询、DOM 操作或一些其他非线性方法遗漏了完整 XAML 表达形式中的某个部分。</span><span class="sxs-lookup"><span data-stu-id="8b817-126">The XAML node stream concept has the notable advantage that if you go through the entire node stream, you are assured that you have processed the entire XAML representation; you do not need to worry that a query, a DOM operation, or some other nonlinear approach to processing information has missed some part of the complete XAML representation.</span></span> <span data-ttu-id="8b817-127">因此，XAML 节点流表示形式非常适合连接 XAML 读取器和 XAML 编写器，还适合于提供一个系统，用于插入在 XAML 处理操作的读取和编写阶段之间运行的进程。</span><span class="sxs-lookup"><span data-stu-id="8b817-127">For this reason, the XAML node stream representation is ideal both for connecting XAML readers and XAML writers, and for providing a system where you can insert your own process that acts between the read and write phases of a XAML processing operation.</span></span> <span data-ttu-id="8b817-128">在很多情况下，XAML 读取器针对顺序可能在源文本、二进制或对象图中显示的方式故意优化了 XAML 节点流中的节点顺序或故意重新进行了排序。</span><span class="sxs-lookup"><span data-stu-id="8b817-128">In many cases, the ordering of nodes in the XAML node stream is deliberately optimized or reordered by XAML readers versus how the order might appear in the source text, binary, or object graph.</span></span> <span data-ttu-id="8b817-129">此行为旨在强制执行 XAML 处理体系结构，以使 XAML 编写器决不位于节点流中它们必须“后退”的位置。</span><span class="sxs-lookup"><span data-stu-id="8b817-129">This behavior is intended to enforce a XAML processing architecture whereby XAML writers are never in a position where they have to go "back" in the node stream.</span></span> <span data-ttu-id="8b817-130">理想情况下，所有 XAML 写入操作都应能够基于架构上下文和节点流的当前位置运行。</span><span class="sxs-lookup"><span data-stu-id="8b817-130">Ideally, all XAML write operations should be able to act based on schema context plus the current position of the node stream.</span></span>

## <a name="a-basic-reading-node-loop"></a><span data-ttu-id="8b817-131">基本读取节点循环</span><span class="sxs-lookup"><span data-stu-id="8b817-131">A Basic Reading Node Loop</span></span>

<span data-ttu-id="8b817-132">用于检查 XAML 节点流的基本读取节点循环包括以下概念。</span><span class="sxs-lookup"><span data-stu-id="8b817-132">A basic reading node loop for examining a XAML node stream consists of the following concepts.</span></span> <span data-ttu-id="8b817-133">为了在本主题中讨论节点循环，假定你正在使用 <xref:System.Xaml.XamlXmlReader>读取基于文本、用户可读的 XAML 文件。</span><span class="sxs-lookup"><span data-stu-id="8b817-133">For purposes of node loops as discussed in this topic, assume that you are reading a text-based, human-readable XAML file using <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="8b817-134">本节中的链接是指 <xref:System.Xaml.XamlXmlReader>实现的特定 XAML 节点循环 API。</span><span class="sxs-lookup"><span data-stu-id="8b817-134">The links in this section refer to the particular XAML node loop API implemented by <xref:System.Xaml.XamlXmlReader>.</span></span>

- <span data-ttu-id="8b817-135">确保你不在 XAML 节点流的末尾（检查 <xref:System.Xaml.XamlXmlReader.IsEof%2A>或使用 <xref:System.Xaml.XamlXmlReader.Read%2A> 返回值）。</span><span class="sxs-lookup"><span data-stu-id="8b817-135">Make sure that you are not at the end of the XAML node stream (check <xref:System.Xaml.XamlXmlReader.IsEof%2A>, or use the <xref:System.Xaml.XamlXmlReader.Read%2A> return value).</span></span> <span data-ttu-id="8b817-136">如果你在流的末尾，此处没有当前节点，你应该退出。</span><span class="sxs-lookup"><span data-stu-id="8b817-136">If you are at the end of the stream, there is no current node and you should exit.</span></span>

- <span data-ttu-id="8b817-137">通过调用 <xref:System.Xaml.XamlXmlReader.NodeType%2A>检查 XAML 节点流中当前公开的节点类型。</span><span class="sxs-lookup"><span data-stu-id="8b817-137">Check what type of node the XAML node stream currently exposes by calling <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span>

- <span data-ttu-id="8b817-138">如果具有直接连接的关联 XAML 对象编写器，此时通常调用 <xref:System.Xaml.XamlWriter.WriteNode%2A> 。</span><span class="sxs-lookup"><span data-stu-id="8b817-138">If you have an associated XAML object writer that is connected directly, you generally call <xref:System.Xaml.XamlWriter.WriteNode%2A> at this point.</span></span>

- <span data-ttu-id="8b817-139">根据报告为当前节点或当前记录的 <xref:System.Xaml.XamlNodeType> ，调用下面的一个操作以获取节点内容的相关信息：</span><span class="sxs-lookup"><span data-stu-id="8b817-139">Based on which <xref:System.Xaml.XamlNodeType> is reported as the current node or current record, call one of the following to obtain information about the node contents:</span></span>

  - <span data-ttu-id="8b817-140">对于 <xref:System.Xaml.XamlXmlReader.NodeType%2A> 或 <xref:System.Xaml.XamlNodeType.StartMember> 的 <xref:System.Xaml.XamlNodeType.EndMember>，调用 <xref:System.Xaml.XamlXmlReader.Member%2A> 以获取成员的相关 <xref:System.Xaml.XamlMember> 信息。</span><span class="sxs-lookup"><span data-stu-id="8b817-140">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartMember> or <xref:System.Xaml.XamlNodeType.EndMember>, call <xref:System.Xaml.XamlXmlReader.Member%2A> to obtain <xref:System.Xaml.XamlMember> information about a member.</span></span> <span data-ttu-id="8b817-141">成员可能为 <xref:System.Xaml.XamlDirective> ，因此可能不一定是前一个对象的常规类型定义成员。</span><span class="sxs-lookup"><span data-stu-id="8b817-141">The member might be a <xref:System.Xaml.XamlDirective>, and thus might not necessarily be a conventional type-defined member of the preceding object.</span></span> <span data-ttu-id="8b817-142">例如，应用于对象的 `x:Name` 显示为 XAML 成员，其中 <xref:System.Xaml.XamlMember.IsDirective%2A> 为 true，成员的 <xref:System.Xaml.XamlMember.Name%2A> 为 `Name`，且其他属性指示此指令在 XAML 语言 XAML 命名空间下。</span><span class="sxs-lookup"><span data-stu-id="8b817-142">For example, `x:Name` applied to an object appears as a XAML member where <xref:System.Xaml.XamlMember.IsDirective%2A> is true and the <xref:System.Xaml.XamlMember.Name%2A> of the member is `Name`, with other properties indicating that this directive is under the XAML language XAML namespace.</span></span>

  - <span data-ttu-id="8b817-143">对于 <xref:System.Xaml.XamlXmlReader.NodeType%2A> 或 <xref:System.Xaml.XamlNodeType.StartObject> 的 <xref:System.Xaml.XamlNodeType.EndObject>，调用 <xref:System.Xaml.XamlXmlReader.Type%2A> 以获取对象的相关 <xref:System.Xaml.XamlType> 信息。</span><span class="sxs-lookup"><span data-stu-id="8b817-143">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartObject> or <xref:System.Xaml.XamlNodeType.EndObject>, call <xref:System.Xaml.XamlXmlReader.Type%2A> to obtain <xref:System.Xaml.XamlType> information about an object.</span></span>

  - <span data-ttu-id="8b817-144">对于 <xref:System.Xaml.XamlXmlReader.NodeType%2A> 的 <xref:System.Xaml.XamlNodeType.Value>，调用 <xref:System.Xaml.XamlXmlReader.Value%2A>。</span><span class="sxs-lookup"><span data-stu-id="8b817-144">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.Value>, call <xref:System.Xaml.XamlXmlReader.Value%2A>.</span></span> <span data-ttu-id="8b817-145">只有节点为成员值的最简单表达式或者对象的初始化文本时，此节点才是一个值（但是，应注意本主题下一节中介绍的类型转换行为）。</span><span class="sxs-lookup"><span data-stu-id="8b817-145">A node is a value only if it is the simplest expression of a value for a member, or the initialization text for an object (however, you should be aware of type conversion behavior as documented in an upcoming section of this topic).</span></span>

  - <span data-ttu-id="8b817-146">对于 <xref:System.Xaml.XamlXmlReader.NodeType%2A> 的 <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>，调用 <xref:System.Xaml.XamlXmlReader.Namespace%2A> ，以获取命名空间节点的命名空间信息。</span><span class="sxs-lookup"><span data-stu-id="8b817-146">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>, call <xref:System.Xaml.XamlXmlReader.Namespace%2A> to obtain namespace information for a namespace node.</span></span>

- <span data-ttu-id="8b817-147">调用 <xref:System.Xaml.XamlXmlReader.Read%2A> ，以使 XAML 读取器前进到 XAML 节点流中的下一个节点，然后重复步骤。</span><span class="sxs-lookup"><span data-stu-id="8b817-147">Call <xref:System.Xaml.XamlXmlReader.Read%2A> to advance the XAML reader to the next node in the XAML node stream, and repeat the steps again.</span></span>

<span data-ttu-id="8b817-148">.NET XAML 服务 XAML 读取器提供的 XAML 节点流始终提供所有可能节点的完整深度遍历。</span><span class="sxs-lookup"><span data-stu-id="8b817-148">The XAML node stream provided by .NET XAML Services XAML readers always provides a full, deep traversal of all possible nodes.</span></span> <span data-ttu-id="8b817-149">XAML 节点循环的典型流控制技术包括在 `while (reader.Read())`中定义正文，和在节点循环的每个节点上打开 <xref:System.Xaml.XamlXmlReader.NodeType%2A> 。</span><span class="sxs-lookup"><span data-stu-id="8b817-149">Typical flow-control techniques for a XAML node loop include defining a body within `while (reader.Read())`, and switching on <xref:System.Xaml.XamlXmlReader.NodeType%2A> at each node point in the node loop.</span></span>

<span data-ttu-id="8b817-150">如果节点流位于文件末尾，则当前节点为 null。</span><span class="sxs-lookup"><span data-stu-id="8b817-150">If the node stream is at end of file, the current node is null.</span></span>

<span data-ttu-id="8b817-151">使用读取器和编写器的最简单的循环类似于以下示例。</span><span class="sxs-lookup"><span data-stu-id="8b817-151">The simplest loop that uses a reader and writer resembles the following example.</span></span>

```csharp
XamlXmlReader xxr = new XamlXmlReader(new StringReader(xamlStringToLoad));
//where xamlStringToLoad is a string of well formed XAML
XamlObjectWriter xow = new XamlObjectWriter(xxr.SchemaContext);
while (xxr.Read()) {
  xow.WriteNode(xxr);
}
```

<span data-ttu-id="8b817-152">此基本示例显示加载路径 XAML 节点循环，以透明方式连接 XAML 读取器和 XAML 编写器，其操作方式与使用 <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>时完全相同。</span><span class="sxs-lookup"><span data-stu-id="8b817-152">This basic example of a load path XAML node loop transparently connects the XAML reader and XAML writer, doing nothing different than if you had used <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b817-153">但此基本结构已扩展为适用于读取或写入方案。</span><span class="sxs-lookup"><span data-stu-id="8b817-153">But this basic structure is then expanded to apply to your reading or writing scenario.</span></span> <span data-ttu-id="8b817-154">一些可能的方案如下所示：</span><span class="sxs-lookup"><span data-stu-id="8b817-154">Some possible scenarios are as follows:</span></span>

- <span data-ttu-id="8b817-155">打开 <xref:System.Xaml.XamlXmlReader.NodeType%2A>。</span><span class="sxs-lookup"><span data-stu-id="8b817-155">Switch on <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span> <span data-ttu-id="8b817-156">执行不同的操作，具体取决于正在读取的节点类型。</span><span class="sxs-lookup"><span data-stu-id="8b817-156">Perform different actions depending on which node type is being read.</span></span>

- <span data-ttu-id="8b817-157">在任何情况下，都不要调用 <xref:System.Xaml.XamlWriter.WriteNode%2A> 。</span><span class="sxs-lookup"><span data-stu-id="8b817-157">Do not call <xref:System.Xaml.XamlWriter.WriteNode%2A> in all cases.</span></span> <span data-ttu-id="8b817-158">仅在某些 <xref:System.Xaml.XamlWriter.WriteNode%2A> 情况下调用 <xref:System.Xaml.XamlXmlReader.NodeType%2A> 。</span><span class="sxs-lookup"><span data-stu-id="8b817-158">Only call <xref:System.Xaml.XamlWriter.WriteNode%2A> in some <xref:System.Xaml.XamlXmlReader.NodeType%2A> cases.</span></span>

- <span data-ttu-id="8b817-159">在特定节点类型的逻辑中，分析此节点的详细信息并操作它。</span><span class="sxs-lookup"><span data-stu-id="8b817-159">Within the logic for a particular node type, analyze the specifics of that node and act on them.</span></span> <span data-ttu-id="8b817-160">例如，只能编写来自特定 XAML 命名空间的对象，然后删除或延迟任何不来自该 XAML 命名空间的对象。</span><span class="sxs-lookup"><span data-stu-id="8b817-160">For example, you could only write objects that come from a particular XAML namespace, and then drop or defer any objects not from that XAML namespace.</span></span> <span data-ttu-id="8b817-161">或者，可以删除或重新处理你的 XAML 系统在处理成员时不支持的任何 XAML 指令。</span><span class="sxs-lookup"><span data-stu-id="8b817-161">Or you could drop or otherwise reprocess any XAML directives that your XAML system does not support as part of your member processing.</span></span>

- <span data-ttu-id="8b817-162">定义可重写 <xref:System.Xaml.XamlObjectWriter> 方法的自定义 `Write*` ，它可能执行绕过 XAML 架构上下文的类型映射。</span><span class="sxs-lookup"><span data-stu-id="8b817-162">Define a custom <xref:System.Xaml.XamlObjectWriter> that overrides `Write*` methods, possibly performing type mapping that bypasses XAML schema context.</span></span>

- <span data-ttu-id="8b817-163">构造 <xref:System.Xaml.XamlXmlReader> 以使用非默认的 XAML 架构上下文，以便 XAML 行为中的自定义差异可兼用于读取器和编写器。</span><span class="sxs-lookup"><span data-stu-id="8b817-163">Construct the <xref:System.Xaml.XamlXmlReader> to use a nondefault XAML schema context, so that customized differences in XAML behavior are used both by the reader and the writer.</span></span>

### <a name="accessing-xaml-beyond-the-node-loop-concept"></a><span data-ttu-id="8b817-164">访问节点循环之外的 XAML 的概念</span><span class="sxs-lookup"><span data-stu-id="8b817-164">Accessing XAML Beyond the Node Loop Concept</span></span>

<span data-ttu-id="8b817-165">除了用作 XAML 节点循环，可能还有其他使用 XAML 表示形式的方式。</span><span class="sxs-lookup"><span data-stu-id="8b817-165">There are potentially other ways to work with a XAML representation other than as a XAML node loop.</span></span> <span data-ttu-id="8b817-166">例如，可能有 XAML 读取器可以读取索引节点，或者特别是直接通过 `x:Name`、 `x:Uid`或其他标识符访问节点。</span><span class="sxs-lookup"><span data-stu-id="8b817-166">For example, there could exist a XAML reader that can read an indexed node, or in particular accesses nodes directly by `x:Name`, by `x:Uid`, or through other identifiers.</span></span> <span data-ttu-id="8b817-167">.NET XAML 服务不提供完整实现，而是通过服务和支持类型提供建议的模式。</span><span class="sxs-lookup"><span data-stu-id="8b817-167">.NET XAML Services does not provide a full implementation, but provides a suggested pattern through services and support types.</span></span> <span data-ttu-id="8b817-168">有关详细信息，请参阅 <xref:System.Xaml.IXamlIndexingReader> 和 <xref:System.Xaml.XamlNodeList>。</span><span class="sxs-lookup"><span data-stu-id="8b817-168">For more information, see <xref:System.Xaml.IXamlIndexingReader> and <xref:System.Xaml.XamlNodeList>.</span></span>

## <a name="working-with-the-current-node"></a><span data-ttu-id="8b817-169">使用当前代码</span><span class="sxs-lookup"><span data-stu-id="8b817-169">Working with the Current Node</span></span>

<span data-ttu-id="8b817-170">使用 XAML 节点循环的大多数方案不仅仅读取节点。</span><span class="sxs-lookup"><span data-stu-id="8b817-170">Most scenarios that use a XAML node loop do not only read the nodes.</span></span> <span data-ttu-id="8b817-171">大多数方案逐一处理当前节点并将每个节点传递到 <xref:System.Xaml.XamlWriter>的实现。</span><span class="sxs-lookup"><span data-stu-id="8b817-171">Most scenarios process current nodes and pass each node one at a time to an implementation of <xref:System.Xaml.XamlWriter>.</span></span>

<span data-ttu-id="8b817-172">在典型的加载路径方案中， <xref:System.Xaml.XamlXmlReader> 生成 XAML 节点流；根据逻辑和 XAML 架构上下文处理 XAML 节点；并将节点传递到 <xref:System.Xaml.XamlObjectWriter>。</span><span class="sxs-lookup"><span data-stu-id="8b817-172">In the typical load path scenario, a <xref:System.Xaml.XamlXmlReader> produces a XAML node stream; the XAML nodes are processed according to your logic and XAML schema context; and the nodes are passed to a <xref:System.Xaml.XamlObjectWriter>.</span></span> <span data-ttu-id="8b817-173">然后，将生成的对象图集成到应用程序或框架中。</span><span class="sxs-lookup"><span data-stu-id="8b817-173">You then integrate the resulting object graph into your application or framework.</span></span>

<span data-ttu-id="8b817-174">在典型的保存路径方案中， <xref:System.Xaml.XamlObjectReader> 读取对象图，系统处理单个 XAML 节点， <xref:System.Xaml.XamlXmlWriter> 将序列化结果作为 XAML 文本文件输出。</span><span class="sxs-lookup"><span data-stu-id="8b817-174">In a typical save path scenario, a <xref:System.Xaml.XamlObjectReader> reads the object graph, individual XAML nodes are processed, and a <xref:System.Xaml.XamlXmlWriter> outputs the serialized result as a XAML text file.</span></span> <span data-ttu-id="8b817-175">关键在于，路径和方案都涉及一次只处理一个 XAML 节点，并且 XAML 节点可按 XAML 类型系统和 the.NET XAML 服务 Api 所定义的标准化方式进行处理。</span><span class="sxs-lookup"><span data-stu-id="8b817-175">The key is that both paths and scenarios involve working with exactly one XAML node at a time, and the XAML nodes are available for treatment in a standardized way that is defined by the XAML type system and the.NET XAML Services APIs.</span></span>

### <a name="frames-and-scope"></a><span data-ttu-id="8b817-176">框架和作用域</span><span class="sxs-lookup"><span data-stu-id="8b817-176">Frames and Scope</span></span>

<span data-ttu-id="8b817-177">XAML 节点循环以线性方式遍历 XAML 节点流。</span><span class="sxs-lookup"><span data-stu-id="8b817-177">A XAML node loop walks through a XAML node stream in a linear way.</span></span> <span data-ttu-id="8b817-178">节点流遍历对象以及包含其他对象的的成员等。</span><span class="sxs-lookup"><span data-stu-id="8b817-178">The node stream traverses into objects, into members that contain other objects, and so on.</span></span> <span data-ttu-id="8b817-179">它通常可用于通过实现框架和堆栈概念跟踪 XAML 节点流内的作用域。</span><span class="sxs-lookup"><span data-stu-id="8b817-179">It is often useful to keep track of scope within the XAML node stream by implementing a frame and stack concept.</span></span> <span data-ttu-id="8b817-180">当你身处其中主动调整节点流时尤其如此。</span><span class="sxs-lookup"><span data-stu-id="8b817-180">This is particularly true if you are actively adjusting the node stream while you are in it.</span></span> <span data-ttu-id="8b817-181">如果在 XAML 节点结构被视为来自 DOM 透视时向下查看到此结构，作为节点循环逻辑的一部分而实现的框架和堆栈支持会计算 `StartObject` （或 `GetObject`）和 `EndObject` 作用域。</span><span class="sxs-lookup"><span data-stu-id="8b817-181">The frame and stack support that you implement as part of your node loop logic could count `StartObject` (or `GetObject`) and `EndObject` scopes as you descend into a XAML node structure if the structure is thought of from a DOM perspective.</span></span>

## <a name="traversing-and-entering-object-nodes"></a><span data-ttu-id="8b817-182">遍历并进入对象节点</span><span class="sxs-lookup"><span data-stu-id="8b817-182">Traversing and Entering Object Nodes</span></span>

<span data-ttu-id="8b817-183">节点流中由 XAML 读取器打开时的第一个节点为根对象的启动对象节点。</span><span class="sxs-lookup"><span data-stu-id="8b817-183">The first node in a node stream when it is opened by a XAML reader is the start-object node of the root object.</span></span> <span data-ttu-id="8b817-184">根据定义，此对象始终是单个对象节点，没有对等节点。</span><span class="sxs-lookup"><span data-stu-id="8b817-184">By definition, this object is always a single object node and has no peers.</span></span> <span data-ttu-id="8b817-185">在所有实际的 XAML 示例中，根对象均被定义为具有多个对象和成员节点的一个或多个属性。</span><span class="sxs-lookup"><span data-stu-id="8b817-185">In any real-world XAML example, the root object is defined to have one or more properties that hold more objects, and these properties have member nodes.</span></span> <span data-ttu-id="8b817-186">而成员节点具有一个或多个对象节点，或者转而只有一个值节点。</span><span class="sxs-lookup"><span data-stu-id="8b817-186">The member nodes then have one or more object nodes, or might also terminate in a value node instead.</span></span> <span data-ttu-id="8b817-187">根对象通常定义 XAML 名称范围，此范围在 XAML 文本标记中按语法分配为属性，但在 XAML 节点流表示形式中映射到 `Namescope` 节点类型。</span><span class="sxs-lookup"><span data-stu-id="8b817-187">The root object typically defines XAML namescopes, which are syntactically assigned as attributes in the XAML text markup but map to a `Namescope` node type in the XAML node stream representation.</span></span>

<span data-ttu-id="8b817-188">请考虑以下 XAML 示例 (这是任意 XAML，不受 .NET) 中的现有类型支持。</span><span class="sxs-lookup"><span data-stu-id="8b817-188">Consider the following XAML example (this is arbitrary XAML, not backed by existing types in .NET).</span></span> <span data-ttu-id="8b817-189">假定在此对象模型中， `FavorCollection` 是 `List<T>` 的 `Favor`， `Balloon` 和 `NoiseMaker` 可分配给 `Favor`， `Balloon.Color` 对象按类似于 WPF 将颜色定义为已知颜色名称的方式支持 `Color` 属性，且 `Color` 支持属性语法的类型转换器。</span><span class="sxs-lookup"><span data-stu-id="8b817-189">Assume that in this object model, `FavorCollection` is `List<T>` of `Favor`, `Balloon` and `NoiseMaker` are assignable to `Favor`, the `Balloon.Color` property is backed by a `Color` object similar to how WPF defines colors as known color names, and `Color` supports a type converter for attribute syntax.</span></span>

|<span data-ttu-id="8b817-190">XAML 标记</span><span class="sxs-lookup"><span data-stu-id="8b817-190">XAML markup</span></span>|<span data-ttu-id="8b817-191">生成的 XAML 节点流</span><span class="sxs-lookup"><span data-stu-id="8b817-191">Resulting XAML node stream</span></span>|
|-----------------|--------------------------------|
|`<Party`|<span data-ttu-id="8b817-192">`Namespace` 的 `Party`</span><span class="sxs-lookup"><span data-stu-id="8b817-192">`Namespace` node for `Party`</span></span>|
|`xmlns="PartyXamlNamespace">`|<span data-ttu-id="8b817-193">`StartObject` 的 `Party`</span><span class="sxs-lookup"><span data-stu-id="8b817-193">`StartObject` node for `Party`</span></span>|
|`<Party.Favors>`|<span data-ttu-id="8b817-194">`StartMember` 的 `Party.Favors`</span><span class="sxs-lookup"><span data-stu-id="8b817-194">`StartMember` node for `Party.Favors`</span></span>|
||<span data-ttu-id="8b817-195">隐式`StartObject` 的 `FavorCollection`节点</span><span class="sxs-lookup"><span data-stu-id="8b817-195">`StartObject` node for implicit `FavorCollection`</span></span>|
||<span data-ttu-id="8b817-196">隐式`StartMember` 项属性的 `FavorCollection` 节点。</span><span class="sxs-lookup"><span data-stu-id="8b817-196">`StartMember` node for implicit `FavorCollection` items property.</span></span>|
|`<Balloon`|<span data-ttu-id="8b817-197">`StartObject` 的 `Balloon`</span><span class="sxs-lookup"><span data-stu-id="8b817-197">`StartObject` node for `Balloon`</span></span>|
|`Color="Red"`|<span data-ttu-id="8b817-198">`StartMember` 的 `Color`</span><span class="sxs-lookup"><span data-stu-id="8b817-198">`StartMember` node for `Color`</span></span><br /><br /> <span data-ttu-id="8b817-199">属性值字符串`Value` 的 `"Red"`节点</span><span class="sxs-lookup"><span data-stu-id="8b817-199">`Value` node for the attribute value string `"Red"`</span></span><br /><br /> <span data-ttu-id="8b817-200">若 `Color`，表示集 `EndMember`</span><span class="sxs-lookup"><span data-stu-id="8b817-200">`EndMember` for `Color`</span></span>|
|`HasHelium="True"`|<span data-ttu-id="8b817-201">`StartMember` 的 `HasHelium`</span><span class="sxs-lookup"><span data-stu-id="8b817-201">`StartMember` node for `HasHelium`</span></span><br /><br /> <span data-ttu-id="8b817-202">属性值字符串`Value` 的 `"True"`节点</span><span class="sxs-lookup"><span data-stu-id="8b817-202">`Value` node for the attribute value string `"True"`</span></span><br /><br /> <span data-ttu-id="8b817-203">若 `HasHelium`，表示集 `EndMember`</span><span class="sxs-lookup"><span data-stu-id="8b817-203">`EndMember` for `HasHelium`</span></span>|
|`>`|<span data-ttu-id="8b817-204">若 `Balloon`，表示集 `EndObject`</span><span class="sxs-lookup"><span data-stu-id="8b817-204">`EndObject` for `Balloon`</span></span>|
|`<NoiseMaker>Loudest</NoiseMaker>`|<span data-ttu-id="8b817-205">`StartObject` 的 `NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="8b817-205">`StartObject` node for `NoiseMaker`</span></span><br /><br /> <span data-ttu-id="8b817-206">`StartMember` 的 `_Initialization`</span><span class="sxs-lookup"><span data-stu-id="8b817-206">`StartMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="8b817-207">初始化值字符串`Value` 的 `"Loudest"`节点</span><span class="sxs-lookup"><span data-stu-id="8b817-207">`Value` node for the initialization value string `"Loudest"`</span></span><br /><br /> <span data-ttu-id="8b817-208">`EndMember` 的 `_Initialization`</span><span class="sxs-lookup"><span data-stu-id="8b817-208">`EndMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="8b817-209">若 `NoiseMaker`，表示集 `EndObject`</span><span class="sxs-lookup"><span data-stu-id="8b817-209">`EndObject` for `NoiseMaker`</span></span>|
||<span data-ttu-id="8b817-210">隐式`EndMember` 项属性的 `FavorCollection` 节点。</span><span class="sxs-lookup"><span data-stu-id="8b817-210">`EndMember` node for implicit `FavorCollection` items property.</span></span>|
||<span data-ttu-id="8b817-211">隐式`EndObject` 的 `FavorCollection`节点</span><span class="sxs-lookup"><span data-stu-id="8b817-211">`EndObject` node for implicit `FavorCollection`</span></span>|
|`</Party.Favors>`|<span data-ttu-id="8b817-212">若 `Favors`，表示集 `EndMember`</span><span class="sxs-lookup"><span data-stu-id="8b817-212">`EndMember` for `Favors`</span></span>|
|`</Party>`|<span data-ttu-id="8b817-213">若 `Party`，表示集 `EndObject`</span><span class="sxs-lookup"><span data-stu-id="8b817-213">`EndObject` for `Party`</span></span>|

<span data-ttu-id="8b817-214">在 XAML 节点流中，可依赖以下行为：</span><span class="sxs-lookup"><span data-stu-id="8b817-214">In the XAML node stream, you can rely on the following behavior:</span></span>

- <span data-ttu-id="8b817-215">如果存在 `Namespace` 节点，将它添加到紧靠用 `StartObject` 声明 XAML 命名空间的 `xmlns`的前面。</span><span class="sxs-lookup"><span data-stu-id="8b817-215">If a `Namespace` node exists, it is added to the stream immediately before the `StartObject` that declared the XAML namespace with `xmlns`.</span></span> <span data-ttu-id="8b817-216">再次查看具有 XAML 和示例节点流的上表。</span><span class="sxs-lookup"><span data-stu-id="8b817-216">Look at the previous table with the XAML and example node stream again.</span></span> <span data-ttu-id="8b817-217">请注意 `StartObject` 和 `Namespace` 节点在文本标记中与其声明位置转置的方式。</span><span class="sxs-lookup"><span data-stu-id="8b817-217">Notice how the `StartObject` and `Namespace` nodes seem to be transposed versus their declaration positions in text markup.</span></span> <span data-ttu-id="8b817-218">此行为表示命名空间节点始终显示在它们在节点流中应用到的节点前面。</span><span class="sxs-lookup"><span data-stu-id="8b817-218">This is representative of the behavior where the namespace nodes always appear ahead of the node they apply to in the node stream.</span></span> <span data-ttu-id="8b817-219">此设计是因为命名空间信息对于对象编写器至关重要，必须在对象编辑器尝试执行类型映射或转而处理对象之前进行了解。</span><span class="sxs-lookup"><span data-stu-id="8b817-219">The purpose of this design is that the namespace information is vital to object writers and must be known before the object writer attempts to perform type mapping or otherwise process the object.</span></span> <span data-ttu-id="8b817-220">将 XANL 命名空间信息置于节点流中其应用程序作用域之前，这使得更容易始终按显示的顺序处理节点流。</span><span class="sxs-lookup"><span data-stu-id="8b817-220">Placing the XAML namespace information ahead of its application scope in the stream makes it simpler to always process the node stream in its presented order.</span></span>

- <span data-ttu-id="8b817-221">由于上述考虑，它是你从头遍历时在大多数实际标记情况中首先读取一个或多个 `Namespace` 节点，而不是根的 `StartObject` 。</span><span class="sxs-lookup"><span data-stu-id="8b817-221">Because of the above consideration, it is one or more `Namespace` nodes that you read first in most real-world markup cases when traversing nodes from the start, not the `StartObject` of the root.</span></span>

- <span data-ttu-id="8b817-222">`StartObject` 节点可后接 `StartMember`、 `Value`，或即时 `EndObject`。</span><span class="sxs-lookup"><span data-stu-id="8b817-222">A `StartObject` node can be followed by `StartMember`, `Value`, or an immediate `EndObject`.</span></span> <span data-ttu-id="8b817-223">决不可紧跟其他 `StartObject`。</span><span class="sxs-lookup"><span data-stu-id="8b817-223">It is never followed immediately by another `StartObject`.</span></span>

- <span data-ttu-id="8b817-224">`StartMember` 可后接 `StartObject`、 `Value`，或即时 `EndMember`。</span><span class="sxs-lookup"><span data-stu-id="8b817-224">A `StartMember` can be followed by a `StartObject`, `Value`, or an immediate `EndMember`.</span></span> <span data-ttu-id="8b817-225">可后接成员的 `GetObject`（其中值应来自父对象的现有值），而不是会实例化新值的 `StartObject` 。</span><span class="sxs-lookup"><span data-stu-id="8b817-225">It can be followed by `GetObject`, for members where the value is supposed to come from an existing value of the parent object rather than a `StartObject` that would instantiate a new value.</span></span> <span data-ttu-id="8b817-226">也可后接应用于下一个 `Namespace` 的 `StartObject`节点。</span><span class="sxs-lookup"><span data-stu-id="8b817-226">It can also be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span> <span data-ttu-id="8b817-227">决不可紧跟其他 `StartMember`。</span><span class="sxs-lookup"><span data-stu-id="8b817-227">It is never followed immediately by another `StartMember`.</span></span>

- <span data-ttu-id="8b817-228">`Value` 节点表示值本身；不存在“EndValue”。</span><span class="sxs-lookup"><span data-stu-id="8b817-228">A `Value` node represents the value itself; there is no "EndValue".</span></span> <span data-ttu-id="8b817-229">后面只能接 `EndMember`。</span><span class="sxs-lookup"><span data-stu-id="8b817-229">It can be followed only by an `EndMember`.</span></span>

  - <span data-ttu-id="8b817-230">对象的 XAML 初始化文本因可能用于构造而不会导致对象-值结构。</span><span class="sxs-lookup"><span data-stu-id="8b817-230">XAML initialization text of the object as might be used by construction does not result in an Object-Value structure.</span></span> <span data-ttu-id="8b817-231">相反，会创建名为 `_Initialization` 的成员的专用成员节点。</span><span class="sxs-lookup"><span data-stu-id="8b817-231">Instead, a dedicated member node for a member named `_Initialization` is created.</span></span> <span data-ttu-id="8b817-232">并且此成员节点包含初始化值字符串。</span><span class="sxs-lookup"><span data-stu-id="8b817-232">and that member node contains the initialization value string.</span></span> <span data-ttu-id="8b817-233">如果存在， `_Initialization` 始终为第一个 `StartMember`。</span><span class="sxs-lookup"><span data-stu-id="8b817-233">If it exists, `_Initialization` is always the first `StartMember`.</span></span> <span data-ttu-id="8b817-234">可使用 XAML 语言 XAML 名称范围在限某些 XAML 服务表示形式中限定`_Initialization` ，以阐明 `_Initialization` 不是后备类型中的定义属性。</span><span class="sxs-lookup"><span data-stu-id="8b817-234">`_Initialization` may be qualified in some XAML services representations with the XAML language XAML namescope, to clarify that `_Initialization` is not a defined property in backing types.</span></span>

  - <span data-ttu-id="8b817-235">成员-值组合表示值的属性设置。</span><span class="sxs-lookup"><span data-stu-id="8b817-235">A Member-Value combination represents an attribute setting of the value.</span></span> <span data-ttu-id="8b817-236">可能最终为处理此值时使用的值转换器，并且值为纯字符串。</span><span class="sxs-lookup"><span data-stu-id="8b817-236">There might eventually be a value converter involved in processing this value, and the value is a plain string.</span></span> <span data-ttu-id="8b817-237">但是，在 XAML 对象编写器处理此节点流后才会计算此值。</span><span class="sxs-lookup"><span data-stu-id="8b817-237">However, that is not evaluated until a XAML object writer processes this node stream.</span></span> <span data-ttu-id="8b817-238">XAML 对象编写器处理必需的 XAML 架构上下文、类型系统映射和值转换器所需的其他支持。</span><span class="sxs-lookup"><span data-stu-id="8b817-238">The XAML object writer possesses the necessary XAML schema context, type system mapping, and other support needed for value conversions.</span></span>

- <span data-ttu-id="8b817-239">`EndMember` 节点可后接后续成员的 `StartMember` 节点或成员所有者的 `EndObject` 节点。</span><span class="sxs-lookup"><span data-stu-id="8b817-239">An `EndMember` node can be followed by a `StartMember` node for a subsequent member, or by an `EndObject` node for the member owner.</span></span>

- <span data-ttu-id="8b817-240">`EndObject` 节点可后接 `EndMember` 节点。</span><span class="sxs-lookup"><span data-stu-id="8b817-240">An `EndObject` node can be followed by an `EndMember` node.</span></span> <span data-ttu-id="8b817-241">在对象在集合的项中成对出现的情况中，还可后接 `StartObject` 节点。</span><span class="sxs-lookup"><span data-stu-id="8b817-241">It can also be followed by a `StartObject` node for cases where the objects are peers in a collection's items.</span></span> <span data-ttu-id="8b817-242">或者，可后接应用于下一个 `Namespace` 的 `StartObject`节点。</span><span class="sxs-lookup"><span data-stu-id="8b817-242">Or it can be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span>

  - <span data-ttu-id="8b817-243">对于关闭整个节点流的独特情况，根的 `EndObject` 后面不接任何内容；此时读取器位于文件结尾，且 <xref:System.Xaml.XamlReader.Read%2A> 返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="8b817-243">For the unique case of closing the entire node stream, the `EndObject` of the root is not followed by anything; the reader is now end-of-file, and <xref:System.Xaml.XamlReader.Read%2A> returns `false`.</span></span>

## <a name="value-converters-and-the-xaml-node-stream"></a><span data-ttu-id="8b817-244">值转换器和 XAML 节点流</span><span class="sxs-lookup"><span data-stu-id="8b817-244">Value Converters and the XAML Node Stream</span></span>

<span data-ttu-id="8b817-245">值转换器是用于标记扩展、类型转换器（包括值序列化程序）或通过 XAML 类型系统报告为值转换器的其他专用类的常用术语。</span><span class="sxs-lookup"><span data-stu-id="8b817-245">A value converter is a general term for a markup extension, a type converter (including value serializers) or another dedicated class that is reported as a value converter through the XAML type system.</span></span> <span data-ttu-id="8b817-246">在 XAML 节点流中，类型转换器用法和标记扩展用法的表示形式非常迥异。</span><span class="sxs-lookup"><span data-stu-id="8b817-246">In the XAML node stream, a type converter usage and a markup extension usage have very different representations.</span></span>

### <a name="type-converters-in-the-xaml-node-stream"></a><span data-ttu-id="8b817-247">XAML 节点流中的类型转换器</span><span class="sxs-lookup"><span data-stu-id="8b817-247">Type Converters in the XAML Node Stream</span></span>

<span data-ttu-id="8b817-248">最终生成类型转换器用法的属性设置将在 XAML 节点流中报告为成员的值。</span><span class="sxs-lookup"><span data-stu-id="8b817-248">An attribute set that eventually results in a type converter usage is reported in the XAML node stream as a value of a member.</span></span> <span data-ttu-id="8b817-249">XAML 节点流不会尝试生成类型转换器实例对象，也不会将值传递给它。</span><span class="sxs-lookup"><span data-stu-id="8b817-249">The XAML node stream does not attempt to produce a type converter instance object and pass the value to it.</span></span> <span data-ttu-id="8b817-250">若要使用类型转换器的转换实现，需要调用 XAML 架构上下文并将其用于映射类型。</span><span class="sxs-lookup"><span data-stu-id="8b817-250">Using a type converter's conversion implementation requires invoking the XAML schema context and using it for type-mapping.</span></span> <span data-ttu-id="8b817-251">甚至确定应使用哪个类型转换器类处理值也间接需要 XAML 架构上下文。</span><span class="sxs-lookup"><span data-stu-id="8b817-251">Even determining which type converter class should be used to process the value requires the XAML schema context indirectly.</span></span> <span data-ttu-id="8b817-252">使用默认 XAML 架构上下文时，XAML 类型系统可提供此信息。</span><span class="sxs-lookup"><span data-stu-id="8b817-252">When you use the default XAML schema context, that information is available from the XAML type system.</span></span> <span data-ttu-id="8b817-253">如果在连接到 XAML 编写器前需要 XAML 节点流级别的类型转换器类信息，可以从要设置的成员的 <xref:System.Xaml.XamlMember> 信息中获取。</span><span class="sxs-lookup"><span data-stu-id="8b817-253">If you need the type converter class information at the XAML node stream level before connection to a XAML writer, you can obtain it from the <xref:System.Xaml.XamlMember> information of the member being set.</span></span> <span data-ttu-id="8b817-254">否则，类型转换器输入应作为纯值保留在 XAML 节点流中，直到执行需要类型映射系统和 XAML 架构上下文的剩余操作（例如由 XAML 对象编写器创建对象）。</span><span class="sxs-lookup"><span data-stu-id="8b817-254">But otherwise, type converter input should be preserved in the XAML node stream as a plain value until the remainder of operations that require the type-mapping system and XAML schema context are performed, for example the object creation by a XAML object writer.</span></span>

<span data-ttu-id="8b817-255">例如，请注意下面的类定义大纲和它的 XAML 用法：</span><span class="sxs-lookup"><span data-stu-id="8b817-255">For example, consider the following class definition outline and XAML usage for it:</span></span>

```csharp
public class BoardSizeConverter : TypeConverter {
  //converts from string to an int[2] by splitting on an "x" char
}
public class GameBoard {
  [TypeConverter(typeof(BoardSizeConverter))]
  public int[] BoardSize; //2x2 array, initialization not shown
}
```

```xaml
<GameBoard BoardSize="8x8"/>
```

<span data-ttu-id="8b817-256">此用法的 XAML 节点流的文本表示形式可如下所示：</span><span class="sxs-lookup"><span data-stu-id="8b817-256">A text representation of the XAML node stream for this usage could be expressed as the following:</span></span>

<span data-ttu-id="8b817-257">`StartObject` ，带有表示 <xref:System.Xaml.XamlType> 的 `GameBoard`</span><span class="sxs-lookup"><span data-stu-id="8b817-257">`StartObject` with <xref:System.Xaml.XamlType> representing `GameBoard`</span></span>

<span data-ttu-id="8b817-258">`StartMember` ，带有表示 <xref:System.Xaml.XamlMember> 的 `BoardSize`</span><span class="sxs-lookup"><span data-stu-id="8b817-258">`StartMember` with <xref:System.Xaml.XamlMember> representing `BoardSize`</span></span>

<span data-ttu-id="8b817-259">`Value` 节点，带有文本字符串“`8x8`”</span><span class="sxs-lookup"><span data-stu-id="8b817-259">`Value` node, with text string "`8x8`"</span></span>

<span data-ttu-id="8b817-260">`EndMember` 与 `BoardSize`</span><span class="sxs-lookup"><span data-stu-id="8b817-260">`EndMember` matches `BoardSize`</span></span>

<span data-ttu-id="8b817-261">`EndObject` 与 `GameBoard`</span><span class="sxs-lookup"><span data-stu-id="8b817-261">`EndObject` matches `GameBoard`</span></span>

<span data-ttu-id="8b817-262">请注意此节点流中没有任何类型转换器实例。</span><span class="sxs-lookup"><span data-stu-id="8b817-262">Notice that there is no type converter instance in this node stream.</span></span> <span data-ttu-id="8b817-263">但可以通过调用 <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> 的 <xref:System.Xaml.XamlMember> 上的 `BoardSize`获取类型转换器信息。</span><span class="sxs-lookup"><span data-stu-id="8b817-263">But you can get type converter information by calling <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> on the <xref:System.Xaml.XamlMember> for `BoardSize`.</span></span> <span data-ttu-id="8b817-264">如果具有有效的 XAML 架构上下文，也可通过获取 <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>中的实例来调用转换器方法。</span><span class="sxs-lookup"><span data-stu-id="8b817-264">If you have a valid XAML schema context, you can also invoke the converter methods by obtaining an instance from <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.</span></span>

### <a name="markup-extensions-in-the-xaml-node-stream"></a><span data-ttu-id="8b817-265">XAML 节点流中的标记扩展</span><span class="sxs-lookup"><span data-stu-id="8b817-265">Markup Extensions in the XAML Node Stream</span></span>

<span data-ttu-id="8b817-266">标记扩展用法在 XAML 节点流中报告为成员中的对象节点，其中对象表示标记扩展实例。</span><span class="sxs-lookup"><span data-stu-id="8b817-266">A markup extension usage is reported in the XAML node stream as an object node within a member, where the object represents a markup extension instance.</span></span> <span data-ttu-id="8b817-267">因此标记扩展用法在节点流表示形式中比类型转换器用法表示得更为显式，并且具备更多信息。</span><span class="sxs-lookup"><span data-stu-id="8b817-267">Thus a markup extension usage is presented more explicitly in the node stream representation than a type converter usage is, and carries more information.</span></span> <span data-ttu-id="8b817-268"><xref:System.Xaml.XamlMember> 信息不包含标记扩展的任何相关信息，因为用法因情况而定，在每个可能的标记情况中都有不同；它与类型转换器的情况不同，不专用于每个类型或成员，也不是隐式的。</span><span class="sxs-lookup"><span data-stu-id="8b817-268"><xref:System.Xaml.XamlMember> information could not have told you anything about the markup extension, because the usage is situational and varies in each possible markup case; it is not dedicated and implicit per type or member as is the case with type converters.</span></span>

<span data-ttu-id="8b817-269">即使在 XAML 文本标记的属性中生成标记扩展用法（通常如此），标记扩展中作为对象节点的节点流表示形式也是上述情况。</span><span class="sxs-lookup"><span data-stu-id="8b817-269">The node stream representation of markup extensions as object nodes is the case even if the markup extension usage was made in attribute form in the XAML text markup (which is often the case).</span></span> <span data-ttu-id="8b817-270">使用显式对象元素窗体的标记扩展用法以相同方式处理。</span><span class="sxs-lookup"><span data-stu-id="8b817-270">Markup extension usages that used an explicit object element form are treated the same way.</span></span>

<span data-ttu-id="8b817-271">在标记扩展对象节点中，可能存在此标记扩展的成员。</span><span class="sxs-lookup"><span data-stu-id="8b817-271">Within a markup extension object node, there may be members of that markup extension.</span></span> <span data-ttu-id="8b817-272">无论此标记扩展的用法是位置参数用法还是具有显式命名参数的用法，XAML 节点流表示形式都会保留它。</span><span class="sxs-lookup"><span data-stu-id="8b817-272">The XAML node stream representation preserves the usage of that markup extension, whether that be a positional parameter usage or a usage with explicit named parameters.</span></span>

<span data-ttu-id="8b817-273">对于位置参数用法，XAML 节点流包含一个 XAML 语言定义的记录用法的属性 `_PositionalParameters` 。</span><span class="sxs-lookup"><span data-stu-id="8b817-273">For a positional parameter usage, the XAML node stream contains a XAML language-defined property `_PositionalParameters` that records the usage.</span></span> <span data-ttu-id="8b817-274">此属性是带有 <xref:System.Collections.Generic.List%601> 约束的泛型 <xref:System.Object> 。</span><span class="sxs-lookup"><span data-stu-id="8b817-274">This property is a generic <xref:System.Collections.Generic.List%601> with <xref:System.Object> constraint.</span></span> <span data-ttu-id="8b817-275">此约束是对象而不是字符串，因为位置参数用法一定内含嵌套标记扩展用法。</span><span class="sxs-lookup"><span data-stu-id="8b817-275">The constraint is object and not string because conceivably a positional parameter usage could contain nested markup extension usages within it.</span></span> <span data-ttu-id="8b817-276">若要从用法中访问位置参数，可以循环访问列表并使用单个列表值的索引器。</span><span class="sxs-lookup"><span data-stu-id="8b817-276">To access the positional parameters from the usage, you could iterate through the list and use the indexers for individual list values.</span></span>

<span data-ttu-id="8b817-277">对于命名参数用法，每个命名参数表示为节点流中此名称的成员节点。</span><span class="sxs-lookup"><span data-stu-id="8b817-277">For a named parameter usage, each named parameter is represented as a member node of that name in the node stream.</span></span> <span data-ttu-id="8b817-278">成员值不一定是字符串，因为可能存在嵌套标记扩展用法。</span><span class="sxs-lookup"><span data-stu-id="8b817-278">The member values are not necessarily strings, because there could be a nested markup extension usage.</span></span>

<span data-ttu-id="8b817-279">尚未调用标记扩展的`ProvideValue` 。</span><span class="sxs-lookup"><span data-stu-id="8b817-279">`ProvideValue` from the markup extension is not yet invoked.</span></span> <span data-ttu-id="8b817-280">但是，如果连接了 XAML 读取器和 XAML 编写器则进行调用，以便在节点系统中检查它时在标记扩展节点上调用 `WriteEndObject` 。</span><span class="sxs-lookup"><span data-stu-id="8b817-280">However, it is invoked if you connect a XAML reader and XAML writer so that `WriteEndObject` is invoked on the markup extension node when you examine it in the node stream.</span></span> <span data-ttu-id="8b817-281">为此，通常需要提供与在加载路径上形成对象图时所用的 XAML 架构上下文相同的上下文。</span><span class="sxs-lookup"><span data-stu-id="8b817-281">For this reason, you generally need the same XAML schema context available as would be used in order to form the object graph on the load path.</span></span> <span data-ttu-id="8b817-282">否则，任何标记扩展的 `ProvideValue` 都可在此引发异常，因为它没有可用的预期服务。</span><span class="sxs-lookup"><span data-stu-id="8b817-282">Otherwise, `ProvideValue` from any markup extension can throw exceptions here, because it does not have expected services available.</span></span>

## <a name="xaml-and-xml-language-defined-members-in-the-xaml-node-stream"></a><span data-ttu-id="8b817-283">XAML 节点流中 XAML 和 XML 语言定义的成员</span><span class="sxs-lookup"><span data-stu-id="8b817-283">XAML and XML Language-Defined Members in the XAML Node Stream</span></span>

<span data-ttu-id="8b817-284">特定成员由于 XAML 读取器的解释和约定而引入到 XAML 节点流，而不是通过显式 <xref:System.Xaml.XamlMember> 查找或构造引入。</span><span class="sxs-lookup"><span data-stu-id="8b817-284">Certain members are introduced to a XAML node stream because of interpretations and conventions of a XAML reader, instead of through an explicit <xref:System.Xaml.XamlMember> lookup or construction.</span></span> <span data-ttu-id="8b817-285">通常，这些成员均为 XAML 指令。</span><span class="sxs-lookup"><span data-stu-id="8b817-285">Often, these members are XAML directives.</span></span> <span data-ttu-id="8b817-286">在某些情况下，它是读取 XAML 的操作，用于将指令引入 XAML 节点流。</span><span class="sxs-lookup"><span data-stu-id="8b817-286">In some cases, it is the act of reading the XAML that introduces the directive into the XAML node stream.</span></span> <span data-ttu-id="8b817-287">换句话说，原始输入 XAML 文本未显式指定成员指令，但 XAML 读取器插入指令以满足结构 XAML 约定并在此信息丢失前报告 XAML 节点流中的信息。</span><span class="sxs-lookup"><span data-stu-id="8b817-287">In other words, the original input XAML text did not explicitly specify the member directive, but the XAML reader inserts the directive in order to satisfy a structural XAML convention and report information in the XAML node stream before that information is lost.</span></span>

<span data-ttu-id="8b817-288">以下列表说明了需要 XAML 读取器引入指令 XAML 成员节点的所有情况，以及如何在 .NET XAML 服务实现中标识该成员节点。</span><span class="sxs-lookup"><span data-stu-id="8b817-288">The following list notes all cases where a XAML reader is expected to introduce a directive XAML member node, and how that member node is identified in .NET XAML Services implementations.</span></span>

- <span data-ttu-id="8b817-289">**对象节点的初始化文本：** 此成员节点的名称是 `_Initialization`，它表示 XAML 指令，并且在 XAML 语言 XAML 命名空间中进行定义。</span><span class="sxs-lookup"><span data-stu-id="8b817-289">**Initialization text for an object node:** The name of this member node is `_Initialization`, it represents a XAML directive, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="8b817-290">可从 <xref:System.Xaml.XamlLanguage.Initialization%2A>中获取它的静态实体。</span><span class="sxs-lookup"><span data-stu-id="8b817-290">You can get a static entity for it from <xref:System.Xaml.XamlLanguage.Initialization%2A>.</span></span>

- <span data-ttu-id="8b817-291">**标记扩展的位置参数：** 此成员节点的名称是 `_PositionalParameters`，并且它在 XAML 语言 XAML 命名空间中进行定义。</span><span class="sxs-lookup"><span data-stu-id="8b817-291">**Positional parameters for a markup extension:** The name of this member node is `_PositionalParameters`, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="8b817-292">它始终包含对象的泛型列表，其中每个对象都是通过以输入 XAML 提供的 `,` 分隔符拆分而预先分隔的位置参数。</span><span class="sxs-lookup"><span data-stu-id="8b817-292">It always contains a generic list of objects, each of which is a positional parameter pre-separated by splitting on the `,` delimiter character as supplied in the input XAML.</span></span> <span data-ttu-id="8b817-293">可从 <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>中获取位置参数指令的静态实体。</span><span class="sxs-lookup"><span data-stu-id="8b817-293">You can get a static entity for the positional parameters directive from <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.</span></span>

- <span data-ttu-id="8b817-294">**未知内容：** 此成员节点的名称是 `_UnknownContent`。</span><span class="sxs-lookup"><span data-stu-id="8b817-294">**Unknown content:** The name of this member node is `_UnknownContent`.</span></span> <span data-ttu-id="8b817-295">严格地说，它是 <xref:System.Xaml.XamlDirective>，并且在 XAML 语言 XAML 命名空间中定义。</span><span class="sxs-lookup"><span data-stu-id="8b817-295">Strictly speaking, it is a <xref:System.Xaml.XamlDirective>, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="8b817-296">在 XAML 对象元素包含源 XAML 中的内容但当前可用的 XAML 架构上下文中无法确认任何内容属性的情况下，此指令用作 sentinel。</span><span class="sxs-lookup"><span data-stu-id="8b817-296">This directive is used as a sentinel for cases where a XAML object element contains content in the source XAML but no content property can be determined under the currently available XAML schema context.</span></span> <span data-ttu-id="8b817-297">可通过检查名为 `_UnknownContent`的成员，在 XAML 节点流中检测此类情况。</span><span class="sxs-lookup"><span data-stu-id="8b817-297">You can detect this case in a XAML node stream by checking for members named `_UnknownContent`.</span></span> <span data-ttu-id="8b817-298">如果加载路径 XAML 节点流中未执行其他操作，在遇到任何对象的 <xref:System.Xaml.XamlObjectWriter> 成员时将在尝试的 `WriteEndObject` 上引发默认 `_UnknownContent` 。</span><span class="sxs-lookup"><span data-stu-id="8b817-298">If no other action is taken in a load path XAML node stream, the default <xref:System.Xaml.XamlObjectWriter> throws on attempted `WriteEndObject` when it encounters the `_UnknownContent` member on any object.</span></span> <span data-ttu-id="8b817-299">默认 <xref:System.Xaml.XamlXmlWriter> 不会引发，并将成员视为隐式。</span><span class="sxs-lookup"><span data-stu-id="8b817-299">The default <xref:System.Xaml.XamlXmlWriter> does not throw, and treats the member as implicit.</span></span> <span data-ttu-id="8b817-300">可以从 `_UnknownContent` 中获取 <xref:System.Xaml.XamlLanguage.UnknownContent%2A>的静态实体。</span><span class="sxs-lookup"><span data-stu-id="8b817-300">You can get a static entity for `_UnknownContent` from <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.</span></span>

- <span data-ttu-id="8b817-301">**集合的集合属性：** 虽然用于 XAML 的集合类的后备 CLR 类型通常具有一个专用命名属性，该属性包含收集项，但在实现类型解析之前，XAML 类型系统不知道该属性。</span><span class="sxs-lookup"><span data-stu-id="8b817-301">**Collection property of a collection:** Although the backing CLR type of a collection class that is used for XAML usually has a dedicated named property that holds the collection items, that property is not known to a XAML type system prior to backing type resolution.</span></span> <span data-ttu-id="8b817-302">相反，XAML 节点流引入 `Items` 占位符作为集合 XAML 类型的成员。</span><span class="sxs-lookup"><span data-stu-id="8b817-302">Instead, the XAML node stream introduces an `Items` placeholder as a member of the collection XAML type.</span></span> <span data-ttu-id="8b817-303">在 .NET XAML 服务实现中，节点流中此指令或成员的名称为 `_Items` 。</span><span class="sxs-lookup"><span data-stu-id="8b817-303">In .NET XAML Services implementation, the name of this directive or member in the node stream is `_Items`.</span></span> <span data-ttu-id="8b817-304">可以从 <xref:System.Xaml.XamlLanguage.Items%2A>中获取此指令的常量。</span><span class="sxs-lookup"><span data-stu-id="8b817-304">A constant for this directive can be obtained from <xref:System.Xaml.XamlLanguage.Items%2A>.</span></span>

    <span data-ttu-id="8b817-305">请注意，XAML 节点流可能包含 Items 属性，其中的项不能基于支持类型解析和 XAML 架构上下文进行分析。</span><span class="sxs-lookup"><span data-stu-id="8b817-305">Note that a XAML node stream might contain an Items property with items that turn out to not be parsable based on the backing type resolution and XAML schema context.</span></span> <span data-ttu-id="8b817-306">例如，应用于对象的</span><span class="sxs-lookup"><span data-stu-id="8b817-306">For example,</span></span>

- <span data-ttu-id="8b817-307">**XML 定义的成员：**`xml:base` `xml:lang` `xml:space` `base` `lang` `space` 在 .NET XAML 服务实现中，XML 定义的、和成员被报告为名为、和的 XAML 指令。</span><span class="sxs-lookup"><span data-stu-id="8b817-307">**XML-defined members:** The XML-defined `xml:base`, `xml:lang` and `xml:space` members are reported as XAML directives named `base`, `lang`, and `space` in .NET XAML Services implementations.</span></span> <span data-ttu-id="8b817-308">这些成员的命名空间是指 XML 命名空间 `http://www.w3.org/XML/1998/namespace`。</span><span class="sxs-lookup"><span data-stu-id="8b817-308">The namespace for these is the XML namespace `http://www.w3.org/XML/1998/namespace`.</span></span> <span data-ttu-id="8b817-309">其中每个成员的常量都可从 <xref:System.Xaml.XamlLanguage>获取。</span><span class="sxs-lookup"><span data-stu-id="8b817-309">Constants for each of these can be obtained from <xref:System.Xaml.XamlLanguage>.</span></span>

## <a name="node-order"></a><span data-ttu-id="8b817-310">节点顺序</span><span class="sxs-lookup"><span data-stu-id="8b817-310">Node Order</span></span>

<span data-ttu-id="8b817-311">在某些情况下， <xref:System.Xaml.XamlXmlReader> 会根据在标记中查看或处理为 XML 时节点显示的顺序更改 XAML 节点流中的 XAML 节点顺序。</span><span class="sxs-lookup"><span data-stu-id="8b817-311">In some cases, <xref:System.Xaml.XamlXmlReader> changes the order of XAML nodes in the XAML node stream, versus the order the nodes appear if viewed in the markup or if processed as XML.</span></span> <span data-ttu-id="8b817-312">这是为了对节点进行排序，以便 <xref:System.Xaml.XamlObjectWriter> 可以仅向前的方式处理节点流。</span><span class="sxs-lookup"><span data-stu-id="8b817-312">This is done in order to order the nodes such that a <xref:System.Xaml.XamlObjectWriter> can process the node stream in a forward-only manner.</span></span>  <span data-ttu-id="8b817-313">在 .NET XAML 服务中，XAML 读取器会重新对节点进行排序，而不是将此任务留给 XAML 编写器，作为节点流的 XAML 对象编写器使用者的性能优化。</span><span class="sxs-lookup"><span data-stu-id="8b817-313">In .NET XAML Services, the XAML reader reorders nodes rather than leaving this task to the XAML writer, as a performance optimization for XAML object writer consumers of the node stream.</span></span>

<span data-ttu-id="8b817-314">某些指令专用于提供从对象元素创建对象所需的详细信息。</span><span class="sxs-lookup"><span data-stu-id="8b817-314">Certain directives are intended specifically to provide more information for the creation of an object from an object element.</span></span> <span data-ttu-id="8b817-315">这些指令包括： `Initialization`、 `PositionalParameters`、 `TypeArguments`、 `FactoryMethod`、 `Arguments`。</span><span class="sxs-lookup"><span data-stu-id="8b817-315">These directives are: `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`.</span></span> <span data-ttu-id="8b817-316">.NET XAML 服务 XAML 读取器尝试将这些指令作为对象的后的节点流中的第一个成员 `StartObject` ，出于下一节中所述的原因。</span><span class="sxs-lookup"><span data-stu-id="8b817-316">.NET XAML Services XAML readers attempt to place these directives as the first members in the node stream following an object's `StartObject`, for reasons that are explained in the next section.</span></span>

### <a name="xamlobjectwriter-behavior-and-node-order"></a><span data-ttu-id="8b817-317">XamlObjectWriter 行为和节点顺序</span><span class="sxs-lookup"><span data-stu-id="8b817-317">XamlObjectWriter Behavior and Node Order</span></span>

<span data-ttu-id="8b817-318">`StartObject` 的 <xref:System.Xaml.XamlObjectWriter> 不一定是指示 XAML 对象编写器立即构造对象实例的信号。</span><span class="sxs-lookup"><span data-stu-id="8b817-318">`StartObject` to a <xref:System.Xaml.XamlObjectWriter> is not necessarily a signal to the XAML object writer to immediately construct the object instance.</span></span> <span data-ttu-id="8b817-319">XAML 包括多种语言功能，使您可以使用附加输入初始化对象，并且不完全依赖于调用无参数构造函数来生成初始对象，而只是设置属性。</span><span class="sxs-lookup"><span data-stu-id="8b817-319">XAML includes several language features that make it possible to initialize an object with additional input, and to not rely entirely on invoking a parameterless constructor to produce the initial object, and only then setting properties.</span></span> <span data-ttu-id="8b817-320">这些功能包括： <xref:System.Windows.Markup.XamlDeferLoadAttribute>；初始化文本； [x:TypeArguments](xtypearguments-directive.md)；标记扩展的位置参数；工厂方法和关联的 [x:arguments](xarguments-directive.md) 节点（XAML 2009 年）。</span><span class="sxs-lookup"><span data-stu-id="8b817-320">These features include: <xref:System.Windows.Markup.XamlDeferLoadAttribute>; initialization text; [x:TypeArguments](xtypearguments-directive.md); positional parameters of a markup extension; factory methods and associated [x:Arguments](xarguments-directive.md) nodes (XAML 2009).</span></span> <span data-ttu-id="8b817-321">其中每种情况都会延迟实际的对象构造，并且由于节点流重新排序，XAML 对象编写器可以依赖于实际构造实例的行为，这种情况下，每次都不是该对象类型的构造指令。</span><span class="sxs-lookup"><span data-stu-id="8b817-321">Each of these cases delays the actual object construction, and because the node stream is reordered, the XAML object writer can rely on a behavior of actually constructing the instance whenever a start member is encountered that is not specifically a construction directive for that object type.</span></span>

### <a name="getobject"></a><span data-ttu-id="8b817-322">GetObject</span><span class="sxs-lookup"><span data-stu-id="8b817-322">GetObject</span></span>

<span data-ttu-id="8b817-323">`GetObject` 表示 XAML 节点，其中 XAML 对象编写器应转而获取对象的包含属性的值，而不是构造新对象。</span><span class="sxs-lookup"><span data-stu-id="8b817-323">`GetObject` represents a XAML node where rather than constructing a new object, a XAML object writer should instead get the value of the object's containing property.</span></span> <span data-ttu-id="8b817-324">当包含属性在后备类型的对象模型中不是故意为只读时，在 XAML 节点流中遇到 `GetObject` 节点的一种典型情况是针对集合对象或字典对象。</span><span class="sxs-lookup"><span data-stu-id="8b817-324">A typical  case where a `GetObject` node is encountered in a XAML node stream is for a collection object or a dictionary object, when the containing property is deliberately read-only in the backing type's object model.</span></span> <span data-ttu-id="8b817-325">在此情况中，通常由拥有类型的初始化逻辑创建和初始化（通常为空）集合或字典。</span><span class="sxs-lookup"><span data-stu-id="8b817-325">In this scenario, the collection or dictionary often is created and initialized (usually empty) by the initialization logic of an owning type.</span></span>

## <a name="see-also"></a><span data-ttu-id="8b817-326">另请参阅</span><span class="sxs-lookup"><span data-stu-id="8b817-326">See also</span></span>

- <xref:System.Xaml.XamlObjectReader>
- [<span data-ttu-id="8b817-327">XAML 服务</span><span class="sxs-lookup"><span data-stu-id="8b817-327">XAML Services</span></span>](index.md)
- [<span data-ttu-id="8b817-328">XAML 命名空间</span><span class="sxs-lookup"><span data-stu-id="8b817-328">XAML Namespaces</span></span>](namespaces.md)
