---
title: XAMLServices 类和基本的 XAML 读取或写入
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [XAML Services], XamlServices class
- XamlServices class [XAML Services], how to use
ms.assetid: 6ac27fad-3687-4d7a-add1-3e90675fdfde
ms.openlocfilehash: b88813b099a2e0ccfe7a8bd24156d8addb4631e9
ms.sourcegitcommit: 9f6df084c53a3da0ea657ed0d708a72213683084
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/09/2020
ms.locfileid: "96974028"
---
# <a name="xamlservices-class-and-basic-xaml-reading-or-writing"></a><span data-ttu-id="d6f5f-102">XAMLServices 类和基本的 XAML 读取或写入</span><span class="sxs-lookup"><span data-stu-id="d6f5f-102">XAMLServices class and basic XAML reading or writing</span></span>

<span data-ttu-id="d6f5f-103"><xref:System.Xaml.XamlServices> 是由 .NET 提供的一个类，可用于解决无需对 XAML 节点流的特定访问权限的 XAML 方案或从这些节点获取的 XAML 类型系统信息。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-103"><xref:System.Xaml.XamlServices> is a class provided by .NET that can be used to address XAML scenarios that don't require specific access to the XAML node stream or to XAML type system information obtained from those nodes.</span></span> <span data-ttu-id="d6f5f-104"><xref:System.Xaml.XamlServices> API 可以按如下所示进行汇总： `Load` 或 `Parse` 以支持 xaml 加载路径， `Save` 以支持 xaml 保存路径，以及 `Transform` 提供联接加载路径和保存路径的技术。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-104"><xref:System.Xaml.XamlServices> API can be summarized as follows: `Load` or `Parse` to support a XAML load path, `Save` to support a XAML save path, and `Transform` to provide a technique that joins a load path and save path.</span></span> <span data-ttu-id="d6f5f-105">`Transform` 可用于从一个 XAML 架构更改为另一个。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-105">`Transform` can be used to change from one XAML schema to another.</span></span> <span data-ttu-id="d6f5f-106">本主题总结了每个 API 分类，并介绍了特定方法重载之间的差异。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-106">This topic summarizes each of these API classifications and describes the differences between particular method overloads.</span></span>

## <a name="load"></a><span data-ttu-id="d6f5f-107">加载</span><span class="sxs-lookup"><span data-stu-id="d6f5f-107">Load</span></span>

<span data-ttu-id="d6f5f-108">各种 <xref:System.Xaml.XamlServices.Load%2A> 重载实现了加载路径的完整逻辑。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-108">Various overloads of <xref:System.Xaml.XamlServices.Load%2A> implement the complete logic for a load path.</span></span> <span data-ttu-id="d6f5f-109">加载路径以某种形式使用 XAML，并输出 XAML 节点流。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-109">The load path uses XAML in some form and outputs a XAML node stream.</span></span> <span data-ttu-id="d6f5f-110">其中的大部分加载路径使用一种编码的 XML 文本文件格式的 XAML。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-110">Most of these load paths use XAML in an encoded XML text-file form.</span></span> <span data-ttu-id="d6f5f-111">但是，你也可以加载常规流，或者加载已包含在另一个 <xref:System.Xaml.XamlReader> 实现中的预加载 XAML 源。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-111">However, you can also load a general stream, or you can load a preloaded XAML source that is already contained in a different <xref:System.Xaml.XamlReader> implementation.</span></span>

<span data-ttu-id="d6f5f-112">适用于大多数方案的最简单的重载是 <xref:System.Xaml.XamlServices.Load%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-112">The simplest overload for most scenarios is <xref:System.Xaml.XamlServices.Load%28System.String%29>.</span></span> <span data-ttu-id="d6f5f-113">此重载具有 `fileName` 参数，它仅是文本文件的名称，该文件包含要加载的 XAML。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-113">This overload has a `fileName` parameter that is simply the name of a text file that contains the XAML to load.</span></span> <span data-ttu-id="d6f5f-114">这适用于应用程序方案，如具有本地计算机之前序列化的状态或数据的完全信任应用程序。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-114">This is appropriate for application scenarios such as full trust applications that have previously serialized state or data to the local computer.</span></span> <span data-ttu-id="d6f5f-115">这也对框架有用，你正在其中定义应用程序模型并想要加载一个标准文件，这些标准文件定义应用程序行为、启动 UI 或其他使用 XAML 的框架定义的功能。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-115">This is also useful for frameworks where you are defining the application model and want to load one of the standard files that defines application behavior, starting UI, or other framework-defined capabilities that use XAML.</span></span>

<span data-ttu-id="d6f5f-116"><xref:System.Xaml.XamlServices.Load%28System.IO.Stream%29> 具有类似的方案。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-116"><xref:System.Xaml.XamlServices.Load%28System.IO.Stream%29> has similar scenarios.</span></span> <span data-ttu-id="d6f5f-117">如果你让用户选择要加载文件，此重载可能会很有用，因为 <xref:System.IO.Stream> 是其他可以访问文件系统的 <xref:System.IO> API 的常见输出。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-117">This overload might be useful if you have the user choose files to load, because a <xref:System.IO.Stream> is a frequent output of other <xref:System.IO> APIs that can access a file system.</span></span> <span data-ttu-id="d6f5f-118">或者，你可以通过异步下载或其他也提供流的网络技术来访问 XAML 源。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-118">Or you could be accessing XAML sources through asynchronous downloads or other network techniques that also provide a stream.</span></span> <span data-ttu-id="d6f5f-119">（从流或用户选择的源进行加载可能出现安全问题。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-119">(Loading from a stream or user-selected source may have security implications.</span></span> <span data-ttu-id="d6f5f-120">有关详细信息，请参阅 [XAML Security Considerations](security-considerations.md)。）</span><span class="sxs-lookup"><span data-stu-id="d6f5f-120">For more information, see [XAML Security Considerations](security-considerations.md).)</span></span>

<span data-ttu-id="d6f5f-121"><xref:System.Xaml.XamlServices.Load%28System.IO.TextReader%29> 和 <xref:System.Xaml.XamlServices.Load%28System.Xml.XmlReader%29> 是依赖于早期版本的 .net 中的格式读取器的重载。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-121"><xref:System.Xaml.XamlServices.Load%28System.IO.TextReader%29> and <xref:System.Xaml.XamlServices.Load%28System.Xml.XmlReader%29> are overloads that rely on readers of formats from previous versions of .NET.</span></span> <span data-ttu-id="d6f5f-122">若要使用这些重载，应已创建一个读取器实例并使用其 `Create` API 将 XAML 加载到相关窗体中 (text 或 XML) 。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-122">To use these overloads, you should have already created a reader instance and used its `Create` API to load the XAML in the relevant form (text or XML).</span></span> <span data-ttu-id="d6f5f-123">如果你已经在其他读取器中移动了记录指针或对它们执行了其他操作，这就不重要了。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-123">If you have already moved record pointers in the other readers or performed other operations with them, this is not important.</span></span> <span data-ttu-id="d6f5f-124"><xref:System.Xaml.XamlServices.Load%2A> 的负载路径逻辑始终处理整个根下的 XAML 输入。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-124">The load path logic from <xref:System.Xaml.XamlServices.Load%2A> always processes the entire XAML input from the root down.</span></span> <span data-ttu-id="d6f5f-125">以下方案可能保证使用以下重载：</span><span class="sxs-lookup"><span data-stu-id="d6f5f-125">The following scenarios might warrant the use of these overloads:</span></span>

- <span data-ttu-id="d6f5f-126">设计图面，其中你从现有的特定于 XML 的文本编辑器提供简单的 XAML 编辑功能。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-126">Design surfaces where you provide simple XAML editing capability from an existing XML-specific text editor.</span></span>

- <span data-ttu-id="d6f5f-127">核心 <xref:System.IO> 方案的变体，你可以在其中使用专用的读取器打开文件或流。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-127">Variants of the core <xref:System.IO> scenarios, where you use the dedicated readers to open files or streams.</span></span> <span data-ttu-id="d6f5f-128">你的逻辑在尝试将内容加载为 XAML 之前对其执行初步检查或处理。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-128">Your logic performs rudimentary checking or processing of the contents before it tries to load as XAML.</span></span>

<span data-ttu-id="d6f5f-129">可以加载文件或流，或者可以加载 <xref:System.Xml.XmlReader> 、 <xref:System.IO.TextReader> 或， <xref:System.Xaml.XamlReader> 通过使用读取器的 api 进行加载来包装 XAML 输入。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-129">You can either load a file or stream, or you can load an <xref:System.Xml.XmlReader>, <xref:System.IO.TextReader>, or <xref:System.Xaml.XamlReader> that wraps your XAML input by loading with the reader's APIs.</span></span>

<span data-ttu-id="d6f5f-130">在内部，每个前面的重载最终为 <xref:System.Xaml.XamlServices.Load%28System.Xml.XmlReader%29>，且传递的 <xref:System.Xml.XmlReader> 用于创建一个新的 <xref:System.Xaml.XamlXmlReader>。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-130">Internally, each of the preceding overloads is ultimately <xref:System.Xaml.XamlServices.Load%28System.Xml.XmlReader%29>, and the passed <xref:System.Xml.XmlReader> is used to create a new <xref:System.Xaml.XamlXmlReader>.</span></span>

<span data-ttu-id="d6f5f-131">为更高级方案提供的 `Load` 签名是 <xref:System.Xaml.XamlServices.Load%28System.Xaml.XamlReader%29>。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-131">The `Load` signature that provides for more advanced scenarios is <xref:System.Xaml.XamlServices.Load%28System.Xaml.XamlReader%29>.</span></span> <span data-ttu-id="d6f5f-132">在以下情况之一，可以使用此签名：</span><span class="sxs-lookup"><span data-stu-id="d6f5f-132">You can use this signature for one of the following cases:</span></span>

- <span data-ttu-id="d6f5f-133">你已定义自己的实现 <xref:System.Xaml.XamlReader> 。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-133">You've defined your own implementation of a <xref:System.Xaml.XamlReader>.</span></span>

- <span data-ttu-id="d6f5f-134">你需要指定与默认设置不同的 <xref:System.Xaml.XamlReader> 设置。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-134">You need to specify settings for <xref:System.Xaml.XamlReader> that vary from the default settings.</span></span>

<span data-ttu-id="d6f5f-135">非默认设置的示例：</span><span class="sxs-lookup"><span data-stu-id="d6f5f-135">Examples of non-default settings:</span></span>

<xref:System.Xaml.XamlReaderSettings.AllowProtectedMembersOnRoot%2A>\
<xref:System.Xaml.XamlReaderSettings.BaseUri%2A>\
<xref:System.Xaml.XamlReaderSettings.IgnoreUidsOnPropertyElements%2A>\
<xref:System.Xaml.XamlReaderSettings.LocalAssembly%2A>\
<span data-ttu-id="d6f5f-136"><xref:System.Xaml.XamlReaderSettings.ValuesMustBeString%2A>.</span><span class="sxs-lookup"><span data-stu-id="d6f5f-136"><xref:System.Xaml.XamlReaderSettings.ValuesMustBeString%2A>.</span></span>

<span data-ttu-id="d6f5f-137"><xref:System.Xaml.XamlServices> 的默认读取器是 <xref:System.Xaml.XamlXmlReader>。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-137">The default reader for <xref:System.Xaml.XamlServices> is <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="d6f5f-138">如果您提供自己 <xref:System.Xaml.XamlXmlReader> 的 with settings，以下是设置为非默认值的属性 <xref:System.Xaml.XamlXmlReaderSettings> ：</span><span class="sxs-lookup"><span data-stu-id="d6f5f-138">If you provide your own <xref:System.Xaml.XamlXmlReader> with settings, the following are properties to set non-default <xref:System.Xaml.XamlXmlReaderSettings>:</span></span>

<xref:System.Xaml.XamlXmlReaderSettings.CloseInput%2A>\
<xref:System.Xaml.XamlXmlReaderSettings.SkipXmlCompatibilityProcessing%2A>\
<xref:System.Xaml.XamlXmlReaderSettings.XmlLang%2A>\
<xref:System.Xaml.XamlXmlReaderSettings.XmlSpacePreserve%2A>

## <a name="parse"></a><span data-ttu-id="d6f5f-139">分析</span><span class="sxs-lookup"><span data-stu-id="d6f5f-139">Parse</span></span>

<span data-ttu-id="d6f5f-140"><xref:System.Xaml.XamlServices.Parse%2A> 就像 `Load` ，因为它是从 XAML 输入创建 XAML 节点流的负载路径 API。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-140"><xref:System.Xaml.XamlServices.Parse%2A> is like `Load` because it is a load path API that creates a XAML node stream from XAML input.</span></span> <span data-ttu-id="d6f5f-141">但是，在这种情况下，XAML 输入直接作为一个字符串提供，其中包含所有要加载的 XAML。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-141">However, in this case, the XAML input is provided directly as a string that contains all the XAML to load.</span></span> <span data-ttu-id="d6f5f-142"><xref:System.Xaml.XamlServices.Parse%2A> 是一种轻量级方法，与框架方案相比更适合应用程序方案。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-142"><xref:System.Xaml.XamlServices.Parse%2A> is a lightweight approach that is more appropriate for application scenarios than framework scenarios.</span></span> <span data-ttu-id="d6f5f-143">有关详细信息，请参阅 <xref:System.Xaml.XamlServices.Parse%2A>。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-143">For more information, see <xref:System.Xaml.XamlServices.Parse%2A>.</span></span> <span data-ttu-id="d6f5f-144"><xref:System.Xaml.XamlServices.Parse%2A> 只是一个在 <xref:System.Xaml.XamlServices.Load%28System.Xml.XmlReader%29> 内部涉及的包装调用 <xref:System.IO.StringReader> 。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-144"><xref:System.Xaml.XamlServices.Parse%2A> is just a wrapped <xref:System.Xaml.XamlServices.Load%28System.Xml.XmlReader%29> call that involves a <xref:System.IO.StringReader> internally.</span></span>

## <a name="save"></a><span data-ttu-id="d6f5f-145">保存</span><span class="sxs-lookup"><span data-stu-id="d6f5f-145">Save</span></span>

<span data-ttu-id="d6f5f-146">的各种重载 <xref:System.Xaml.XamlServices.Save%2A> 实现保存路径。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-146">Various overloads of <xref:System.Xaml.XamlServices.Save%2A> implement the save path.</span></span> <span data-ttu-id="d6f5f-147">所有 <xref:System.Xaml.XamlServices.Save%2A> 方法都采用对象图作为输入，并生成流、文件或 <xref:System.Xml.XmlWriter>/<xref:System.IO.TextWriter> 实例形式的输出。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-147">All of the <xref:System.Xaml.XamlServices.Save%2A> methods all take an object graph as input and produce output as a stream, file, or <xref:System.Xml.XmlWriter>/<xref:System.IO.TextWriter> instance.</span></span>

<span data-ttu-id="d6f5f-148">输入对象预期为某些对象表示形式的根对象。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-148">The input object is expected to be the root object of some object representation.</span></span> <span data-ttu-id="d6f5f-149">这可能是业务对象的单个根、UI 方案中页的对象树的根、设计工具的工作编辑界面或适用于方案的其他根对象概念。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-149">This might be the single root of a business object, the root of an object tree for a page in a UI scenario, the working editing surface from a design tool, or other root object concepts that are appropriate for scenarios.</span></span>

<span data-ttu-id="d6f5f-150">在许多情况下，你保存的对象树与加载 XAML 的原始操作相关，该操作与 <xref:System.Xaml.XamlServices.Load%2A> 或框架/应用程序模型实现的其他 API 一起加载。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-150">In many scenarios, the object tree that you save is related to an original operation that loaded XAML either with <xref:System.Xaml.XamlServices.Load%2A> or with other API implemented by a framework/application model.</span></span> <span data-ttu-id="d6f5f-151">可能会在对象树中捕获到差异，产生这些差异的原因可能是状态更改，可能是应用程序捕获来自用户的运行时设置处的更改，或者是 XAML 变更，因为你的应用程序是 XAML 设计界面等原因。无论是否有更改，从标记首次加载 XAML 然后再次将其保存并比较两个 XAML 标记形式，这整个概念有时会被称为 XAML 的往返过程表示形式。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-151">There might be differences captured in the object tree that are due to state changes, changes where your application captured runtime settings from a user, changed XAML because your application is a XAML design surface, etc. With or without changes, the concept of first loading XAML from markup and then saving it again and comparing the two XAML markup forms is sometimes referred as a round-trip representation of the XAML.</span></span>

<span data-ttu-id="d6f5f-152">保持和序列化以标记形式设置的复杂对象这一操作面临的挑战是实现完全表示形式而不丢失信息与减少导致 XAML 可读性降低的冗繁信息之间的平衡。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-152">The challenge with saving and serializing a complex object that is set in a markup form is in achieving a balance between full representation without information loss, versus verbosity that makes the XAML less human-readable.</span></span> <span data-ttu-id="d6f5f-153">此外，XAML 的不同客户可能对应该如何实现这种平衡有不同的定义或期望。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-153">Moreover, different customers for XAML might have different definitions or expectations for how that balance should be set.</span></span> <span data-ttu-id="d6f5f-154"><xref:System.Xaml.XamlServices.Save%2A> API 表示这种平衡的一个定义。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-154">The <xref:System.Xaml.XamlServices.Save%2A> APIs represent one definition of that balance.</span></span> <span data-ttu-id="d6f5f-155"><xref:System.Xaml.XamlServices.Save%2A> API 使用可用的 XAML 架构上下文和 <xref:System.Xaml.XamlType>、 <xref:System.Xaml.XamlMember>的默认的基于 CLR 的特征以及其他 XAML 内部函数和 XAML 类型系统概念，以确定在将某些 XAML 节点流构造保存回标记时可以在何处优化它们。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-155">The <xref:System.Xaml.XamlServices.Save%2A> APIs use available XAML schema context and the default CLR-based characteristics of <xref:System.Xaml.XamlType>, <xref:System.Xaml.XamlMember>, and other XAML intrinsic and XAML type system concepts to determine where certain XAML node stream constructs can be optimized when they are saved back into markup.</span></span> <span data-ttu-id="d6f5f-156">例如， <xref:System.Xaml.XamlServices> 保存路径可使用基于 CLR 的默认 XAML 架构上下文来解析对象的 <xref:System.Xaml.XamlType> ，这可以确定一个 <xref:System.Xaml.XamlType.ContentProperty%2A?displayProperty=nameWithType>，然后可以在属性元素标记将属性写入对象的 XAML 内容时将其省略。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-156">For example, <xref:System.Xaml.XamlServices> save paths can use CLR-based default XAML schema context to resolve <xref:System.Xaml.XamlType> for objects, can determine a <xref:System.Xaml.XamlType.ContentProperty%2A?displayProperty=nameWithType>, and then can omit property element tags when they write the property to the XAML content of the object.</span></span>

<a name="transform"></a>
## <a name="transform"></a><span data-ttu-id="d6f5f-157">转换</span><span class="sxs-lookup"><span data-stu-id="d6f5f-157">Transform</span></span>

<span data-ttu-id="d6f5f-158">通过链接一个加载路径或保存路径作为单个操作，<xref:System.Xaml.XamlServices.Transform%2A> 会转换或变换 XAML。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-158"><xref:System.Xaml.XamlServices.Transform%2A> converts or transforms XAML by linking a load path and a save path as a single operation.</span></span> <span data-ttu-id="d6f5f-159">可以将不同的架构上下文或不同的后备类型系统用于 <xref:System.Xaml.XamlReader> 和 <xref:System.Xaml.XamlWriter>，这会影响如何转换产生的 XAML。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-159">A different schema context or different backing type system can be used for <xref:System.Xaml.XamlReader> and <xref:System.Xaml.XamlWriter>, which is what influences how the resulting XAML is transformed.</span></span> <span data-ttu-id="d6f5f-160">这非常适合广泛的转换操作。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-160">This works well for broad transform operations.</span></span>

<span data-ttu-id="d6f5f-161">对于依赖于检查 XAML 节点流中每个节点的操作，通常不使用 <xref:System.Xaml.XamlServices.Transform%2A>。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-161">For operations that rely on examining each node in a XAML node stream, you typically do not use <xref:System.Xaml.XamlServices.Transform%2A>.</span></span> <span data-ttu-id="d6f5f-162">相反，你需要定义自己的加载路径-保存路径操作系列并插入自己的逻辑。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-162">Instead you need to define your own load path-save path operation series and interject your own logic.</span></span> <span data-ttu-id="d6f5f-163">在其中一个路径，在你自己的节点循环中使用 XAML 读取器/XAML 编写器对。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-163">In one of the paths, use a XAML reader/XAML writer pair around your own node loop.</span></span> <span data-ttu-id="d6f5f-164">例如，使用 <xref:System.Xaml.XamlXmlReader> 加载初始 XAML 并使用连续的 <xref:System.Xaml.XamlXmlReader.Read%2A> 调用单步执行节点。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-164">For example, load the initial XAML using <xref:System.Xaml.XamlXmlReader> and step into the nodes with successive <xref:System.Xaml.XamlXmlReader.Read%2A> calls.</span></span> <span data-ttu-id="d6f5f-165">在 XAML 节点流级别操作现在可以调整各个节点（类型、成员、其他节点）以应用转换，或将节点保持原样。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-165">Operating at the XAML node stream level you can now adjust individual nodes (types, members, other nodes) to apply a transformation, or leave the node as-is.</span></span> <span data-ttu-id="d6f5f-166">然后开始将节点发送到 `Write` 的相关 <xref:System.Xaml.XamlObjectWriter> API 并写出对象。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-166">Then you send the node onwards to the relevant `Write` API of a <xref:System.Xaml.XamlObjectWriter> and write out the object.</span></span> <span data-ttu-id="d6f5f-167">有关更多信息，请参见 [Understanding XAML Node Stream Structures and Concepts](understanding-xaml-node-stream-structures-and-concepts.md)。</span><span class="sxs-lookup"><span data-stu-id="d6f5f-167">For more information, see [Understanding XAML Node Stream Structures and Concepts](understanding-xaml-node-stream-structures-and-concepts.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="d6f5f-168">另请参阅</span><span class="sxs-lookup"><span data-stu-id="d6f5f-168">See also</span></span>

- <xref:System.Xaml.XamlObjectWriter>
- <xref:System.Xaml.XamlServices>
- [<span data-ttu-id="d6f5f-169">XAML 服务</span><span class="sxs-lookup"><span data-stu-id="d6f5f-169">XAML Services</span></span>](/dotnet/api/)
