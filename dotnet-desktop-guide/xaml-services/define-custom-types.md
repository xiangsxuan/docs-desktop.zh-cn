---
title: 定义与 .NET XAML 服务一起使用的自定义类型
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: 2af59edfac430a1804cff3ffb0ab34df6b550f0a
ms.sourcegitcommit: 9f6df084c53a3da0ea657ed0d708a72213683084
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/09/2020
ms.locfileid: "96974022"
---
# <a name="define-custom-types-for-use-with-net-xaml-services"></a><span data-ttu-id="6c441-102">定义与 .NET XAML 服务一起使用的自定义类型</span><span class="sxs-lookup"><span data-stu-id="6c441-102">Define custom types for use with .NET XAML Services</span></span>

<span data-ttu-id="6c441-103">在定义作为业务对象的自定义类型或不依赖于特定框架的类型时，可以遵循 XAML 的某些最佳实践。</span><span class="sxs-lookup"><span data-stu-id="6c441-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="6c441-104">如果遵循这些做法，.NET XAML 服务及其 XAML 读取器和 XAML 编写器可以发现类型的 XAML 特征，并使用 XAML 类型系统在 XAML 节点流中为其指定适当的表示形式。</span><span class="sxs-lookup"><span data-stu-id="6c441-104">If you follow these practices, .NET XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="6c441-105">本主题介绍类型定义、成员定义和类型或成员的 CLR 特性的最佳实践。</span><span class="sxs-lookup"><span data-stu-id="6c441-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>

## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="6c441-106">XAML 的构造函数模式和类型定义</span><span class="sxs-lookup"><span data-stu-id="6c441-106">Constructor Patterns and Type Definitions for XAML</span></span>

<span data-ttu-id="6c441-107">若要在 XAML 中实例化为对象元素，自定义类必须满足以下要求：</span><span class="sxs-lookup"><span data-stu-id="6c441-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>

- <span data-ttu-id="6c441-108">自定义类必须是公共的，并且必须公开无参数的公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="6c441-108">The custom class must be public and must expose a parameterless public constructor.</span></span> <span data-ttu-id="6c441-109">（有关结构注释，请参阅下节内容。）</span><span class="sxs-lookup"><span data-stu-id="6c441-109">(See following section for notes regarding structures.)</span></span>

- <span data-ttu-id="6c441-110">自定义类不得为嵌套类。</span><span class="sxs-lookup"><span data-stu-id="6c441-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="6c441-111">完整名称路径中的多余 "点" 使类命名空间除法不明确，并与附加属性等其他 XAML 功能发生冲突。</span><span class="sxs-lookup"><span data-stu-id="6c441-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>
<span data-ttu-id="6c441-112">如果对象可以实例化为对象元素，则创建的对象可以填充任何将对象作为其基础类型的属性的属性元素形式。</span><span class="sxs-lookup"><span data-stu-id="6c441-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>

<span data-ttu-id="6c441-113">如果启用值转换器，则仍可为不满足这些条件的类型提供对象值。</span><span class="sxs-lookup"><span data-stu-id="6c441-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="6c441-114">有关详细信息，请参阅 [XAML 的类型转换器和标记扩展](type-converters-and-markup-extensions.md)。</span><span class="sxs-lookup"><span data-stu-id="6c441-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

### <a name="structures"></a><span data-ttu-id="6c441-115">結構</span><span class="sxs-lookup"><span data-stu-id="6c441-115">Structures</span></span>

<span data-ttu-id="6c441-116">结构始终能够按 CLR 定义在 XAML 中构造。</span><span class="sxs-lookup"><span data-stu-id="6c441-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="6c441-117">这是因为 CLR 编译器会为结构隐式创建一个无参数的构造函数。</span><span class="sxs-lookup"><span data-stu-id="6c441-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="6c441-118">此构造函数将所有属性值初始化为其默认值。</span><span class="sxs-lookup"><span data-stu-id="6c441-118">This constructor initializes all property values to their defaults.</span></span>

<span data-ttu-id="6c441-119">在某些情况下，结构的默认构造行为并不理想。</span><span class="sxs-lookup"><span data-stu-id="6c441-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="6c441-120">这可能是因为结构旨在将值和函数作为联合填充。</span><span class="sxs-lookup"><span data-stu-id="6c441-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="6c441-121">作为联合，包含的值可能具有互斥的解释，因此，其所有属性都是可设置的。</span><span class="sxs-lookup"><span data-stu-id="6c441-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="6c441-122">WPF 词汇中的此类结构的一个示例是 <xref:System.Windows.GridLength> 。</span><span class="sxs-lookup"><span data-stu-id="6c441-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="6c441-123">此类结构应实现类型转换器，以便可以使用创建结构值的不同解释或模式的字符串约定来用属性形式表示值。</span><span class="sxs-lookup"><span data-stu-id="6c441-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="6c441-124">结构还应通过非参数构造函数公开代码构造的类似行为。</span><span class="sxs-lookup"><span data-stu-id="6c441-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>

### <a name="interfaces"></a><span data-ttu-id="6c441-125">界面</span><span class="sxs-lookup"><span data-stu-id="6c441-125">Interfaces</span></span>

<span data-ttu-id="6c441-126">接口可用作成员的基础类型。</span><span class="sxs-lookup"><span data-stu-id="6c441-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="6c441-127">XAML 类型系统检查可赋值列表，并期望作为值提供的对象可以分配给接口。</span><span class="sxs-lookup"><span data-stu-id="6c441-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="6c441-128">只要相关的可赋值类型支持 XAML 构造要求，就必须将接口呈现为 XAML 类型。</span><span class="sxs-lookup"><span data-stu-id="6c441-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>

### <a name="factory-methods"></a><span data-ttu-id="6c441-129">工厂方法</span><span class="sxs-lookup"><span data-stu-id="6c441-129">Factory Methods</span></span>

<span data-ttu-id="6c441-130">工厂方法为 XAML 2009 功能。</span><span class="sxs-lookup"><span data-stu-id="6c441-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="6c441-131">它们修改了对象必须具有无参数构造函数的 XAML 原则。</span><span class="sxs-lookup"><span data-stu-id="6c441-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="6c441-132">本文未介绍工厂方法。</span><span class="sxs-lookup"><span data-stu-id="6c441-132">Factory methods are not documented in this article.</span></span> <span data-ttu-id="6c441-133">请参阅 [X:FactoryMethod 指令](xfactorymethod-directive.md)。</span><span class="sxs-lookup"><span data-stu-id="6c441-133">See [x:FactoryMethod Directive](xfactorymethod-directive.md).</span></span>

## <a name="enumerations"></a><span data-ttu-id="6c441-134">枚举</span><span class="sxs-lookup"><span data-stu-id="6c441-134">Enumerations</span></span>

<span data-ttu-id="6c441-135">枚举具有 XAML 本机类型转换行为。</span><span class="sxs-lookup"><span data-stu-id="6c441-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="6c441-136">XAML 中指定的枚举常量名称根据基础枚举类型进行解析，并将枚举值返回到 XAML 对象编写器。</span><span class="sxs-lookup"><span data-stu-id="6c441-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>

<span data-ttu-id="6c441-137">XAML 支持应用了的枚举的标志样式用法 <xref:System.FlagsAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="6c441-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="6c441-138">有关详细信息，请参阅 [XAML 语法详述](../framework/wpf/advanced/xaml-syntax-in-detail.md)。</span><span class="sxs-lookup"><span data-stu-id="6c441-138">For more information, see [XAML Syntax In Detail](../framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="6c441-139"> ([Xaml 语法](../framework/wpf/advanced/xaml-syntax-in-detail.md) 是针对 WPF 受众编写的，但该主题中的大部分信息与不特定于特定实现框架的 xaml 相关。 ) </span><span class="sxs-lookup"><span data-stu-id="6c441-139">([XAML Syntax In Detail](../framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>

## <a name="member-definitions"></a><span data-ttu-id="6c441-140">成员定义</span><span class="sxs-lookup"><span data-stu-id="6c441-140">Member Definitions</span></span>

<span data-ttu-id="6c441-141">类型可以为 XAML 用法定义成员。</span><span class="sxs-lookup"><span data-stu-id="6c441-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="6c441-142">类型可以定义即使是 XAML 可用的成员，即使特定类型不能使用 XAML。</span><span class="sxs-lookup"><span data-stu-id="6c441-142">It's possible for types to define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="6c441-143">这是可能的，因为 CLR 继承。</span><span class="sxs-lookup"><span data-stu-id="6c441-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="6c441-144">只要继承成员的某个类型支持 XAML 用法作为类型，且该成员支持其基础类型的 XAML 用法或具有可用的本机 XAML 语法，则该成员是 XAML 可用的。</span><span class="sxs-lookup"><span data-stu-id="6c441-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>

### <a name="properties"></a><span data-ttu-id="6c441-145">属性</span><span class="sxs-lookup"><span data-stu-id="6c441-145">Properties</span></span>

<span data-ttu-id="6c441-146">如果你使用典型的 CLR 和访问器模式以及与语言相关的 keywording 将属性定义为公共 CLR 属性 `get` `set` ，则 XAML 类型系统可将属性报告为具有为属性提供的适当信息的成员 <xref:System.Xaml.XamlMember> ，如 <xref:System.Xaml.XamlMember.IsReadPublic%2A> 和 <xref:System.Xaml.XamlMember.IsWritePublic%2A> 。</span><span class="sxs-lookup"><span data-stu-id="6c441-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>

<span data-ttu-id="6c441-147">特定属性可通过应用来启用文本语法 <xref:System.ComponentModel.TypeConverterAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="6c441-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="6c441-148">有关详细信息，请参阅 [XAML 的类型转换器和标记扩展](type-converters-and-markup-extensions.md)。</span><span class="sxs-lookup"><span data-stu-id="6c441-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="6c441-149">在缺少文本语法或本机 XAML 转换的情况下，如果没有进一步的间接寻址（如标记扩展用法），则 XAML 类型系统中的属性的类型 (<xref:System.Xaml.XamlMember.TargetType%2A>) 必须能够通过将目标类型视为 CLR 类型，将实例返回到 xaml 对象编写器。</span><span class="sxs-lookup"><span data-stu-id="6c441-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>

<span data-ttu-id="6c441-150">如果使用 XAML 2009，则在未满足前面的注意事项时，可以使用 [X:Reference 标记扩展](xreference-markup-extension.md) 来提供值;但是，这比类型定义问题更是使用问题。</span><span class="sxs-lookup"><span data-stu-id="6c441-150">If using XAML 2009, [x:Reference Markup Extension](xreference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>

### <a name="events"></a><span data-ttu-id="6c441-151">事件</span><span class="sxs-lookup"><span data-stu-id="6c441-151">Events</span></span>

<span data-ttu-id="6c441-152">如果将事件定义为公共 CLR 事件，则 XAML 类型系统可将事件报告为成员，其形式 <xref:System.Xaml.XamlMember.IsEvent%2A> 为 `true` 。</span><span class="sxs-lookup"><span data-stu-id="6c441-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="6c441-153">线路事件处理程序不在 .NET XAML 服务功能的范围内;布线留给特定的框架和实现。</span><span class="sxs-lookup"><span data-stu-id="6c441-153">Wiring the event handlers is not within the scope of .NET XAML Services capabilities; wiring is left to specific frameworks and implementations.</span></span>

### <a name="methods"></a><span data-ttu-id="6c441-154">方法</span><span class="sxs-lookup"><span data-stu-id="6c441-154">Methods</span></span>

<span data-ttu-id="6c441-155">方法的内联代码不是默认的 XAML 功能。</span><span class="sxs-lookup"><span data-stu-id="6c441-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="6c441-156">在大多数情况下，你不会直接从 XAML 引用方法成员，XAML 中的方法的角色只是为特定 XAML 模式提供支持。</span><span class="sxs-lookup"><span data-stu-id="6c441-156">In most cases, you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="6c441-157">[X:FactoryMethod 指令](xfactorymethod-directive.md) 是一个异常。</span><span class="sxs-lookup"><span data-stu-id="6c441-157">[x:FactoryMethod Directive](xfactorymethod-directive.md) is an exception.</span></span>

### <a name="fields"></a><span data-ttu-id="6c441-158">字段</span><span class="sxs-lookup"><span data-stu-id="6c441-158">Fields</span></span>

<span data-ttu-id="6c441-159">CLR 设计准则不鼓励非静态字段。</span><span class="sxs-lookup"><span data-stu-id="6c441-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="6c441-160">对于静态字段，只能通过 [X:Static 标记扩展](xstatic-markup-extension.md)访问静态字段值;在这种情况下，你不会在 CLR 定义中执行任何特殊操作来公开 [x:Static](xstatic-markup-extension.md) 使用的字段。</span><span class="sxs-lookup"><span data-stu-id="6c441-160">For static fields, you can access static field values only through [x:Static Markup Extension](xstatic-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](xstatic-markup-extension.md) usages.</span></span>

## <a name="attachable-members"></a><span data-ttu-id="6c441-161">可附加成员</span><span class="sxs-lookup"><span data-stu-id="6c441-161">Attachable Members</span></span>

<span data-ttu-id="6c441-162">可附加成员通过定义类型的访问器方法模式向 XAML 公开。</span><span class="sxs-lookup"><span data-stu-id="6c441-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="6c441-163">定义类型本身无需作为对象使用 XAML。</span><span class="sxs-lookup"><span data-stu-id="6c441-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="6c441-164">事实上，一种常见的模式是声明一个服务类，该服务类的角色将拥有该可附加成员，并实现相关的行为，但不会提供任何其他函数（如 UI 表示形式）。</span><span class="sxs-lookup"><span data-stu-id="6c441-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="6c441-165">对于以下各节，placeholder *属性* 名称表示可附加成员的名称。</span><span class="sxs-lookup"><span data-stu-id="6c441-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="6c441-166">该名称在 [XamlName 语法](xamlname-grammar.md)中必须有效。</span><span class="sxs-lookup"><span data-stu-id="6c441-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>

<span data-ttu-id="6c441-167">请注意这些模式与类型的其他方法之间的名称冲突。</span><span class="sxs-lookup"><span data-stu-id="6c441-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="6c441-168">如果存在与某个模式匹配的成员，则它可以被 XAML 处理器解释为可附加成员使用通道，即使这不是你的意图。</span><span class="sxs-lookup"><span data-stu-id="6c441-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>

#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="6c441-169">GetPropertyName 访问器</span><span class="sxs-lookup"><span data-stu-id="6c441-169">The GetPropertyName Accessor</span></span>

<span data-ttu-id="6c441-170">访问器的签名 `GetPropertyName` 必须是：</span><span class="sxs-lookup"><span data-stu-id="6c441-170">The signature for the `GetPropertyName` accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="6c441-171">`target` 对象在实现中可以指定为更具体的类型。</span><span class="sxs-lookup"><span data-stu-id="6c441-171">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="6c441-172">可以使用它来确定可附加成员的使用范围;预期范围外的使用情况将引发无效的强制转换异常，然后由 XAML 分析错误引发。</span><span class="sxs-lookup"><span data-stu-id="6c441-172">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="6c441-173">参数名称 `target` 不是必需的，但 `target` 在大多数实现中按约定命名。</span><span class="sxs-lookup"><span data-stu-id="6c441-173">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>

- <span data-ttu-id="6c441-174">返回值在实现中可以指定为更具体的类型。</span><span class="sxs-lookup"><span data-stu-id="6c441-174">The return value can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="6c441-175">若要支持可 <xref:System.ComponentModel.TypeConverter> 附加成员的属性用法的已启用文本语法，请将应用于 <xref:System.ComponentModel.TypeConverterAttribute> 该 `GetPropertyName` 访问器。</span><span class="sxs-lookup"><span data-stu-id="6c441-175">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `GetPropertyName` accessor.</span></span> <span data-ttu-id="6c441-176">应用到 `get` 而不是 `set` 直观的; 但是，此约定可以支持可序列化的只读可附加成员的概念，这在设计器方案中非常有用。</span><span class="sxs-lookup"><span data-stu-id="6c441-176">Applying to the `get` instead of the `set` may seem non-intuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>

#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="6c441-177">SetPropertyName 访问器</span><span class="sxs-lookup"><span data-stu-id="6c441-177">The SetPropertyName Accessor</span></span>

<span data-ttu-id="6c441-178">访问器的签名 `SetPropertyName` 必须是：</span><span class="sxs-lookup"><span data-stu-id="6c441-178">The signature for the `SetPropertyName` accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="6c441-179">`target`可以在实现中将对象指定为更具体的类型，与上一节中所述的逻辑和结果相同。</span><span class="sxs-lookup"><span data-stu-id="6c441-179">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>

- <span data-ttu-id="6c441-180">`value` 对象在实现中可以指定为更具体的类型。</span><span class="sxs-lookup"><span data-stu-id="6c441-180">The `value` object can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="6c441-181">请记住，此方法的值是来自 XAML 使用情况的输入，通常采用属性格式。</span><span class="sxs-lookup"><span data-stu-id="6c441-181">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="6c441-182">从属性窗体中，必须提供文本语法的值转换器支持，并在 `GetPropertyName` s 访问器上进行属性。</span><span class="sxs-lookup"><span data-stu-id="6c441-182">From attribute form there must be value converter support for a text syntax, and you attribute on the `GetPropertyName`s accessor.</span></span>

### <a name="attachable-member-stores"></a><span data-ttu-id="6c441-183">可附加成员存储</span><span class="sxs-lookup"><span data-stu-id="6c441-183">Attachable Member Stores</span></span>

<span data-ttu-id="6c441-184">通常，访问器方法不能提供将可附加成员值置于对象图中的方法，也不能从对象图中检索值并正确地对其进行序列化。</span><span class="sxs-lookup"><span data-stu-id="6c441-184">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="6c441-185">为了提供此功能， `target` 之前的访问器签名中的对象必须能够存储值。</span><span class="sxs-lookup"><span data-stu-id="6c441-185">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="6c441-186">存储机制应该与可附加成员原则一致，成员可附加到可附加成员不在成员列表中的目标。</span><span class="sxs-lookup"><span data-stu-id="6c441-186">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="6c441-187">.NET XAML 服务为可附加的成员存储提供通过 Api 和的实现技术 <xref:System.Xaml.IAttachedPropertyStore> <xref:System.Xaml.AttachablePropertyServices> 。</span><span class="sxs-lookup"><span data-stu-id="6c441-187">.NET XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="6c441-188"><xref:System.Xaml.IAttachedPropertyStore> 由 XAML 编写器用于发现存储实现，并且应在作为访问器的类型的类型上实现 `target` 。</span><span class="sxs-lookup"><span data-stu-id="6c441-188"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="6c441-189">静态 <xref:System.Xaml.AttachablePropertyServices> api 在访问器的主体中使用，并通过其引用可附加成员 <xref:System.Xaml.AttachableMemberIdentifier> 。</span><span class="sxs-lookup"><span data-stu-id="6c441-189">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>

## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="6c441-190">XAML-Related CLR 特性</span><span class="sxs-lookup"><span data-stu-id="6c441-190">XAML-Related CLR Attributes</span></span>

<span data-ttu-id="6c441-191">正确地对类型、成员和程序集进行排序非常重要，因为要将 XAML 类型系统信息报告给 .NET XAML 服务。</span><span class="sxs-lookup"><span data-stu-id="6c441-191">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET XAML Services.</span></span> <span data-ttu-id="6c441-192">如果以下任一情况适用，则报告 XAML 类型系统信息是相关的：</span><span class="sxs-lookup"><span data-stu-id="6c441-192">Reporting XAML type system information is relevant if either of the following situations apply:</span></span>

- <span data-ttu-id="6c441-193">您希望您的类型与直接基于 .NET XAML 服务 XAML 读取器和 XAML 编写器的 XAML 系统一起使用。</span><span class="sxs-lookup"><span data-stu-id="6c441-193">You intend your types for use with XAML systems that are directly based on .NET XAML Services XAML readers and XAML writers.</span></span>
- <span data-ttu-id="6c441-194">定义或使用基于 xaml 读取器和 XAML 编写器的 XAML 利用框架。</span><span class="sxs-lookup"><span data-stu-id="6c441-194">You define or use a XAML-utilizing framework that's based on those XAML readers and XAML writers.</span></span>

<span data-ttu-id="6c441-195">有关与自定义类型的 XAML 支持相关的每个与 XAML 相关的属性的列表，请参阅 [自定义类型和库的 Xaml 相关 CLR 特性](clr-attributes-with-custom-types-and-libraries.md)。</span><span class="sxs-lookup"><span data-stu-id="6c441-195">For a listing of each XAML-related attribute that's relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](clr-attributes-with-custom-types-and-libraries.md).</span></span>

## <a name="usage"></a><span data-ttu-id="6c441-196">使用情况</span><span class="sxs-lookup"><span data-stu-id="6c441-196">Usage</span></span>

<span data-ttu-id="6c441-197">使用自定义类型需要标记作者必须为包含自定义类型的程序集和 CLR 命名空间映射前缀。</span><span class="sxs-lookup"><span data-stu-id="6c441-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="6c441-198">本主题不介绍此过程。</span><span class="sxs-lookup"><span data-stu-id="6c441-198">This procedure is not documented in this topic.</span></span>

## <a name="access-level"></a><span data-ttu-id="6c441-199">访问级别</span><span class="sxs-lookup"><span data-stu-id="6c441-199">Access Level</span></span>

<span data-ttu-id="6c441-200">XAML 提供了一个方法，用于加载和实例化具有 `internal` 访问级别的类型。</span><span class="sxs-lookup"><span data-stu-id="6c441-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="6c441-201">提供此功能的目的是使用户代码可以定义自己的类型，然后从同时也属于相同用户代码范围的标记中实例化这些类。</span><span class="sxs-lookup"><span data-stu-id="6c441-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>

<span data-ttu-id="6c441-202">无论何时，用户代码定义 <xref:System.Windows.Controls.UserControl> 旨在作为重构 UI 行为的方法的一个示例，而不是作为可能通过使用访问级别声明支持类而隐含的任何可能的扩展机制的一部分 `public` 。</span><span class="sxs-lookup"><span data-stu-id="6c441-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="6c441-203">如果将 <xref:System.Windows.Controls.UserControl> `internal` 支持代码编译到将其作为 XAML 类型引用的同一程序集中，则可以使用 access 声明此类。</span><span class="sxs-lookup"><span data-stu-id="6c441-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>

<span data-ttu-id="6c441-204">对于在完全信任的情况下加载 XAML 并使用的应用程序 <xref:System.Xaml.XamlObjectWriter> ， `internal` 将始终启用加载具有访问级别的类。</span><span class="sxs-lookup"><span data-stu-id="6c441-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>

<span data-ttu-id="6c441-205">对于在部分信任环境下加载 XAML 的应用程序，可以使用 API 来控制访问级别特性 <xref:System.Xaml.Permissions.XamlAccessLevel> 。</span><span class="sxs-lookup"><span data-stu-id="6c441-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="6c441-206">此外，延迟机制 (如 WPF 模板系统) 必须能够传播任何访问级别权限，并在最终运行时评估时保留这些权限;这是通过传递信息在内部处理的 <xref:System.Xaml.Permissions.XamlAccessLevel> 。</span><span class="sxs-lookup"><span data-stu-id="6c441-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>

### <a name="wpf-implementation"></a><span data-ttu-id="6c441-207">WPF 实现</span><span class="sxs-lookup"><span data-stu-id="6c441-207">WPF Implementation</span></span>

<span data-ttu-id="6c441-208">WPF XAML 使用部分信任访问模型，其中，如果在部分信任环境下加载 BAML，则对 <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> 作为 BAML 源的程序集的访问将受到限制。</span><span class="sxs-lookup"><span data-stu-id="6c441-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="6c441-209">对于延迟，WPF 使用 <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> 作为传递访问级别信息的机制。</span><span class="sxs-lookup"><span data-stu-id="6c441-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>

<span data-ttu-id="6c441-210">在 WPF XAML 术语中， *内部类型* 是由同一程序集定义的类型，该程序集也包括引用 XAML。</span><span class="sxs-lookup"><span data-stu-id="6c441-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="6c441-211">可以通过 XAML 命名空间映射此类类型，该命名空间故意省略映射的 assembly 部分，例如 `xmlns:local="clr-namespace:WPFApplication1"` 。</span><span class="sxs-lookup"><span data-stu-id="6c441-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span> <span data-ttu-id="6c441-212">如果 BAML 引用内部类型，并且该类型具有 `internal` 访问级别，则会 `GeneratedInternalTypeHelper` 为该程序集生成一个类。</span><span class="sxs-lookup"><span data-stu-id="6c441-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="6c441-213">如果你想要避免 `GeneratedInternalTypeHelper` 这种情况，则必须使用 `public` 访问级别，或者必须将相关类因式分解为单独的程序集，并使该程序集依赖。</span><span class="sxs-lookup"><span data-stu-id="6c441-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>

## <a name="see-also"></a><span data-ttu-id="6c441-214">另请参阅</span><span class="sxs-lookup"><span data-stu-id="6c441-214">See also</span></span>

- [<span data-ttu-id="6c441-215">自定义类型和库的 XAML 相关 CLR 特性</span><span class="sxs-lookup"><span data-stu-id="6c441-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](clr-attributes-with-custom-types-and-libraries.md)
- [<span data-ttu-id="6c441-216">XAML 服务</span><span class="sxs-lookup"><span data-stu-id="6c441-216">XAML Services</span></span>](/dotnet/api/)
